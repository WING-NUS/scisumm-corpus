<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">In natural-language discourse, related events tend to appear near each other to describe a larger scenario.</S>
		<S sid ="2" ssid = "2">Such structures can be formalized by the notion of a frame (a.k.a. template), which comprises a set of related events and prototypical participants and event transitions.</S>
		<S sid ="3" ssid = "3">Identifying frames is a prerequisite for information extraction and natural language generation, and is usually done manually.</S>
		<S sid ="4" ssid = "4">Methods for inducing frames have been proposed recently, but they typically use ad hoc procedures and are difficult to diagnose or extend.</S>
		<S sid ="5" ssid = "5">In this paper, we propose the first probabilistic approach to frame induction, which incorporates frames, events, and participants as latent topics and learns those frame and event transitions that best explain the text.</S>
		<S sid ="6" ssid = "6">The number of frame components is inferred by a novel application of a split-merge method from syntactic parsing.</S>
		<S sid ="7" ssid = "7">In end-to-end evaluations from text to induced frames and extracted facts, our method produces state-of-the-art results while substantially reducing engineering effort.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="8" ssid = "8">Events with causal or temporal relations tend to occur near each other in text.</S>
			<S sid ="9" ssid = "9">For example, a BOMBING scenario in an article on terrorism might begin with a DETONATION event, in which terrorists set off a bomb.</S>
			<S sid ="10" ssid = "10">Then, a DAMAGE event might ensue to describe the resulting destruction and any casualties, followed by an INVESTIGATION event ‚àóThis research was undertaken during the author‚Äôs internship at Microsoft Research.</S>
			<S sid ="11" ssid = "11">covering subsequent police investigations.</S>
			<S sid ="12" ssid = "12">Afterwards, the BOMBING scenario may transition into a CRIMINAL-PROCESSING scenario, which begins with police catching the terrorists, and proceeds to a trial, sentencing, etc. A common set of participants serves as the event arguments; e.g., the agent (or subject) of DETONATION is often the same as the theme (or object) of INVESTIGATION and corresponds to a PERPETRATOR.</S>
			<S sid ="13" ssid = "13">Such structures can be formally captured by the notion of a frame (a.k.a. template, scenario), which consists of a set of events with prototypical transitions, as well as a set of slots representing the common participants.</S>
			<S sid ="14" ssid = "14">Identifying frames is an explicit or implicit prerequisite for many NLP tasks.</S>
			<S sid ="15" ssid = "15">Information extraction, for example, stipulates the types of events and slots that are extracted for a frame or template.</S>
			<S sid ="16" ssid = "16">Online applications such as dialogue systems and personal-assistant applications also model users‚Äô goals and subgoals using frame-like representations.</S>
			<S sid ="17" ssid = "17">In natural-language generation, frames are often used to represent contents to be expressed as well as to support surface realization.</S>
			<S sid ="18" ssid = "18">Until recently, frames and related representations have been manually constructed, which has limited their applicability to a relatively small number of domains and a few slots within a domain.</S>
			<S sid ="19" ssid = "19">Furthermore, additional manual effort is needed after the frames are defined in order to extract frame components from text (e.g., in annotating examples and designing features to train a supervised learning model).</S>
			<S sid ="20" ssid = "20">This paradigm makes generalizing across tasks difficult, and might suffer from annotator bias.Recently, there has been increasing interest in au 837 Proceedings of NAACLHLT 2013, pages 837‚Äì846, Atlanta, Georgia, 9‚Äì14 June 2013.</S>
			<S sid ="21" ssid = "21">Qc 2013 Association for Computational Linguistics tomatically inducing frames from text.</S>
			<S sid ="22" ssid = "22">A notable example is Chambers and Jurafsky (2011), which first clusters related verbs to form frames, and then clusters the verbs‚Äô syntactic arguments to identify slots.</S>
			<S sid ="23" ssid = "23">While Chambers and Jurafsky (2011) represents a major step forward in frame induction, it is also limited in several aspects.</S>
			<S sid ="24" ssid = "24">The clustering used ad hoc steps and customized similarity metrics, as well as an additional retrieval step from a large external text corpus for slot generation.</S>
			<S sid ="25" ssid = "25">This makes it hard to replicate their approach or adapt it to new domains.</S>
			<S sid ="26" ssid = "26">Lacking a coherent model, it is also difficult to incorporate additional linguistic insights and prior knowledge.</S>
			<S sid ="27" ssid = "27">In this paper, we present PROFINDER (PRObabilistic Frame INDucER), the first probabilistic approach to frame induction.</S>
			<S sid ="28" ssid = "28">PROFINDER defines a joint distribution over the words in a document and their frame assignments by modeling frame and event transitions, correlations among events and slots, and their surface realizations.</S>
			<S sid ="29" ssid = "29">Given a set of documents, PROFINDER outputs a set of induced frames with learned parameters, as well as the most probable frame assignments that can be used for event and entity extraction.</S>
			<S sid ="30" ssid = "30">The numbers of events and slots are dynamically determined by a novel application of the split-merge approach from syntactic parsing (Petrov et al., 2006).</S>
			<S sid ="31" ssid = "31">In end-to-end evaluations from text to entity extraction using standard MUC and TAC datasets, PROFINDER achieved state-of-the-art results while significantly reducing engineering effort and requiring no external data.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "2">
			<S sid ="32" ssid = "1">In information extraction and other semantic processing tasks, the dominant paradigm requires two stages of manual effort.</S>
			<S sid ="33" ssid = "2">First, the target representation is defined manually by domain experts.</S>
			<S sid ="34" ssid = "3">Then, manual effort is required to construct an extractor or to annotate examples to train a machine-learning system.</S>
			<S sid ="35" ssid = "4">Recently, there has been a burgeoning body of work in reducing such manual effort.</S>
			<S sid ="36" ssid = "5">For example, a popular approach to reduce annotation effort is bootstrapping from seed examples (Patwardhan and Riloff, 2007; Huang and Riloff, 2012).</S>
			<S sid ="37" ssid = "6">However, this still requires prespecified frames or templates, and selecting seed words is often a challenging task (Curran et al., 2007).</S>
			<S sid ="38" ssid = "7">Filatova et al.</S>
			<S sid ="39" ssid = "8">(2006) construct simple domain templates by mining verbs and the named entity type of verbal arguments that are topical, whereas Shinyama and Sekine (2006) identify query-focused slots by clustering common named entities and their syntactic contexts.</S>
			<S sid ="40" ssid = "9">Open IE (Banko and Etzioni, 2008) limits the manual effort to designing a few domain-independent relation patterns, which can then be applied to extract relational triples from text.</S>
			<S sid ="41" ssid = "10">While extremely scalable, this approach can only extract atomic factoids within a sentence, and the resulting triples are noisy, non-canonicalized text fragments.</S>
			<S sid ="42" ssid = "11">More relevant to our approach is the recent work in unsupervised semantic induction, such as unsupervised semantic parsing (Poon and Domingos, 2009), unsupervised semantical role labeling (Swier and Stevenson, 2004) and induction (Lang and Lap- ata, 2011, e.g.), and slot induction from web search logs (Cheung and Li, 2012).</S>
			<S sid ="43" ssid = "12">As in PROFINDER, they model distributional contexts for slots and roles.</S>
			<S sid ="44" ssid = "13">However, these approaches focus on the semantics of independent sentences or queries, and do not capture discourse-level dependencies.</S>
			<S sid ="45" ssid = "14">The modeling of frame and event transitions in PROFINDER is similar to a sequential topic model (Gruber et al., 2007), and is inspired by the successful applications of such topic models in sum- marization (Barzilay and Lee, 2004; Daume¬¥ III and Marcu, 2006; Haghighi and Vanderwende, 2009, inter alia).</S>
			<S sid ="46" ssid = "15">There are, however, two main differences.</S>
			<S sid ="47" ssid = "16">First, PROFINDER contains not a single sequential topic model, but two (for frames and events, respectively).</S>
			<S sid ="48" ssid = "17">In addition, it also models the interdependencies among events, slots, and surface text, which is analogous to the USP model (Poon and Domingos, 2009).</S>
			<S sid ="49" ssid = "18">PROFINDER can thus be viewed as a novel combination of state-of-the-art models in unsupervised semantics and discourse modeling.</S>
			<S sid ="50" ssid = "19">In terms of aim and capability, PROFINDER is most similar to Chambers and Jurafsky (2011), which culminated from a series of work for identifying correlated events and arguments in narratives (Chambers and Jurafsky, 2008; Chambers and Jurafsky, 2009).</S>
			<S sid ="51" ssid = "20">By adopting a probabilistic approach, PROFINDER has a sound theoretical underpinning, and is easy to modify or extend.</S>
			<S sid ="52" ssid = "21">For example, in Section 3, we show how PROFINDER can easily be augmented with additional linguistically-motivated features.</S>
			<S sid ="53" ssid = "22">Likewise, PROFINDER can easily be used as a semi-supervised system if some slot designations and labeled examples are available.</S>
			<S sid ="54" ssid = "23">The idea of representing and capturing stereotypical knowledge has a long history in artificial intelligence and psychology, and has assumed various names such as frames (Minsky, 1974), schemata (Rumelhart, 1975), and scripts (Schank and Abelson, 1977).</S>
			<S sid ="55" ssid = "24">In the linguistics and computational linguistics communities, frame semantics (Fillmore, 1982) uses frames as the central representation of word meaning, culminating in the development of FrameNet (Baker et al., 1998), which contains over 1000 manually annotated frames.</S>
			<S sid ="56" ssid = "25">A similarly rich lexical resource is the MindNet project (Richardson et al., 1998).</S>
			<S sid ="57" ssid = "26">Our notion of frame is related to these representations, but there are also subtle differences.</S>
			<S sid ="58" ssid = "27">For example, Minsky‚Äôs frame emphasizes inheritance, which we do not model in this paper1.</S>
			<S sid ="59" ssid = "28">As in semantic role labeling, FrameNet focuses on semantic roles and does not model event or frame transitions, so the scope of its frames is often no more than an event in our model.</S>
			<S sid ="60" ssid = "29">Perhaps the most similar to our frame is Roger Schank‚Äôs scripts, which capture prototypical events and participants in a scenario such as restaurant dining.</S>
			<S sid ="61" ssid = "30">In their approach, however, scripts are manually defined, making it hard to generalize.</S>
			<S sid ="62" ssid = "31">In this regard, our work may be viewed as an attempt to revive a long tradition in AI and linguistics, by leveraging the recent advances in computational power, NLP, and machine learning.</S>
	</SECTION>
	<SECTION title="Probabilistic Frame Induction. " number = "3">
			<S sid ="63" ssid = "1">In this section, we present PROFINDER, a probabilistic model for frame induction.</S>
			<S sid ="64" ssid = "2">Let F be a set of frames, where each frame F = (EF , SF ) comprises a unique set of events EF and slots SF . Given a document D and a word w in D, Zw = (f, e) repre sents an assignment of w to frame f ‚àà F and frame element e ‚àà Ef ‚à™ Sf . At the heart of PROFINDER is a generative model PŒ∏ (D, Z ) that defines a joint distribution over document D and the frame assignment to its words Z . Given a set of documents D, 1 This should be a straightforward extension ‚Äî using the split-and-merge approach, PROFINDER already produces a hierarchy of events and slots in learning, although currently it makes no use of the intermediate levels.</S>
			<S sid ="65" ssid = "3">frame induction in PROFINDER amounts to determining the number of events and slots in each frame, as well as learning the parameters Œ∏ by summing out the latent assignments Z to maximize the likelihood of the document set n PŒ∏ (D).</S>
			<S sid ="66" ssid = "4">D‚ààD The induced frames identify the key event structures in the document set.</S>
			<S sid ="67" ssid = "5">Additionally, PROFINDER can conduct event and entity extraction by computing the most probable frame assignment Z . In the remainder of the section, we first present the base model for PROFINDER.</S>
			<S sid ="68" ssid = "6">We then introduce several linguistically motivated refinements, as well as efficient algorithms for learning and inference in PROFINDER.</S>
			<S sid ="69" ssid = "7">3.1 Base Model.</S>
			<S sid ="70" ssid = "8">The probabilistic formulation of PROFINDER makes it extremely flexible for incorporating linguistic intuition and prior knowledge.</S>
			<S sid ="71" ssid = "9">In this paper, we design our PROFINDER model to capture three types of dependencies.</S>
			<S sid ="72" ssid = "10">Frame transitions between clauses A sentence contains one or more clauses, each of which is a minimal unit expressing a proposition.</S>
			<S sid ="73" ssid = "11">A clause is unlikely to straddle different frames, so we stipulate that the words in a clause be assigned to the same frame.</S>
			<S sid ="74" ssid = "12">On the other hand, frame transitions can happen between clauses, and we adopt the common Markov assumption that the frame of a clause only depends on the previous clause in the document.</S>
			<S sid ="75" ssid = "13">Clauses are automatically extracted from the dependency parse and further decomposed into an event head and its syntactic arguments.</S>
			<S sid ="76" ssid = "14">Event transitions within a frame Events tend to transition into related events in the same frame, as determined by their causal or temporal relations.</S>
			<S sid ="77" ssid = "15">Each clause is assigned an event compatible with its frame assignment (i.e., the event is in the given frame).</S>
			<S sid ="78" ssid = "16">Like frame transitions, we assume that the event assignment of a clause depends only on the event of the previous clause.</S>
			<S sid ="79" ssid = "17">Emission of event heads and slot words Similar to topics in topic models, each event determines a multinomial from which the event head is generated; e.g., a DETONATION event might use verbs such as detonate, set off or nouns such as denotation, bombing as its event head.</S>
			<S sid ="80" ssid = "18">Additionally, as in USP (Poon and Domingos, 2009), an event also contains a multinomial of slots for each of its argument types2; e.g., the agent argument of a DETONATION event is generally the PERPETRATOR slot of the BOMBING frame.</S>
			<S sid ="81" ssid = "19">Finally, each slot has its own multinomials for generating the argument head and dependency label, regardless of the event.</S>
			<S sid ="82" ssid = "20">Formally, let D be a document and C1, ¬∑ ¬∑ ¬∑ , Cl be its clauses, the PROFINDER model is defined by PŒ∏ (D, Z ) = PF‚àíINIT(F1) √ó n PF‚àíTRAN(Fi+1|Fi) i √ó PE‚àíINIT(E1|F1) n age additional linguistic intuition.</S>
			<S sid ="83" ssid = "21">PROFINDER incorporates three such refinements.</S>
			<S sid ="84" ssid = "22">Background frame Event narratives often contain interjections of general content common to all frames.</S>
			<S sid ="85" ssid = "23">For example, in newswire articles, ATTRIBUTION is commonplace to describe who said or reported a particular quote or fact.</S>
			<S sid ="86" ssid = "24">To avoid contaminating frames with generic content, we introduce a background frame with its own events, slots, and emission distributions, and a binary switch vari able Bi ‚àà {BK G, C N T } that determines whether clause i is generated from the actual content frame Fi (C N T ) or background (BK G).</S>
			<S sid ="87" ssid = "25">We also stipulate that if BK G is chosen, the nominal frame stays the same as the previous clause.</S>
			<S sid ="88" ssid = "26">Stickiness in frame and event transitions Prior √ó i n √ó i n √ó i,j n √ó i,j n √ó i,j PE‚àíTRAN(Ei+1|Ei, Fi+1, Fi) PE‚àíHEAD(ei| Ei) PSLOT(Si,j |Ei,j , Ai,j ) PA‚àíHEAD(ai, j |Si,j ) PA‚àíDEP(dep i,j |Si,j ) work has demonstrated that promoting topic coherence in natural language discourse helps discourse modeling (Barzilay and Lee, 2004).</S>
			<S sid ="89" ssid = "27">We extend PROFINDER to leverage this intuition by incorporating a ‚Äústickiness‚Äù prior (Haghighi and Vanderwende, 2009) to encourage neighboring clauses to stay in the same frame.</S>
			<S sid ="90" ssid = "28">Specifically, along with introducing the background frame, the frame transition component now becomes PF‚àíTRAN(Fi+1| Fi, Bi+1) = (1) Here, Fi, Ei denote the frame and event assignment to clause Ci, respectively, and ei denotes the Ô£¥Ô£±1(Fi+1 = Fi), if Bi+1 = BK G Ô£≤Œ≤1(F = F )+ event head.</S>
			<S sid ="91" ssid = "29">For the j-th argument of clause i, Si,j denotes the slot assignment, Ai,j the argument Ô£¥Ô£≥(1 ‚àí Œ≤)PF‚àí TRAN(Fi+1|Fi), if Bi+1 = C N T type, ai,j the head word, and depi,j the dependency from the event head.</S>
			<S sid ="92" ssid = "30">PE‚àíTRAN(Ei+1|Ei, Fi+1, Fi) = PE‚àíINIT(Ei+1|Fi+1) if Fi+1 /= Fi.</S>
			<S sid ="93" ssid = "31">Essentially, PROFINDER combines a frame HMM with an event HMM, where the first models frame transition and emits events, and the second models event transition within a frame and emits argument slots.</S>
			<S sid ="94" ssid = "32">3.2 Model refinements.</S>
			<S sid ="95" ssid = "33">The base model captures the main dependencies in event narrative, but it can be easily extended to lever 2 USP generates the argument types along with events from clustering.</S>
			<S sid ="96" ssid = "34">For simplicity, in PROFINDER we simply classify a syntactic argument into subject, object, and prepositional object, according to its Stanford dependency to the event head.</S>
			<S sid ="97" ssid = "35">where Œ≤ is the stickiness parameter, and the event transition component correspondingly becomes PE‚àíTRAN(Ei+1|Ei, Fi+1, Fi, Bi+1) = (2) Ô£¥Ô£±1(Ei+1 = Ei), if Bi+1 = BK G Ô£≤PE TRAN(Ei+1|Ei), if B = C N T , F = F Ô£¥Ô£≥PE‚àíINIT(Ei+1), if Bi+1 = C N T , Fi /= Fi+1 Argument dependencies as caseframes As noticed in previous work such as Chambers and Juraf- sky (2011), the combination of an event head and a dependency relation often gives a strong signal of the slot that is indicated.</S>
			<S sid ="98" ssid = "36">For example, bomb &gt; nsubj (subject argument of bomb) often indicates a PERPETRATOR.</S>
			<S sid ="99" ssid = "37">Thus, rather than simply emitting 1.</S>
			<S sid ="100" ssid = "38">Generate whether this clause is background.</S>
			<S sid ="101" ssid = "39">Background ÔøΩ1 ÔøΩùëÅ (Bi ‚àà {C N T , BK G} ‚àº PBKG (B)) Frame Event Arguments ÔøΩ1 ÔøΩ1 ÔøΩÔøΩ1 . . .</S>
			<S sid ="102" ssid = "40">ÔøΩ1 Event head ÔøΩùëÅ ÔøΩùëÅ ÔøΩÔøΩùëÅ ÔøΩùëÅ 2.</S>
			<S sid ="103" ssid = "41">Generate the frame Fi and event Ei from PF‚àíINI T(F ), PE‚àíINI T(E), or accor ding to equati ons 1 and 2 3.</S>
			<S sid ="104" ssid = "42">Generate the observed event head ei from PE‚àíHEA D(ei|Ei ).</S>
	</SECTION>
	<SECTION title="For. " number = "4">
			<S sid ="105" ssid = "1">each event argument : (a) Gene rate the slot Si,j from PS LOT (S |E , A, B) . ÔøΩÔøΩÔøΩÔøΩ1 ÔøΩÔøΩ 1 ÔøΩÔøΩÔøΩÔøΩùëÅ ùëéùëÅ (b) Generate the dependency/c aseframe emis ÔøΩ1 ÔøΩùëÅ ÔøΩ sion depi,j ‚àº PA ‚àíDEP(dep|S) and the ÔøΩÔøΩ‚àí ÔøΩÔøΩùëÉ ÔøΩÔøΩ‚àí ùêªÔøΩùê¥ÔøΩ ÔøΩ ÔøΩ ÔøΩ‚àí |ÔøΩÔøΩ| ùêªÔøΩùê¥ÔøΩ |ÔøΩ| |ÔøΩ| lemma of the head word of the event argument ai,j ‚àº PA‚àíHEAD( a|S).</S>
			<S sid ="106" ssid = "2">3.4 Learning and.</S>
			<S sid ="107" ssid = "3">Inference Figure 1: Graphical representation of our model.</S>
			<S sid ="108" ssid = "4">Hyper- parameters, the stickiness factor, and the frame and event initial and transition distributions are not shown for clarity.</S>
			<S sid ="109" ssid = "5">the dependency from the event head to an event argument depi,j , our model instead emits the pair of event head and dependency relation, which we call a caseframe following Bean and Riloff (2004).</S>
			<S sid ="110" ssid = "6">3.3 Full generative story.</S>
			<S sid ="111" ssid = "7">To summarize, the distributions that are learned by our model are the default distributions PBKG(B), PF‚àíINIT(F ), PE‚àíINIT(E); the transition distri butions PF‚àíTRAN(Fi+1|Fi), PE‚àíTRAN(Ei+1|Ei); and the emission distributions PSLOT(S|E, A, B), PE‚àíHEAD(e|E, B), PA‚àíHEAD(a|S), PA‚àíDEP(dep|S).We used additive smoothing with uniform Dirich let priors for all the multinomials.</S>
			<S sid ="112" ssid = "8">The overall generative story of our model is as follows: 1.</S>
			<S sid ="113" ssid = "9">Draw a Bernoulli distribution for PBKG(B).</S>
			<S sid ="114" ssid = "10">2.</S>
			<S sid ="115" ssid = "11">Draw the frame, event, and slot distributions.</S>
			<S sid ="116" ssid = "12">3.</S>
			<S sid ="117" ssid = "13">Draw an event head emission distribution.</S>
			<S sid ="118" ssid = "14">PE‚àíHEAD(e|E, B) for each frame including the background frame 4.</S>
			<S sid ="119" ssid = "15">Draw event argument lemma and caseframe.</S>
			<S sid ="120" ssid = "16">emission distributions for each slot in each frame including the background frame</S>
	</SECTION>
	<SECTION title="For each clause in each document, generate the. " number = "5">
			<S sid ="121" ssid = "1">clause-internal structure.</S>
			<S sid ="122" ssid = "2">The clause-internal structure at clause i is generated by the following steps: Our generative model admits efficient inference by dynamic programming.</S>
			<S sid ="123" ssid = "3">In particular, after collapsing the latent assignment of frame, event, and background into a single hidden variable for each clause, the expectation and most probable assignment can be computed using standard forward-backward and Viterbi algorithms on fixed tree structures.</S>
			<S sid ="124" ssid = "4">Parameter learning can be done using EM by alternating the computation of expected counts and the maximization of multinomial parameters.</S>
			<S sid ="125" ssid = "5">In particular, PROFINDER uses incremental EM, which has been shown to have better and faster convergence properties than standard EM (Liang and Klein, 2009).</S>
			<S sid ="126" ssid = "6">Determining the optimal number of events and slots is challenging.</S>
			<S sid ="127" ssid = "7">One solution is to adopt a non- parametric Bayesian method by incorporating a hierarchical prior over the parameters (e.g., a Dirichlet process).</S>
			<S sid ="128" ssid = "8">However, this approach can impose unrealistic restrictions on the model choice and result in intractability which requires sampling or approximate inference to overcome.</S>
			<S sid ="129" ssid = "9">Additionally, EM learning can suffer from local optima due to its non- convex learning objective, especially when dealing with a large number hidden states without a good initialization.</S>
			<S sid ="130" ssid = "10">To address these issues, we adopt a novel application of the split-merge method previously used in syntactic parsing for inferring refined latent syntactic categories (Petrov et al., 2006).</S>
			<S sid ="131" ssid = "11">First, the model is initialized with a number of frames, which is a hyperparameter, and each frame is associated with one event and two slots.</S>
			<S sid ="132" ssid = "12">Starting from this minimal structure, EM training begins.</S>
			<S sid ="133" ssid = "13">After a number of iterations, each event and slot state is ‚Äúsplit‚Äù in two; that is, each original state now becomes two new states.</S>
			<S sid ="134" ssid = "14">Each of the new states is generated with half of the probability of the original, and contains a duplicate of the associated emission distributions.</S>
			<S sid ="135" ssid = "15">Some perturbation is then added to the probabilities to break symmetry.</S>
			<S sid ="136" ssid = "16">After splitting, we merge back a portion of the newly split events and slots that result in the least improvement in the likelihood of the training data.</S>
			<S sid ="137" ssid = "17">For more details on split-merge, see Petrov et al.</S>
			<S sid ="138" ssid = "18">(2006) By adjusting the number of split-merge cycles and the merge parameters, our model learns the number of events and slots in a dynamical fashion that is tailored to the data.</S>
			<S sid ="139" ssid = "19">Moreover, our model starts with a small number of frame elements, which reduces the number of local optima and facilitates initial learning.</S>
			<S sid ="140" ssid = "20">After each split, the subsequent learning starts with (a perturbed version of) the previously learned parameters, which makes a good initialization that is crucial for EM.</S>
			<S sid ="141" ssid = "21">Finally, it is also compatible with the hierarchical nature of events and slots.</S>
			<S sid ="142" ssid = "22">For example, slots can first be coarsely split into persons versus locations, and later refined into subcategories such as perpetrators and victims.</S>
			<S sid ="143" ssid = "23">4 MUC4 Entity Extraction Experiments.</S>
			<S sid ="144" ssid = "24">We first evaluate our model on a standard entity extraction task, using the evaluation settings from Chambers and Jurafsky (2011) (henceforth, C&amp;J) plate is ignored in final evaluation, so all the clusters that belong to the same slot are then merged across the templates; e.g., the PERPETRATOR clusters for KIDNAPPING and BOMBING are merged.</S>
			<S sid ="145" ssid = "25">The final precision, recall, and F1 are computed based on these merged clusters.</S>
			<S sid ="146" ssid = "26">Correctness is determined by matching head words, and slots marked as optional in MUC are ignored when computing recall.</S>
			<S sid ="147" ssid = "27">All hyperparameters are tuned on the development set (see Appendix A for their values).</S>
			<S sid ="148" ssid = "28">Named entity type Named entity type is a useful feature to filter out entities for particular slots; e.g. a location cannot be an INSTRUMENT.</S>
			<S sid ="149" ssid = "29">We thus divide each induced cluster into four clusters by named entity type before performing the mapping, following C&amp;J‚Äôs heuristic and using a named entity recognizer and word lists derived from WordNet: PERSON/ORGANIZATION, PHYSICAL OBJECT, LOCATION, and OTHER.</S>
			<S sid ="150" ssid = "30">Document classification The MUC4 dataset contains many documents that have words related to MUC slots (e.g., plane and aviation), but are not about terrorism.</S>
			<S sid ="151" ssid = "31">To reduce precision errors, C&amp;J first filtered irrelevant documents based on the specificity of event heads to learned frames.</S>
			<S sid ="152" ssid = "32">To estimate the specificity, they used additional data retrieved from a large external corpus.</S>
			<S sid ="153" ssid = "33">In PROFINDER, however, specificity can be easily estimated using the probability distributions learned during training.</S>
			<S sid ="154" ssid = "34">In particular, we define the probability of an event head in a frame j as: to enable a head-to-head comparison.</S>
			<S sid ="155" ssid = "35">Specifically, we use the MUC4 data set (1992) , which contains PF (w) = EF ‚ààF PE‚àíHEAD(w|E)/|F |, (3) 1300 training and development documents on terrorism in South America, with 200 additional documents for testing.</S>
			<S sid ="156" ssid = "36">MUC4 contains four templates: ATTACK, KIDNAPPING, BOMBING, and ARSON.3 All templates share the same set of predefined slots, with the evaluation focusing on the following four: PERPETRATOR, PHYSICAL TARGET, HUMAN TARGET, and INSTRUMENT.</S>
			<S sid ="157" ssid = "37">For each slot in a MUC template, the system first identifies an induced slot that best maps to it by F1 on the development set.</S>
			<S sid ="158" ssid = "38">As in C&amp;J, tem 3 Two other templates have negligible counts and are ignored as in C&amp;J. and the probability of a frame given an event head as: P (F |w) = PF (w)/ PF (w).</S>
			<S sid ="159" ssid = "39">(4) F ‚ààF We then follow the rest of C&amp;J‚Äôs procedure to score each learned frame with each MUC document.</S>
			<S sid ="160" ssid = "40">Specifically, a document is mapped to a frame if the average PF (w) in the document is above a threshold and the document contains at least one trigger wordwl with P (F |wl) &gt; 0.2.</S>
			<S sid ="161" ssid = "41">The threshold and the in duced frame were determined on the development set, and were used to filter irrelevant documents in the test set.</S>
			<S sid ="162" ssid = "42">Un su per vis ed me th od s P R F1 E v e n t : A t t a c k E v e n t : D i s c u s s i o n PR OF IN DE R (Th is wo rk) 3 2 37 34 re po rt, pa rti ci pa te, kid ho ld, m ee tin g, tal k, dis Chambers and Jurafsky (2011) 48 25 33 nap, kill, release cuss, investigate With additional information PROFINDER +doc.</S>
			<S sid ="163" ssid = "43">classification 41 44 43 Slot: Perpetrator Slot: Victim PERSON/ORG PERSON/ORG C&amp;J 2011 +granularity 44 36 40 Table 1: Results on MUC4 entity extraction.</S>
			<S sid ="164" ssid = "44">C&amp;J 2011 +granularity refers to their experiment in which they mapped one of their templates to five learned clusters rather than one.</S>
			<S sid ="165" ssid = "45">Results Compared to C&amp;J, PROFINDER is conceptually much simpler, using a single probabilistic model and standard learning and inference algo Words: guerrilla, police, source, person, group Caseframes: report&gt;nsubj, kidnap&gt;nsubj, kill&gt;nsubj, participate&gt;nsubj, release&gt;nsubj Words: people, priest, leader, member, judge Caseframes: kill&gt;dobj, murder&gt;dobj, release&gt;dobj, report&gt;dobj, kidnap&gt;dobj rithms, and not requiring multiple processing steps or customized similarity metrics.</S>
			<S sid ="166" ssid = "46">It only used the data in MUC4, whereas C&amp;J required additional text to be retrieved from a large external corpus (Gigaword (Graff et al., 2005)) for each event cluster.</S>
			<S sid ="167" ssid = "47">It currently does not make use of coreference information, whereas C&amp;J did.</S>
			<S sid ="168" ssid = "48">Remarkably, despite all these, PROFINDER was still able to outperform C&amp;J on entity extraction, as shown in Table 1.</S>
			<S sid ="169" ssid = "49">We also evaluated PROFINDER‚Äôs performance assuming perfect document classification (+doc.</S>
			<S sid ="170" ssid = "50">classification).</S>
			<S sid ="171" ssid = "51">This led to a substantially higher precision, suggesting that further improvement is possible from better document classification.</S>
			<S sid ="172" ssid = "52">Figure 2 shows part of a frame learned by PROFINDER, which includes some slots and events annotated in MUC.</S>
			<S sid ="173" ssid = "53">PROFINDER is also able to identify events and slots not annotated in MUC, a desirable characteristic of unsupervised methods.</S>
			<S sid ="174" ssid = "54">For example, it found a DISCUSSION event, an ARREST event (call, arrest, express, meet, charge), a PEACE AGREEMENT slot (agreement, rights, law, proposal), and an AUTHORITIES slot (police, government, force, command).</S>
			<S sid ="175" ssid = "55">The background frame was able to capture many verbs related to attribution, such as say, continue, add, believe, although it missed report.</S>
			<S sid ="176" ssid = "56">5 Evaluating Frame Induction Using.</S>
			<S sid ="177" ssid = "57">Guided Summarization Templates The MUC4 dataset was originally designed for information extraction and focuses on a limited number of template and slot types.</S>
			<S sid ="178" ssid = "58">To evalu Figure 2: A partial frame learned by PROFINDER from the MUC4 data set, with the most probable emissions for each event and slot.</S>
			<S sid ="179" ssid = "59">Labels are assigned by the authors for readability.</S>
			<S sid ="180" ssid = "60">ate PROFINDER‚Äôs capabilities in generalizing to a greater variety of text, we designed and conducted a novel evaluation based on the TAC guided- summarization dataset.</S>
			<S sid ="181" ssid = "61">This evaluation was inspired by the connection between summarization and information extraction (White et al., 2001), and reflects a conceptualization of summarization as inducing and extracting structured information from source text.</S>
			<S sid ="182" ssid = "62">Essentially, we adapted the TAC summarization annotation to create gold-standard slots, and used them to evaluate entity extraction as in MUC4.</S>
			<S sid ="183" ssid = "63">Dataset We used the TAC 2010 guided- summarization dataset in our experiments (Owczarzak and Dang, 2010).</S>
			<S sid ="184" ssid = "64">This data set consists of text from five domains (termed categories in TAC), each with a template defined by TAC organizers.</S>
			<S sid ="185" ssid = "65">In total, there are 46 document clusters (termed topics in TAC), each of which contains 20 documents and has eight human-written summaries.</S>
			<S sid ="186" ssid = "66">Each summary was manually segmented using the Pyramid method (Nenkova and Passonneau, 2004) and each segment was annotated with a slot (termed aspect in TAC) from the corresponding template.</S>
			<S sid ="187" ssid = "67">Figure 3 shows an example and the full set of templates is available at http://www.</S>
			<S sid ="188" ssid = "68">nist.gov/tac/2010/Summarization/ Guided-Summ.2010.guidelines.html.</S>
			<S sid ="189" ssid = "69">In (a) Accidents and Natural Disasters: WHAT: what happened WHEN: date, time, other temporal markers WHERE: physical location WHY: reasons for accident/disaster WHO AFFECTED: casualties...</S>
			<S sid ="190" ssid = "70">DAMAGES: ... caused by the disaster COUNTERMEASURES: rescue efforts...</S>
			<S sid ="191" ssid = "71">(b) (WHEN During the night of July 17,) (WHAT a 23-foot &lt;WHAT tsunami) hit the north coast of Papua New Guinea (PNG)&gt;, (WHY triggered by a 7.0 undersea earthquake in the area).</S>
			<S sid ="192" ssid = "72">(c) WHEN: night WHAT: tsunami, coast WHY: earthquake Figure 3: (a) A frame from the TAC Guided Summarization task with abbreviated slot descriptions.</S>
			<S sid ="193" ssid = "73">(b) A TAC text span, segmented into several contributors with slot labels.</S>
			<S sid ="194" ssid = "74">Note that the two WHAT contributors overlap, and are demarcated by different bracket types.</S>
			<S sid ="195" ssid = "75">(c) The entities that are extracted for evaluation.</S>
			<S sid ="196" ssid = "76">TAC, each annotated segment (Figure 3b) is called a contributor.</S>
			<S sid ="197" ssid = "77">Evaluation Method We converted the contributors into a form that is more similar to the previous MUC evaluation, so that we can fairly compare against previous work such as C&amp;J that were designed to extract information into that form.</S>
			<S sid ="198" ssid = "78">Specifically, we extracted the head lemma from all the maximal noun phrases found in the contributor (Figure 3c) and treated them as gold-standard entity slots to extract.</S>
			<S sid ="199" ssid = "79">While this conversion may not be ideal in some cases, it simplifies the TAC slots and enables automatic evaluation.</S>
			<S sid ="200" ssid = "80">We leave the refinement of this conversion to future work, and believe it could be done by crowdsourcing.</S>
			<S sid ="201" ssid = "81">For each TAC slot in a TAC category, we extract entities from the summaries that belong to the given TAC category.</S>
			<S sid ="202" ssid = "82">A system-induced entity is considered a match to a TAC-derived entity from the same document if the head lemma in the former matches one in the latter.</S>
			<S sid ="203" ssid = "83">Based on this matching criterion, the system-induced slots are mapped to the TAC slots in a way that achieves the best F1 for each TAC slot.</S>
			<S sid ="204" ssid = "84">We allow a system slot to map to multiple TAC slots, due to potential overlaps in entities 1-best 5-best Systems P R F1 P R F1 PROFINDER 24 25 24 21 38 27 C&amp;J 58 6.1 11 50 12 20 Table 2: Results on TAC 2010 entity extraction with N - best mapping for N = 1 and N = 5.</S>
			<S sid ="205" ssid = "85">Intermediate values of N produce intermediate results, and are not shown for brevity.</S>
			<S sid ="206" ssid = "86">among TAC slots.</S>
			<S sid ="207" ssid = "87">For example, in a document about a tsunami, earthquake may appear both in the WHAT slot as a disaster itself, and in the CAUSE slot as a cause for the tsunami.</S>
			<S sid ="208" ssid = "88">One salient difference between TAC and MUC slots is that TAC slots are often more general than MUC slots.</S>
			<S sid ="209" ssid = "89">For example, TAC slots such as WHY and COUNTERMEASURES likely correspond to multiple slots at the granularity of MUC.</S>
			<S sid ="210" ssid = "90">As a result, we also consider mapping the N -best system-induced slots to each TAC slot, for N up to 5.</S>
			<S sid ="211" ssid = "91">Experiments We trained PROFINDER and a reimplementation of C&amp;J on the 920 full source texts of TAC 2010, and tested them on the 368 model summaries.</S>
			<S sid ="212" ssid = "92">We did not provide C&amp;J‚Äôs model with access to external data, in order to enable fair comparison with our model.</S>
			<S sid ="213" ssid = "93">Since all of the summary sentences are expected to be relevant, we did not conduct document or sentence relevance classification in C&amp;J or PROFINDER.</S>
			<S sid ="214" ssid = "94">We tuned all parameters by twofold cross validation on the summaries.</S>
			<S sid ="215" ssid = "95">We computed the overall precision, recall, and F1 by taking a micro- average over the results for each TAC slot.</S>
			<S sid ="216" ssid = "96">Results The results are shown in Table 2.</S>
			<S sid ="217" ssid = "97">PROFINDER substantially outperformed C&amp;J in F1, in both 1-best and N -best cases.</S>
			<S sid ="218" ssid = "98">As in MUC4, the precision of C&amp;J is higher, partly because C&amp;J often did not do much in clustering and produced many small clusters.</S>
			<S sid ="219" ssid = "99">For example, in the 1-best setting, the average number of entities mapped to each TAC slot by C&amp;J is 21, whereas it is 208 for PROFINDER.</S>
			<S sid ="220" ssid = "100">For both systems, the results are generally lower compared to that in MUC4, which is expected since this task is harder given the greater diversity in frames and slots to be induced.</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "6">
			<S sid ="221" ssid = "1">We have presented PROFINDER, the first probabilistic approach to frame induction and shown that it achieves state-of-the-art results on end-to-end entity extraction in standard MUC and TAC data sets.</S>
			<S sid ="222" ssid = "2">Our model is inspired by recent advances in unsupervised semantic induction and content modeling in summarization.</S>
			<S sid ="223" ssid = "3">Our probabilistic approach makes it easy to extend the model with additional linguistic insights and prior knowledge.</S>
			<S sid ="224" ssid = "4">While we have made a case for unsupervised methods and the importance of robustness across domains, our method is also amenable to semi-supervised or supervised learning if annotated data is available.</S>
			<S sid ="225" ssid = "5">In future work, we would like to further investigate frame induction evaluation, particularly in evaluating event clustering.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="226" ssid = "6">We would like to thank Nate Chambers for answering questions about his system.</S>
			<S sid ="227" ssid = "7">We would also like to thank Chris Quirk for help with preprocessing the MUC corpus, and the members of the NLP group at Microsoft Research for useful discussions.</S>
			<S sid ="228" ssid = "8">Appendix A. Hyperparameter Settings We document below the hyperparameter settings for PROFINDER that were used to generate the results in the paper.</S>
			<S sid ="229" ssid = "9">Regina Barzilay and Lillian Lee.</S>
			<S sid ="230" ssid = "10">2004.</S>
			<S sid ="231" ssid = "11">Catching the drift: Probabilistic content models, with applications to generation and summarization.</S>
			<S sid ="232" ssid = "12">In Proceedings of the Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics: HLTNAACL 2004.</S>
			<S sid ="233" ssid = "13">David Bean and Ellen Riloff.</S>
			<S sid ="234" ssid = "14">2004.</S>
			<S sid ="235" ssid = "15">Unsupervised learning of contextual role knowledge for coreference resolution.</S>
			<S sid ="236" ssid = "16">In Proceedings of the Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics: HLTNAACL 2004.</S>
			<S sid ="237" ssid = "17">Nathanael Chambers and Dan Jurafsky.</S>
			<S sid ="238" ssid = "18">2008.</S>
			<S sid ="239" ssid = "19">Unsupervised learning of narrative event chains.</S>
			<S sid ="240" ssid = "20">In Proceedings of ACL08: HLT, pages 789‚Äì797, Columbus, Ohio, June.</S>
			<S sid ="241" ssid = "21">Association for Computational Linguistics.</S>
			<S sid ="242" ssid = "22">Nathanael Chambers and Dan Jurafsky.</S>
			<S sid ="243" ssid = "23">2009.</S>
			<S sid ="244" ssid = "24">Unsupervised learning of narrative schemas and their participants.</S>
			<S sid ="245" ssid = "25">In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP.</S>
			<S sid ="246" ssid = "26">Association for Computational Linguistics.</S>
			<S sid ="247" ssid = "27">Nathanael Chambers and Dan Jurafsky.</S>
			<S sid ="248" ssid = "28">2011.</S>
			<S sid ="249" ssid = "29">Template- based information extraction without the templates.</S>
			<S sid ="250" ssid = "30">In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 976‚Äì986, Portland, Oregon, USA, June.</S>
			<S sid ="251" ssid = "31">Association for Computational Linguistics.</S>
			<S sid ="252" ssid = "32">Jackie C. K. Cheung and Xiao Li.</S>
			<S sid ="253" ssid = "33">2012.</S>
			<S sid ="254" ssid = "34">Sequence clustering and labeling for unsupervised query intent discovery.</S>
			<S sid ="255" ssid = "35">In Proceedings of the 5th ACM International Conference on Web Search and Data Mining, pages 383‚Äì392.</S>
			<S sid ="256" ssid = "36">James R. Curran, Tara Murphy, and Bernhard Scholz.</S>
			<S sid ="257" ssid = "37">2007.</S>
			<S sid ="258" ssid = "38">Minimising semantic drift with mutual exclusion bootstrapping.</S>
			<S sid ="259" ssid = "39">In Proceedings of the 10th Conference of the Pacific Association for Computational Linguistics.</S>
			<S sid ="260" ssid = "40">Hal Daume¬¥ III and Daniel Marcu.</S>
			<S sid ="261" ssid = "41">2006.</S>
			<S sid ="262" ssid = "42">Bayesian</S>
	</SECTION>
</PAPER>
