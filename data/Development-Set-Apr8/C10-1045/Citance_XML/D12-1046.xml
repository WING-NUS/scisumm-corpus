<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">In this paper, we propose a novel decoding algorithm for discriminative joint Chinese word segmentation, part-of-speech (POS) tagging, and parsing.</S>
		<S sid ="2" ssid = "2">Previous work often used a pipeline method – Chinese word segmentation followed by POS tagging and parsing, which suffers from error propagation and is unable to leverage information in later modules for earlier components.</S>
		<S sid ="3" ssid = "3">In our approach, we train the three individual models separately during training, and incorporate them together in a unified framework during decoding.</S>
		<S sid ="4" ssid = "4">We extend the CYK parsing algorithm so that it can deal with word segmentation and POS tagging features.</S>
		<S sid ="5" ssid = "5">As far as we know, this is the first work on joint Chinese word segmentation, POS tagging and parsing.</S>
		<S sid ="6" ssid = "6">Our experimental results on Chinese Tree Bank 5 corpus show that our approach outperforms the state-of-the-art pipeline system.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">For Asian languages such as Japanese and Chinese that do not contain explicitly marked word boundaries, word segmentation is an important first step for many subsequent language processing tasks, such as POS tagging, parsing, semantic role labeling, and various applications.</S>
			<S sid ="8" ssid = "8">Previous studies for POS tagging and syntax parsing on these languages sometimes assume that gold standard word segmentation information is provided, which is not the real scenario.</S>
			<S sid ="9" ssid = "9">In a fully automatic system, a pipeline approach is often adopted, where raw sentences are first segmented into word sequences, then POS tagging and parsing are performed.</S>
			<S sid ="10" ssid = "10">This kind of approach suffers from error propagation.</S>
			<S sid ="11" ssid = "11">For example, word segmentation errors will result in tagging and parsing errors.</S>
			<S sid ="12" ssid = "12">Additionally, early modules cannot use information from subsequent modules.</S>
			<S sid ="13" ssid = "13">Intuitively a joint model that performs the three tasks together should help the system make the best decisions.</S>
			<S sid ="14" ssid = "14">In this paper, we propose a unified model for joint Chinese word segmentation, POS tagging, and parsing.</S>
			<S sid ="15" ssid = "15">Three sub-models are independently trained using the state-of-the-art methods.</S>
			<S sid ="16" ssid = "16">We do not use the joint inference algorithm for training because of the high complexity caused by the large amount of parameters.</S>
			<S sid ="17" ssid = "17">We use linear chain Conditional Random Fields (CRFs) (Lafferty et al., 2001) to train the word segmentation model and POS tagging model, and averaged perceptron (Collins, 2002) to learn the parsing model.</S>
			<S sid ="18" ssid = "18">During decoding, parameters of each sub-model are scaled to represent its importance in the joint model.</S>
			<S sid ="19" ssid = "19">Our decoding algorithm is an extension of CYK parsing.</S>
			<S sid ="20" ssid = "20">Initially, weights of all possible words together with their POS tags are calculated.</S>
			<S sid ="21" ssid = "21">When searching the parse tree, the word and POS tagging features are dynamically generated and the transition information of POS tagging is considered in the span merge operation.</S>
			<S sid ="22" ssid = "22">Experiments are conducted on Chinese Tree Bank (CTB) 5 dataset, which is widely used for Chinese word segmentation, POS tagging and parsing.</S>
			<S sid ="23" ssid = "23">We compare our proposed joint model with the pipeline system, both built using the state-of-the-art sub- models.</S>
			<S sid ="24" ssid = "24">We also propose an evaluation metric to 501 Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 501–511, Jeju Island, Korea, 12–14 July 2012.</S>
			<S sid ="25" ssid = "25">Qc 2012 Association for Computational Linguistics word segmentation errors.</S>
			<S sid ="26" ssid = "26">Our experimental results show that the joint model significantly outperforms the pipeline method based on the state-of-the-art sub-models.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "2">
			<S sid ="27" ssid = "1">There is very limited previous work on joint Chinese word segmentation, POS tagging, and parsing.</S>
			<S sid ="28" ssid = "2">Previous joint models mainly focus on word segmentation and POS tagging task, such as the virtual nodes method (Qian et al., 2010), cascaded linear model (Jiang et al., 2008a), perceptron (Zhang and Clark, 2008), sub-word based stacked learning (Sun, 2011), reranking (Jiang et al., 2008b).</S>
			<S sid ="29" ssid = "3">These joint models form joint decoding using them.</S>
			<S sid ="30" ssid = "4">In this section, we first describe the three sub-models and then the joint decoding algorithm.</S>
			<SUBSECTION>3.1 Word Segmentation Model.</SUBSECTION>
			<S sid ="31" ssid = "5">Methods for Chinese word segmentation can be broadly categorized into character based and word based models.</S>
			<S sid ="32" ssid = "6">Previous studies showed that character-based models are more effective to detect out-of-vocabulary words while word-based models are more accurate to predict in-vocabulary words (Zhang et al., 2006).</S>
			<S sid ="33" ssid = "7">Here, we use order-0 semi- Markov model (Sarawagi and Cohen, 2004) to take advantages of both approaches.</S>
			<S sid ="34" ssid = "8">More specifically, given a sentence x = showed about 0.2 − 1% F-score improvement over c , c , . . .</S>
			<S sid ="35" ssid = "9">, c (where c is the ith Chinese character, the pipeline method.</S>
			<S sid ="36" ssid = "10">Recently, joint tagging and de1 2 l i pendency parsing has been studied as well (Li et al., 2011; Lee et al., 2011).</S>
			<S sid ="37" ssid = "11">Previous research has showed that word segmentation has a great impact on parsing accuracy in the pipeline method (Harper and Huang, 2009).</S>
			<S sid ="38" ssid = "12">In (Jiang et al., 2009), additional data was used to improve Chinese word segmentation, which resulted in significant improvement on the parsing task using the pipeline framework.</S>
			<S sid ="39" ssid = "13">Joint segmentation and parsing was also investigated for Arabic (Green and Manning, 2010).</S>
			<S sid ="40" ssid = "14">A study that is closely related to ours is (Goldberg and Tsarfaty, 2008), where a single generative model was proposed for joint morphological segmentation and syntactic parsing for Hebrew.</S>
			<S sid ="41" ssid = "15">Different from that work, we use a discriminative model, which benefits from large amounts of features and is easier to deal with unknown words.</S>
			<S sid ="42" ssid = "16">Another main difference is that, besides segmentation and parsing, we also incorporate the POS tagging model into the CYK parsing framework.</S>
	</SECTION>
	<SECTION title="Methods. " number = "3">
			<S sid ="43" ssid = "1">For a given Chinese sentence, our task is to generate the word sequence, its POS tag sequence, and the parse tree (constituent parsing).</S>
			<S sid ="44" ssid = "2">A joint model is expected to make more optimal decisions than a pipeline approach; however, such a model will be too complex and it is difficult to estimate model parameters.</S>
			<S sid ="45" ssid = "3">Therefore we do not perform joint inference for training.</S>
			<S sid ="46" ssid = "4">Instead, we develop three individl is the sentence length), the character-based mod el assigns each character with a word boundary tag.</S>
			<S sid ="47" ssid = "5">Here we use the BCDIES tag set, which achieved the best official performance (Zhao and Kit, 2008): B, C, D, E denote the first, second, third, and last character of a multi-character word respectively, I denotes the other characters, and S denotes the single character word.</S>
			<S sid ="48" ssid = "6">We use the same character- based feature templates as in the best official system, shown in Table 1 (1.11.3), including character unigram and bigram features, and transition features.</S>
			<S sid ="49" ssid = "7">Linear chain CRFs are used for training.</S>
			<S sid ="50" ssid = "8">Feature templates in the word-based model are shown in Table 1 (1.41.6), including word features, sub-word features, and character bigrams within words.</S>
			<S sid ="51" ssid = "9">The word feature is activated if a predicted word w is in the vocabulary (i.e., appears in training data).</S>
			<S sid ="52" ssid = "10">Subword(w) is the longest in-vocabulary word within w. To use word features, we adopt a K- best reranking approach.</S>
			<S sid ="53" ssid = "11">The top K candidate segmentation results for each training sample are generated using the character-based model, and the gold segmentation is added if it is not in the candidate set.</S>
			<S sid ="54" ssid = "12">We use the Maximum Entropy (ME) model to learn the weights of word features such that the probability of the gold candidate is maximal.</S>
			<S sid ="55" ssid = "13">A problem arises when combining the two models and using it in joint segmentation and parsing, since the linear chain used in the character-based model is incompatible with CYK parsing model and the word-based model due to the transition informa (1.1) ci−2 yi , ci−1 yi , ci yi , ci+1 yi , ci+2 yi (1.2) ci−1 ci yi , ci ci+1 yi , ci−1 ci+1 yi (1.3) yi−1 yi Word Level Feature Templates (1.4) word w (1.5) subword(w) (1.6) character bigrams within w Table 1: Feature templates for word segmentation.</S>
			<S sid ="56" ssid = "14">ci is the ith character in the sentence, yi is its label, w is a predicted word.</S>
			<S sid ="57" ssid = "15">tion.</S>
			<S sid ="58" ssid = "16">Thus, we slightly modify the linear chain CRF- s by fixing the weights of transition features during training and testing.</S>
			<S sid ="59" ssid = "17">That is, weights of impossible transition features (e.g., B→B) are set to −∞, and weights of the other transition features (e.g., E→B) are set to 0.</S>
			<S sid ="60" ssid = "18">In this way, the transition feature could be neglected in testing for two reasons.</S>
			<S sid ="61" ssid = "19">First, all illegal label assignments are prohibited in prediction, s but no syntax annotations, such as the People’s Daily corpus and SIGHAN bakeoff corpora (Jin and Chen, 2008).</S>
			<S sid ="62" ssid = "20">Such data can only be used to train POS tag- gers, but not for training the parsing model.</S>
			<S sid ="63" ssid = "21">Often using a larger training set will result in a better POS tagger.</S>
			<S sid ="64" ssid = "22">Second, the state-of-the-art POS tagging systems are often trained by sequence labeling models, not parsing models.</S>
			<S sid ="65" ssid = "23">−2 i i Table 2: Feature templates for POS tagging.</S>
			<S sid ="66" ssid = "24">wi is the ith word in the sentence, ti is its POS tag.</S>
			<S sid ="67" ssid = "25">For a word w, ince their weights are −∞; second, because weights cj (w) is its jth character, c−j (w) is the last j character, of legal transition features are 0, they do not affect the prediction at all.</S>
			<S sid ="68" ssid = "26">In the following, transition features are excluded.</S>
			<S sid ="69" ssid = "27">Now we can use order-0 semi Markov model as the hybrid model.</S>
			<S sid ="70" ssid = "28">We define the score of a word as the sum of the weights of all the features within the word.</S>
			<S sid ="71" ssid = "29">Formally, the score of a multi-character word w = ci , . . .</S>
			<S sid ="72" ssid = "30">, cj is defined as: scoreseg (x, i, j) = θC RF · fC RF (x, yi = B) + . . .</S>
			<S sid ="73" ssid = "31">+θC RF · fC RF (x, yj = E) + θM E · fM E (x, i, j) ≡ θseg fseg (x, i, j) (1) where fC RF and fM E are the feature vectors in the character and word based models respectively, and θC RF , θM E are their corresponding weight vectors.</S>
			<S sid ="74" ssid = "32">For simplicity, we denote θseg = θC RF ⊕M E , fseg = fC RF ⊕M E , where θC RF ⊕M E means the concatenation of θC RF and θM E . Scores for single character words are defined similarly.</S>
			<S sid ="75" ssid = "33">These word scores will be used in the joint segmentation and parsing task Section 3.4.</S>
			<S sid ="76" ssid = "34">3.2 POS Tagging Model.</S>
			<S sid ="77" ssid = "35">Though syntax parsing model can directly predict the POS tag itself, we choose not to use this, but use an independent POS tagger for two reasons.</S>
			<S sid ="78" ssid = "36">First, and l(w) is its length.</S>
			<S sid ="79" ssid = "37">The POS tagging problem is to assign a POS tagt ∈ T to each word in a sentence.</S>
			<S sid ="80" ssid = "38">We also use lin ear chain CRFs for POS tagging.</S>
			<S sid ="81" ssid = "39">Feature templates shown in Table 2 are the same as those in (Qian et al., 2010), which have been shown effective on CTB corpus.</S>
			<S sid ="82" ssid = "40">Three feature sets are considered: (i) word level features, including surrounding word uni- grams, bigrams, and word length; (ii) character level features, such as the first and last characters in the words; (iii) transition features.</S>
			<S sid ="83" ssid = "41">3.3 Parsing Model.</S>
			<S sid ="84" ssid = "42">We choose discriminative models for parsing since it is easy to handle unknown words by simply adding character level features.</S>
			<S sid ="85" ssid = "43">Online structured learning algorithms were demonstrated to be effective for training, such as stochastic optimization (Finkel et al., 2008).</S>
			<S sid ="86" ssid = "44">In this study, we use averaged perceptron algorithm for parameter estimation since it is easier to implement and has competitive performance.</S>
			<S sid ="87" ssid = "45">A Context Free Grammar (CFG) consists of (i) a set of terminals; (ii) a set of nonterminals {N k }; (i ii) a designated start symbol ROOT; and (iv) a set of rules, {r = N i → ζ j }, where ζ j is a sequence ofterminals and nonterminals.</S>
			<S sid ="88" ssid = "46">In the parsing task, ter N P NR NN NR NN Shanghai customs Chongming office CP top state IP VP bottom state N P VV NT CP VP NP VV NT VV Last year realized N P Last year realized NR Shanghai NN_NR NN NR_NN Figure 2: Unary rule normalization.</S>
			<S sid ="89" ssid = "47">Nonterminal-yield unary chains are collapsed to single unary rules.</S>
			<S sid ="90" ssid = "48">Identity unary rules are added to spans that have no unary rule.</S>
			<S sid ="91" ssid = "49">customs NR NN Chongming office tom states; (ii) top state features ftop (i, j, x, N i,j ); (iii) unary rule features funary (i, j, x, runary ), which extract the transition information from bottom s Figure 1: Parse tree binarization tates to top states; (iv) binary rule features fbinary (i, j, k, x, rbinary = N i,j → N i,k −1 + N k,r ), minals are the words, and nonterminals are the POS tags and phrase types.</S>
			<S sid ="92" ssid = "50">In this paper, nonterminal is named state for short.</S>
			<S sid ="93" ssid = "51">A parse tree T of sentence x can be factorized into several one-level subtrees, where N i,k−1, N k,r are the top states of the left and right children.</S>
			<S sid ="94" ssid = "52">The score function for a sentence x with parse tree T is defined as: score(x, T ) = each corresponding to a rule r. In practice, binarization of rules is necessary to θbottom · fbottom (i, j, x, N i,j ) obtain cubic parsing time.</S>
			<S sid ="95" ssid = "53">That is, the right hand N i,j ∈T side of each rule should contain no more than 2 states.</S>
			<S sid ="96" ssid = "54">We used right branching binarization, as illustrated in Figure 1.</S>
			<S sid ="97" ssid = "55">We did not use parent annotation, since we found it degraded the performance + ∑ N i,j ∈T + ∑ unary θtop · ftop (i, j, x, N i,j ) θunary · funary (i, j, x, runary ) in our experiments (shown in Section 4).</S>
			<S sid ="98" ssid = "56">We used the same preprocessing step as (Harper and Huang, 2009), collapsing all the allowed nonterminal-yield unary chains to single unary rules.</S>
			<S sid ="99" ssid = "57">Therefore, all s ri,j ∈T + ∑ i,j,k ∈T θbinary · fbinary (i, j, x, rbinary ) pans in the binarized trees contain no more than one unary rules.</S>
			<S sid ="100" ssid = "58">To facilitate decoding, we unify the form of spans so that each span contains exactly one u- nary rule.</S>
			<S sid ="101" ssid = "59">This is done by adding identity unary rules where θbottom , θtop , θunary , θbinary are the weight vectors of the four feature sets.</S>
			<S sid ="102" ssid = "60">Given the training corpus {(xi , T˜ )}, the learning task is to estimate the weight vectors so that for each (N → N ) to spans that have no unary rule.</S>
			<S sid ="103" ssid = "61">These sentence xi , the gold standard tree T˜ achieves the identity unary rules will be removed in evaluation.</S>
			<S sid ="104" ssid = "62">Hence, there are two states of a span: the top state N and the bottom state N that correspond to the left and right hand of the unary rule runary = N → N respectively, as shown in Figure 2.</S>
			<S sid ="105" ssid = "63">Table 3 lists the feature templates we use for parsing.</S>
			<S sid ="106" ssid = "64">There are 4 feature sets: (i) bottom state features fbottom (i, j, x, N i,j ), which depend on the botmaximal score among all the possible trees.</S>
			<S sid ="107" ssid = "65">The per ceptron algorithm is guaranteed to find the solution if it exists.</S>
			<S sid ="108" ssid = "66">3.4 Joint Decoding.</S>
			<S sid ="109" ssid = "67">The three models described above are separately trained to make parameter estimation feasible as well as optimize each individual component.</S>
			<S sid ="110" ssid = "68">In test (3.</S>
			<S sid ="111" ssid = "69">1) Bi na ry rul e te mp lat es N → N l + N r Xl Xm −1 Xr len l len r Xl Xm Xr lenl lenr Xl Xm −1 Xr wo rd m− 1 (R OO T) Xl + Xm Xr wordm (ROOT) (3.</S>
			<S sid ="112" ssid = "70">2) Un ary rul e te mp lat es N → N (3.</S>
			<S sid ="113" ssid = "71">3) Bo tto m sta te te mp lat es Xl len Xr len Xl −2 Xl −1 Xr +1 len Xl−1 Xr+1 Xr+2 len w ll w lr X l le n wll wlr Xr len Xl Xr wll len Xl Xr wlr len wordl wordr Xl Xr len wordl wordr Xl Xr X l− 1 X l (L E A F) Xl+1 Xl (LEAF) Xl wordl (LEAF) Xl wll (LEAF) Xl+a Xr+b len wordl+a wordr+b −1 ≤ a, b ≤ 1 (3.</S>
			<S sid ="114" ssid = "72">3) To p sta te te mp lat es X l− 1 X l (L E A F) Xl+1 Xl (LEAF) Xl wordl (LEAF) Xl wll (LEAF) Xl+a Xr+b len wordl+a wordr+b −1 ≤ a, b ≤ 1 Table 3: Feature templates for parsing, where X can be word, first and last character of word, first and last character bigram of word, POS tag.</S>
			<S sid ="115" ssid = "73">Xl+a /Xr−a denotes the first/last a X in the span, while Xl−a /Xr+a denotes the a X left/right to span.</S>
			<S sid ="116" ssid = "74">Xm is the first X of right child, and Xm−1 is the last X of the left child.</S>
			<S sid ="117" ssid = "75">len, lenl , lenr denote the length of the span, left child and right child respectively.</S>
			<S sid ="118" ssid = "76">wl is the length of word.</S>
			<S sid ="119" ssid = "77">ROOT/LEAF means the template can only generate the features for the root/initial span.</S>
			<S sid ="120" ssid = "78">ing, we perform joint decoding to combine information from the three models.</S>
			<S sid ="121" ssid = "79">Parameters of word segmentation (θseg ), POS tagging (θpos ), and parsing models (θparse = θbottom⊕top⊕ unary⊕bianry ) are s caled by three positive hyper-parameters α, β, and γ respectively, which control their contribution in the joint model.</S>
			<S sid ="122" ssid = "80">If α &gt;&gt; β &gt;&gt; γ, then the joint model is equivalent to a pipeline model, in which there is no feedback from downstream models to upstream ones.</S>
			<S sid ="123" ssid = "81">For well tuned hyper-parameters, we expect that segmentation and POS tagging results can be improved by parsing information.</S>
			<S sid ="124" ssid = "82">The hyper- parameters are tuned on development data.</S>
			<S sid ="125" ssid = "83">In the following sections, for simplicity we drop α, β, γ, and just use θseg , θpos , θparse to represent the scaled parameters.</S>
			<S sid ="126" ssid = "84">The basic idea of our decoding algorithm is to extend the CYK parsing algorithm so that it can deal with transition features in POS tagging and segmentation scores in word segmentation.</S>
			<S sid ="127" ssid = "85">3.4.1 Algorithm The joint decoding algorithm is shown in Algorithm 1.</S>
			<S sid ="128" ssid = "86">Given a sentence x = c1, . . .</S>
			<S sid ="129" ssid = "87">, cl , Line 0 calculates the scores of all possible words in the sentence using Eq(1).</S>
			<S sid ="130" ssid = "88">There are l(l + 1)/2 word candidates in total.</S>
			<S sid ="131" ssid = "89">Surrounding words are important features for POS tagging and parsing; however, they are unavailable because segmentation is incomplete before parsing.</S>
			<S sid ="132" ssid = "90">Therefore, we adopt pseudo surrounding features by simply fixing the context words as the single most likely ones.</S>
			<S sid ="133" ssid = "91">Given a word candidate wi,j from ci to cj , its previous word s′ is the rightmost one in the best word sequence of c1, . . .</S>
			<S sid ="134" ssid = "92">, ci−1, which can be obtained by dynamic programming.</S>
			<S sid ="135" ssid = "93">Recursively, the second word left to wi,j is the previousword of s′.</S>
			<S sid ="136" ssid = "94">The next word of wi,j is defined similar ly.</S>
			<S sid ="137" ssid = "95">In Line 1, we use bidirectional Viterbi decoding to obtain all the surrounding words.</S>
			<S sid ="138" ssid = "96">In the forward direction, the algorithm starts from the first character boundary to the last, and finds the best previous word for the ith character boundary bi . In the backward direction, the algorithm starts from right to left, and finds the best next word of each bi .In Line 2, for each word candidate, we can calcu late the score of each POS tag using state features in the POS tagging model, since the context words are available now.</S>
			<S sid ="139" ssid = "97">The score function of word wi,j with POS tag t is: scoreseg⊕pos (x, i, j, t) = scoreseg (x, i, j) + θpos · fpos (x, wi,j , t) (2) In Line 3, POS tags of surrounding words can be obtained similarly using bidirectional decoding.</S>
			<S sid ="140" ssid = "98">Algorithm 1 Joint Word Segmentation, POS tagging, and Parsing Algorithm Input: Sentence x = c1 , . . .</S>
			<S sid ="141" ssid = "99">, cl , beam size B, scaled word segmentation model, POS tagging model and parsing model.</S>
			<S sid ="142" ssid = "100">Output: Word sequence, POS tag sequence, and parse tree 0: ∀0 ≤ i ≤ j ≤ l − 1, calculate scoreseg (x, i, j) using Equation (1) 1: For each character boundary bi , 0 ≤ i ≤ l, get the best previous and next words of bi using bidirectional Viterbi decoding 2: ∀0 ≤ i ≤ j ≤ l − 1, t ∈ T , calculate scoreseg⊕pos (x, i, j, t) using Equation (2) 3: ∀bi , 0 ≤ i ≤ l, t ∈ T , get the best POS tags of words left/right to bi using bidirectional viterbi decoding.</S>
			<S sid ="143" ssid = "101">4: For each word candidate wi,j , 0 ≤ i ≤ j ≤ l − 1 5: For each bottom state N , POS tag t ∈ T ✁ step 1 (Line 57): get bottom states 6: scorebottom (x, i, j, wi,j , t, N ) = scoreseg⊕pos (x, i, j, t) + θbottom · fbottom (x, i, j, wi,j , t, N ) 7: Keep B best scorebottom . 8: For each top state N ✁ step 2 (Line 89): get top states 9: scoretop (x, i, j, wi,j , t, N ) = maxN {scorebottom (x, i, j, wi,j , t, N ) + θtop · ftop (x, i, j, wi,j , t, N ) +θunary · funary (x, i, j, wi,j , t, N → N )} 10: for i = 0, . . .</S>
			<S sid ="144" ssid = "102">, l − 1 do 11: for width = 1, . . .</S>
			<S sid ="145" ssid = "103">, l − 1 do 12: j = i + width 13: for k = i + 1, . . .</S>
			<S sid ="146" ssid = "104">, j do 14: scorebottom (x, i, j, w, t, N ) = maxl,r {scoretop (x, i, k − 1, wl , tl , N l ) + scoretop (x, k, j, wr , tr , N r ) +θbinary · fbinary (x, i, j, k, w, t, N → N r + N r ) + θpos · fpos (tlast → tf irst ) l r +θbottom fbottom (x, i, j, w, t, N )} 15: Keep B best scorebottom ✁ step 1 (Line 1415): get bottom states 16: For each top state N ✁ step 2 (Line 1617): get top states 17: scoretop (x, i, j, w, t, N ) = maxN {scorebottom (x, i, j, w, t, N ) +θunary · funary (x, i, j, w, t, N → N )} 18: end for 19: end for 20: end for L i n e 0 1 2 3 6 9 1 4 1 5 To tal Bo un d( w.r .t. l) Co mp lex ity l2 l2 |T |l2 |T |2 l2 |T |M l2 B M l2 l3 M B2 B M l2 l 3 M B 2 Table 4: Complexity Analysis of Algorithm 1.</S>
			<S sid ="147" ssid = "105">That is, for wi,j with POS tag t, we use Viterbi algorithm to search the optimal POS tags of its left and right words.</S>
			<S sid ="148" ssid = "106">In Lines 49, each word was initialized as a basic span.</S>
			<S sid ="149" ssid = "107">A span structure in the joint model is a 6tuple: S(i, j, w, t, N , N ), where i, j are the boundary indices, w, t are the word sequence and POS sequence within the span respectively, and N , N are the bottom and top states.</S>
			<S sid ="150" ssid = "108">There are two types of surrounding n-grams: one is inside the span, for example, the first word of a span, which can be obtained from w; the other is outside the span, for example, the previous word of a span, which is obtained from the pseudo context information.</S>
			<S sid ="151" ssid = "109">The score of a basic span depends on its corresponding word and POS pair score, and the weights of the active state and unary features.</S>
			<S sid ="152" ssid = "110">To avoid enumerating the combination of the bottom and top states, initialization for each span is divided into 2 steps.</S>
			<S sid ="153" ssid = "111">In the first step, the score of every bottom state is calculated using bottom state features, and only the B best states are maintained (see Line 67).</S>
			<S sid ="154" ssid = "112">In the second step, top state features and unary rule features are used to get the score of each top state (Line 9), and only the top B states are preserved.</S>
			<S sid ="155" ssid = "113">Similarly, there are two steps in the merge operation: S(i, j, w, t, N , N ) = Sl (i, k, wl , tl , Nl , Nl ) + Sr (k + 1, j, wr , tr , Nr , Nr ).</S>
			<S sid ="156" ssid = "114">The score of the bottom state N is calculated using binary features fbinary (x, i, j, k, w, t, N → N r + N r ), bottom statefeatures fbottom (x, i, j, w, t, N ), and POS tag transi tion features that depend on the boundary POS tags of Sl and Sr . See Line 14 of Algorithm 1, where For joint word segmentation and POS tagging, a word is correctly predicted if both the boundaries and the POS tag are correctly identified.</S>
			<S sid ="157" ssid = "115">For joint segmentation, POS tagging, and parsing task, when calculating the bracket scores using existing parseval tools, we need to consider possible word segmentation errors.</S>
			<S sid ="158" ssid = "116">To do this, we add the word boundary information in states – a bracket is correct only if tlast f irst l and tr are the POS tags of the last word in the left child span and the first word in the right child span respectively.</S>
			<S sid ="159" ssid = "117">3.4.2 Complexity analysis Given a sentence of length l, the complexity for each line of Algorithm 1 is listed in Table 4, where |T | is the size of POS tag set, M is the number of states, and B is the beam size.</S>
	</SECTION>
	<SECTION title="Experiments. " number = "4">
			<S sid ="160" ssid = "1">4.1 Data.</S>
			<S sid ="161" ssid = "2">its boundaries, label and word segmentation are all correct.</S>
			<S sid ="162" ssid = "3">One example is shown in Figure 3.</S>
			<S sid ="163" ssid = "4">Notice that identity unary rules are removed during evaluation.</S>
			<S sid ="164" ssid = "5">The basic spans are characters, not words, because the number of words in reference and prediction may be different.</S>
			<S sid ="165" ssid = "6">POS tags are removed since they do not affect the bracket scores.</S>
			<S sid ="166" ssid = "7">If the segmentation is perfect, then the bracket scores of the modified tree are exactly the same as the original tree.</S>
			<S sid ="167" ssid = "8">This is similar to evaluating parsing performance on speech transcripts with automatic sentence segmentation (Roark et al., 2006).</S>
			<S sid ="168" ssid = "9">For comparison with other systems, we use the CTNP B5 corpus, which has been studied for Chinese word NP(0,2,5) segmentation, POS tagging and parsing.</S>
			<S sid ="169" ssid = "10">We use the standard train/develop/test split of the data.</S>
			<S sid ="170" ssid = "11">DetailsNR NN - - - - are shown in Table 5.</S>
			<S sid ="171" ssid = "12">Shanghai office Shanghai office Table 5: Training, development, and test data of CTB 5.</S>
			<S sid ="172" ssid = "13">4.2 Evaluation Metric.</S>
			<S sid ="173" ssid = "14">We evaluate system performance on the individual tasks, as well as the joint tasks.1 For word segmentation, three metrics are used for evaluation: precision (P), recall (R), and F-score (F) defined by 2PR/(P+R).</S>
			<S sid ="174" ssid = "15">Precision is the percentage of correct words in the system output.</S>
			<S sid ="175" ssid = "16">Recall is the percentage of words in gold standard annotations that are correctly predicted.</S>
			<S sid ="176" ssid = "17">For parsing, we use the standard parseval evaluation metrics: bracketing precision, recall and F-score.</S>
			<S sid ="177" ssid = "18">1 Note that the joint task refers to automatic segmentation and tagging/parsing.</S>
			<S sid ="178" ssid = "19">It can be achieved using a pipeline system or our joint decoding method.</S>
			<S sid ="179" ssid = "20">Figure 3: Boundary information is added to states to calculate the bracket scores in the face of word segmentation errors.</S>
			<S sid ="180" ssid = "21">Left: the original parse tree, Right: the converted parse tree.</S>
			<S sid ="181" ssid = "22">The numbers in the brackets are the indices of the character boundaries based on word segmentation.</S>
			<S sid ="182" ssid = "23">4.3 Parameter Estimation.</S>
			<S sid ="183" ssid = "24">We train three submodels using the gold features, that is, POS tagger is trained using the perfect segmentation, and parser is trained using perfect segmentation and POS tags.</S>
			<S sid ="184" ssid = "25">Some studies reported that better performance may be achieved by training subsequent models using representative output of the preceding models (Che et al., 2009).</S>
			<S sid ="185" ssid = "26">Hence for comparison we trained another parser using automatically generated POS tags obtained from 10-fold cross validation, but did not find significant difference between these two parsers when testing on the perfectly segmented development dataset.</S>
			<S sid ="186" ssid = "27">Therefore we use the parser trained with perfect POS tags for the joint task.</S>
			<S sid ="187" ssid = "28">Three hyper-parameters, α, β, and γ, are tuned on development data using a heuristic search.</S>
			<S sid ="188" ssid = "29">Parameters that achieved the best joint parsing result are selected.</S>
			<S sid ="189" ssid = "30">In the search, we fixed γ = 1 and varied α, β.</S>
			<S sid ="190" ssid = "31">First, we set β = 1, and enumerate α = 1 , 1 , 1, 2, . . .</S>
			<S sid ="191" ssid = "32">, and choose the best α∗.</S>
			<S sid ="192" ssid = "33">Then, System P R F (Jiang et al., 2008b) - - 97.74 (Jiang et al., 2008a) - - 97.85 (Kruengkrai et al., 2009) 97.46 98.29 97.87 (Zhang and Clark, 2010) - - 97.78 (Zhang and Clark, 2011) - - 97.78 (Sun, 2011) - - 98.17 Ours (w/o transition features) 97.45 98.24 97.85 Ours (with transition features) 97.44 98.23 97.84 4 2 we set α = α∗ and vary β = 1 , 1 , 1, 2, . . .</S>
			<S sid ="193" ssid = "34">, and 4 2 select the best β∗.</S>
			<S sid ="194" ssid = "35">Table 6 lists the parameters we used for training the submodels, as well as the hyper-parameters for joint decoding.</S>
			<S sid ="195" ssid = "36">M od el Pa ra me ter V a l u e Ch ara cte r ba se d wo rd se gm ent or Ga uss ian pri or # Fe atu re 0 . 0 1 3, 8 7 5, 8 0 2 W or d ba se d wo rd se gm ent or Ga uss ian pri or # Fe atu re 0 . 0 1 3 1 2 , 5 3 3 PO S tag ger Ga uss ian pri or # Fe atu re 0.1 48, 60 8,8 02 Pa rse r Ite rat ion Nu mb er # Fe atu re 10 49, 36 9,8 43 Joi nt H y p e r p a r a m e t e r α H y p e r p a r a m e t e r β H y p e r p a r a m e t e r γ B e a m S i z e B 4 0.5 1 20 Table 6: Parameters used in our system.</S>
			<S sid ="196" ssid = "37">4.4 Experimental Results.</S>
			<S sid ="197" ssid = "38">In this section we first show that our sub-models are better than or comparable to state-of-the-art systems, and then the joint model is superior to the pipeline approach.</S>
			<S sid ="198" ssid = "39">4.4.1 Evaluating Sub-models Table 7 shows word segmentation results using our word segmentation submodel, in comparison to a few state-of-the-art systems.</S>
			<S sid ="199" ssid = "40">For our segmentor, we show results for two variants: one removes transition features as described in Section 3.1, the other uses CRFs to learn the weights of transition features.</S>
			<S sid ="200" ssid = "41">We can see that our system is competitive with all the others except Sun’s that used additional idiom resources.</S>
			<S sid ="201" ssid = "42">Our two word segmentors have similar performance.</S>
			<S sid ="202" ssid = "43">Since the one without transition features can be naturally integrated into the joint system, we use it in the following joint tasks.</S>
			<S sid ="203" ssid = "44">Table 7: Word segmentation results.</S>
			<S sid ="204" ssid = "45">For the POS tagging only task that takes gold standard word segmentation as input, we have two systems.</S>
			<S sid ="205" ssid = "46">One uses the linear chain CRFs as described in Section 3.2, the other is obtained using the parser described in Section 3.3 – the parser generates POS tag hypotheses when POS tag features are not used.</S>
			<S sid ="206" ssid = "47">The POS tagging accuracy is 95.53% and 95.10% using these two methods respectively.</S>
			<S sid ="207" ssid = "48">The better performance from the former system may be because the local label dependency is more helpful for POS tagging than the long distance dependencies that might be noisy.</S>
			<S sid ="208" ssid = "49">This result also confirms our choice of using an independent POS tagger for the sub-model, rather than relying on a parser for POS tagging.</S>
			<S sid ="209" ssid = "50">However, since there are no reported results for this setup, we demonstrate the competence of our POS tagger using the joint word segmentation and POS tagging task.</S>
			<S sid ="210" ssid = "51">Table 8 shows the performance of a few systems along with ours, all using the pipeline approach where automatic segmentation is followed by POS tagging.</S>
			<S sid ="211" ssid = "52">We can see that our POS tagger is comparable to the others.</S>
			<S sid ="212" ssid = "53">System P R F (Jiang et al., 2008b) - - 93.37 (Jiang et al., 2008a) - - 93.41 (Kruengkrai et al., 2009) 93.28 94.07 93.67 (Zhang and Clark, 2010) - - 93.67 (Zhang and Clark, 2011) - - 93.67 (Sun, 2011) - - 94.02 Ours (pipeline) 93.10 93.96 93.53 Table 8: Results for the joint word segmentation and POS tagging task.</S>
			<S sid ="213" ssid = "54">For parsing, Table 9 presents the parsing result on gold standard segmented sentence.</S>
			<S sid ="214" ssid = "55">Notice that the result of (Harper and Huang, 2009; Zhang and Clark, 2011) are not directly comparable to ours, as they used a different data split.</S>
			<S sid ="215" ssid = "56">The best published system result on CTB5 is Petrov and Klein’s, which used PCFG with latent Variables.</S>
			<S sid ="216" ssid = "57">Our system performs better mainly because it benefits from a large amount of features.</S>
			<S sid ="217" ssid = "58">Table 10: Results for the joint segmentation, tagging, and parsing task using pipeline and joint models.</S>
			<S sid ="218" ssid = "59">Table 9: Parsing results using gold standard word segmentation.</S>
			<S sid ="219" ssid = "60">For our parser, besides the model described in Section 3.3, we tried two variations: one does not use the automatic POS tag features, the other one is learned on the parent annotated training data.</S>
			<S sid ="220" ssid = "61">The results in Table 9 show that there is a performance degradation when using parent annotation.</S>
			<S sid ="221" ssid = "62">This may be due to the introduction of a large number of states, resulting in sparse features.</S>
			<S sid ="222" ssid = "63">We also notice that with the help of the POS tag information, even automatically generated, the parser gained 0.9% improvement in F-score.</S>
			<S sid ="223" ssid = "64">This demonstrates the advantage of using a better independent POS tagger and incorporating it in parsing.</S>
			<S sid ="224" ssid = "65">Finally Table 10 shows the results for the three tasks using our joint decoding method in comparison to the pipeline method.</S>
			<S sid ="225" ssid = "66">We can see that the joint model outperforms the pipeline one.</S>
			<S sid ="226" ssid = "67">This is mainly because of a better parsing module as well as joint decoding.</S>
			<S sid ="227" ssid = "68">In the table we also include results of (Jiang et al., 2009), which is the only reported joint parsing result we found using the same data split on CTB5.</S>
			<S sid ="228" ssid = "69">They achieved 80.28% parsing F-score using automatic word segmentation.</S>
			<S sid ="229" ssid = "70">Their adapted system Jiang09+ leveraged additional corpus to improve Chinese word segmentation, resulting in an F- score of 81.07%.</S>
			<S sid ="230" ssid = "71">Our system has better performance than these.</S>
			<S sid ="231" ssid = "72">4.5 Error Analysis.</S>
			<S sid ="232" ssid = "73">We compared the results from the pipeline and our joint decoding systems in order to understand the impact of the joint model on word segmentation and POS tagging.</S>
			<S sid ="233" ssid = "74">We notice that the joint model tend to generate more words than the pipeline model.</S>
			<S sid ="234" ssid = "75">For example, “巴尔一行” is one word in the pipeline model, but correctly segmented as two words “巴尔/一行” in the joint model.</S>
			<S sid ="235" ssid = "76">This tendency of seg mentation also makes it fail to recognize some long words, especially OOV words.</S>
			<S sid ="236" ssid = "77">For example, “事 实上” is segmented as “事实/上”.</S>
			<S sid ="237" ssid = "78">In the data set, we find that, the joint model corrected 10 missing boundaries over the pipeline method, and introduced 3 false positive segmentation errors.</S>
			<S sid ="238" ssid = "79">For the analysis of POS tags, we only examined the words that are correctly segmented by both the pipeline and the joint models.</S>
			<S sid ="239" ssid = "80">Table 11 shows the increase and decrease of error patterns of the joint model over the pipeline POS tagger.</S>
			<S sid ="240" ssid = "81">An error pat tern “X → Y” means that the word whose true tag is ‘X’ is assigned a tag ‘Y’.</S>
			<S sid ="241" ssid = "82">All the patterns are ranked in descending order of the reduction/increase of the error number.</S>
			<S sid ="242" ssid = "83">We can see that the joint model has a clear advantage in the disambiguation of {VV, NN}and {DEG, DEC}, which results in the overall im proved performance.</S>
			<S sid ="243" ssid = "84">In contrast, the joint method performs worse on ambiguous POS pairs such as{N N, N R}.</S>
			<S sid ="244" ssid = "85">This observation is similar to those re ported by (Li et al., 2011; Hatori et al., 2011).</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "5">
			<S sid ="245" ssid = "1">In this paper, we proposed a new algorithm for joint Chinese word segmentation, POS tagging, and parsing.</S>
			<S sid ="246" ssid = "2">Our algorithm is an extension of the CYK err or pa tte rn # ↓ err or pa tte rn # ↑ N N → V V 47 19 N N → N R 15 12 V V → N N 42 13 N R → N N 7 5 D E G → D EC 23 10 J J → P 1 4 N N → J J 29 8 N N → D T 2 4 D EC → D E G 11 4 P → V V 3 2 J J → N N 12 4 A D → N N 1 2 Table 11: POS tagging error patterns.</S>
			<S sid ="247" ssid = "3"># means the error number of the corresponding pattern made by the pipeline tagging model.</S>
			<S sid ="248" ssid = "4">↓ and ↑ mean the error number reduced or increased by the joint model.</S>
			<S sid ="249" ssid = "5">parsing method.</S>
			<S sid ="250" ssid = "6">The sub-models are independently trained for the three tasks to reduce model complexity and optimize individual sub-models.</S>
			<S sid ="251" ssid = "7">Our experiments demonstrate the advantage of the joint models.</S>
			<S sid ="252" ssid = "8">In the future work, we will compare this joint model to the pipeline approach that uses multiple candidates or soft decisions in the early modules.</S>
			<S sid ="253" ssid = "9">We will also investigate methods for joint learning as well as ways to speed up the joint decoding algorithm.</S>
			<S sid ="254" ssid = "10">Acknowledgments The authors thank Zhongqiang Huang for his help with experiments.</S>
			<S sid ="255" ssid = "11">This work is partly supported by DARPA under Contract No.</S>
			<S sid ="256" ssid = "12">HR001112-C-0016.</S>
			<S sid ="257" ssid = "13">Any opinions expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.</S>
	</SECTION>
</PAPER>
