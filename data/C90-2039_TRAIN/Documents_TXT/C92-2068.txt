Quasi-Destructive Graph Unification with Structure-Sharing* 
Hideto Tomabechi 
Carnegie Mellon University 
109 EDSH, Pittsburgh, PA 15213-3890 
t0mabech@cs.cmu.edu 

Abstract 
Graph unifi(:ation remains the nlost expensive part of unificatiou-b~Lsed grammar l)arsing. We fl)cus on (Hie 81}ee(l-u 1) elelltellt ill the design of llllifiea-tion algorithms: avoidance of copying of umao(li-fled sul)graph.s. We propose a method of attaining snch a design through a nlethod of structnre-sharing which avoids log(d) overheads often associated with structure-sharillg of graphs without any use of costly dependency pointers. The proposed scheme elimi-nates redundant copying whih~ maintaining the qua.si- dc,qtructive scheme's ability to avoid over copying and early copying eomlfined with its ability to handle cyclk: structures without algorithnfie additions. 

1 Motivation 
Despite recent efforts in improving graph unification algorithms, graph unification renlains the most ex-pensive part of parsing, both in time and space. ATR's latest data fi'om the SL-TRANS large-scale speech-to-speech translation project ([Morimoto, et al, 1990]) show 80 to 90 percent of tot~ parsing time is still consumed by graph unification where 75 to 95 percent of time is consumed by graph copying fune- ti(ms. 1 Qu~si-Destruetive (Q-D) Graph Unification ([Tontabeehi, 1991]) was deveh)ped as a fiLst variation of non-destructive graph unification based upon the notion of time-sensitive 'qu~mi-destruction' of node structures. The Q-D algorithm was proposed I)~Lsed upon the following m:cepted obserwttion about graph unification: 
Unification does not always succeed. 

Copying is an expensive operation. 

The design of tit(', Q-D scheme was motiwttcd by the following two princil)les h~r frost gral)h unification ba,sed upon the above observations: 
• 	
Copying should be performed only for suc- cessful unifications. 

• 	
Unification failures should be found as soon as possible. 



*This research wa.8 (lone while the author was ~ Visiting Research Scientist at ATR Interpreting Telephony [O~search Laboratories. 
lBased on unpublished reports from Knowledge itnd Data Processing Dept. ATR. The observed tendency was that sen-tellCCS with very long parsing tillle requiting a large Ii|lltll~t~r of unification calls (over 200l} top-level calls) coll811lllcd extremely htrge proportion (over 93 percent) of total paraing time ft~r graph unification. Similar data tep0rted in [Kogure. 19901. 
and eliminated Over Copying and Early Copying (as defined in [Tomabechi, 1991] 2) and ralt about twice the speed of [Wroblewski. 1987]'s algorithm, a In this pal)er we proi)ose another design principle f(n' graph unification bmsed upon yet another accepted observa- tion that: 
Unmodified subgraphs can be shared. 
At lemst two schelnes have been proposed recently ])a.~ed Ul)OU this observation (namely [Kogure. 1990] and [Emele, 1991]); however, both schemes are I)ased upon the increlllent'al Col)yiug sehellle all(l ~-LS ([e- scribed in [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi'om Early Copying as de-fined in that article. This is I)eeause, when a unifica-tion falls, the copies that were (:reated up to the point of failure are w~Lste(l if copies are created incremen-t;ally, By way of definition we would like to catego-rize the sharing of struetul'eS in gral)hs into Feature- Structure Sharing (FS-Sharing) ~nd Data-Structure Sharing (DS-Sharing). Below arc our definitions: 
• 	
Feature-Structure Sharing: Two or more dis- tinct i)~,ths within a graph share the same sub-graph by (:onwwging (111 the same node equiv-alent to the notion of structure sharing or reen- lrancy in linguistic theories (such ~ in [Pollard and Sag, 1987]). 

• 	
Data-Structure Sharing: Two or more dis-tinct graphs share the same subgral)h by con-verging nil the same node the noti(m nf 


2 Namely. 
• 	
Over Copying: Two dags ate created in order to create one new dag, This typically happens when Col)its of two input d~tgs are created prior to a destructive unific~Ltion operation to build one new dag. 

• 	
Early Copying: Copies ar~ created prior to the failure of unification so that copies (:reltted since the beginning of the unitication up to the point of failure are wasted. 


Wroblewski defined Early Col)ying as follows: "The argutnent dags are copied be/t~teunification started. If the unilication fails then some of the Ct)l)ying is wasted effort" attd restricts early copying to cases that only apply to copies that are created prior to a unification. Our definition ()f Early Copying includes copies that ~rc created during a unification and created up t() the point of fltilur(~ width were iltt(!ow~red by Wroblewski's definition. 
3 Recent (~xp(~rilnents COlllhlctt~d ill the Knowledge all(] Data Pro(:esniug Dept. of ATR shows the original Q-D algorithm COllsiatelltly rllllS lit ~tt~out 40 ])q~rctrl|t ~ff the elal)sed tillle uf Wroblewski'8 algorithm with its SL-TRANS large-scale upoken-languag,~ ttansl~ttlon system (with over l(t00{I gram- matical gral)h nodes). 

straeture-sharing at tim data structure level. [Kogurc, 1990] cldls Coltying of sui:h strltctures 
Redundant Copyin 9. Virtually all gral~ll-lutitication alg(n'itlinl,,; suptmrt FS-Sh~triug and some SUliport DS-Sharing with vary- ing levels (if overhead. In this lisper we proltOSl~ ~t sclienle of graph unification I)tmed UllOn a qu;~si-destrtt(:tive gratth uniti(:ati(m inetlloll that attains DS-Sharing with virtually no overh(',ad for structure- sharing. Henceforth, in tills palter, structltre-sharing refers tit DS-sllariug unless otllerwise n(ited. Wc will see that tfic iutroducti(m of strlu:ture-sliarilag to qua~si-destructive imification art;tins another two-fold increase ill rim tiluc spired. The graphs llamdled in the scheme (:;tit lie auy dirc(:ted grai)ll and cycli(:ity is llaudled without any algorithmic ;tdditions. 
Our design princiitles for achieving structlu'C-sharing in tit(', qlta.si-destructive scllellU~ are: 
• 	Atomic and Bottom nodes can be shared 4 
Atomic nodes can lie sltarcd sahdy since they tlever cli~l, llge their wdues. B(Ittolll llodl!s Call It(! share(l 5 sittce bottom nodes are always fl)rwal'ded to somc other uo(Jes wllcn they unify. 
• 	Complex nodes can be shared unless they are modified-conq)lex nodes (:all bc COllSld- ercd modified if they ~tre a target of the fitrward- ing operation m' if riley received the curreut ad- ditiml of comltlcment arcs (into COml)-ari:-list in (pia,si-destructive sclmme). 
By designing an algorithm ba.sed Ult,m these pril> (:il)les for strlu:ture-sliarillg while retaining the quasi- destructive nature of [Totnat)echi, 1991]'s algoritllnl, our scllmnc eliniinates l{,cdlnt(tant Cllpying whih~ elinlinating botll Early Copying auld Over Copying. 



2 Q-D Graph Unification 
We Woldd first like to describe tlle qu;Lsi-destructiwe (Q-D) graph unilication schenle which is the lnLsis of our s(:henl(,'. As a data structltrl~, at nolle is rcpre sentcd with live fiehls: type, arc-llst, comp ark-list. fm'w~u'd, (:oily, and geueration. 6 The data-structure for an at'(: has two liclds, qabel' and 'value'. "Lot)el" is an atmnic symt)ol wllicli labels tile ;u'e. and 'wdue" is a llointer to a llo(le structure. 
The central notion of tile Q-D algm'itlun is tile del)eudency of the retiresentational (:ontcnt on the glob~d timing clol:k (or thc global counter for tlic currcnt generation of lUlific;~tions). Any luodilic;~tiol~ made to coml)-arc-list, forward, or i:Olly rid(Is during one top-lcw:l uniticati(m (:au bc inwdidated by (me in- (:renlent otmration inl tile global timiug counter. COIl tents of the (xmlp-arc-list, forward and (:opy fields arc 
'IAtomic lto([l~8 ;ire IlodeH (halt reprea(~llt atoluic vcdue8, lie( loin nodes are llo{|e8 that repreuellt variabh*. 
~As long as the unific~ttion Ol)er,~tion is the only operation to nmdify graphs. 
6 Note that [Tonlabechi, 1991] used sellarttte lltark fields fin COml)-;trc-liat, forward, fill(| copy: (:urrently however, (}lily f}lltt general(kin mark is used for adl three fiehls. Thanks are due to Hidehiko M~U,uo of T,)yo Informattion Sy,tcms (TIS) for suggesting thin. 
NODE 
type 
+ ............... + 

are-list 
+............... + 

comp-nrc-lint 
+ ............... + 

~orward IRC 

+ ............... + + ............... + 



copy I label I 
+ ............... + + ............... + 

generation I value I 
............... + ............... ÷ 

Figure 1: Node and Arc Structures 
resl)cctc(l ,rely wlten tile ge.neration mark of the lml'- ticlll~u' node nuttches tile current glob;d comat.er wdue. Q-I) graph unificatiola ham two kinds of arc lists: 1) ar,:-list and 2) colnt~;u'c-list. Arc-list (:Ollt~tins the arcs that are p(!rln;tu(!nl (i.e.. ordimLry gral)li arcs) and Cillnp-arc list contains arcs that are rally wdid during one top-hwel graph unitication oper;d, ion. Tim algorittun also uses two kintls of fi)rwardlng links, i.e,, l)(!rttlalal!nt ;IAl(l t;(!llll)Ol'&l'y, i ll(!rlll~l,llellt forwar(fillg link is the usual fm'warding link ftnmd in ottler' ;d- goritfilns ([Pereir~t, 19851, [Wroblewski. 1987], ctc). Telnl)orary forwarding links arc links tlud. arc only wdid during onc top-level unilic~tti(m, Tlic currency IIf the temporary links is (letermiued by matching the emlteut of tim generati(nl field for the links witll the gl(ibal (:ounter; if they nutt(:ll, the content of this tiehl is respect[~d 7. As in [Pereira, 1985]. tile Q D ~dgorithln lla.S tltree types of uodes: 1) :atonfic. 2) :lie(torn 8, and 3) :conqth!x. :atOllli(: tyllc nodes rep-res(mt at(nni( synll)ol values (such ;~s 'Noun'), :bet tom type n(Jdes are variables and :(:()lttl)lcx tylac nodes ~l.re Ilo(les that have art:s i:ol[litlg (lilt of thenl. Arcs are stored in the m'cqist tiehl. Tile atomic vahl(! is also storc.d in the m'c-list if the node tyttc is :at,imil:. :llottom nodes succeed in unifyiug with nny uodes and the result of lint(it:alien t~kes tim type ~md the value of the node tlutt the :bottona nI)de w;m unified with. :atonli(: nodes succeed in unifying with :btIttona nodes or :at(lllliC llO(li~s with the mune vallle (Stilted in the arc-list). UnificatioD of an :atomic uode with a :co]tll)lex llOde illlllte([iatcly filJls. :cottll)lex taodes site(reed in unifying with :bottolit nodes or witll :(:OUl- l)lex trades whose subgrlqdls all unity. ° Figure 2 is the central qllmsi-,lestructlw~ graph unifi(:ation algorithm and Figur('. 3 is the dcrcfel'encing 1° flulction. Fig-lit'(? 4 shows the algoritlill; for (:ollying ttilfl(!s all(1 ~Lrcs (called from lmify0) wllih~ respecting the (:Ollt(mts of ~a~4 "~x~ist~ 
7~1~ do II(It ]l~tVe ~t separate field for temporary forwtLrding links; instead, we desigllat(t tile integer wdue 9 to repreuent a permanent f,~rwatding llnk. We Ht~trt incrementing the global COUltter f[Olll 10 ,() whellever the gener;tti(ut lu~trk i8 lIO| 9, the integer vahle 11111~4t e(ltla] the globad COllltter v;tllle to reulmCt the forwaxding link. 
8 lqottom i8 called leaf in Pereira'u algorithm. 
9Arc wtlues are ,'always It(Idea aLnd never synlbolie V~dlle8 be- cause :atomic *uLd :bottom nodes lilly lie (or ]l(}cO]ll(}) poillted to by luultiph: arl:x (i.e, FS-Sh~ring) depemlil~g on gt0annlar COllHtr.'killtg, and we do not want arcu to (:oltt~tln terlnin~d atomic V~lleO. 
l°Derefi~rel|Cillg i8 till opera((loll to recllrsively traw~rae f.r-w;trding links to return the target mille of forwarding. 

QUASI-DI~qTnuCTIVE ~RAPI[ UNIFICATION ] 
FUNCTION unify-dg(dgl,dg2}; 
result ~ catch with tag 'unify-fail 

calling unify0(dgl,dg2): 
increment *unify-global-counter*: ;; starts front 1(} 11 
ret urn (result); 

END; 

FUNCTION unify0(dgl,dg2); 
if '*T* = unifyl(dgl,dg2); THEN 
copy ~ copy-dg-with-coml)-arcs(dgl); 
return(copy); 

END; 

FUNCTION unify1 (dgl-underef,dg2-undercf): dgl ~ derefercnce-dgldgl-underef); dg2 ~ dereference-dgl dg2-undercf }: IF (dgl.copy is son-empty)THEN 
dgl.copy ~ nil; :; cutoff ullt:ltrrent copy 
IF (dg2.copy is non-empty) THEN 
dg2.copy ~ nil; 
IF (dgl = dg2)I~THEN 
return('*T*); 

ELSE IF (dgl.type = :bottom) THEN 
forward-dg( dgl,dg2 jt empor asy); 
return('*T*); 

ELSE IF (dg2.type = :bottom) THEN 
forward-dg( dg2,dgl,:tem porary ); 
rcturn('*T*); 

ELSE IF (dgl.type = :atomic AND 
dg2.type = :atomic) THEN 

IF (dgl.arc-list = dg2.arc-list)13THEN forward-dg( dg2,dgl,:tempor ary}: return('*T*); 
ELSE throwt4with keyword 'unify-fail; 
ELSE IF (dgl.type = :atomic OH 
dg2.type = :atomic) THEN 
throw with keyword 'unify-fail; 

ELSE shared ~ intersectaxcs(dgl,dg2); 
forward-dg( dg2,dgl,:t empor ary ); 15 
FOR EACH arc IN shared DO 

unifyl(destination of the shared arc for dgl, destination of 
the shared arc for dE2); new ~ complementarca(dg2,dgl); 16 IFlT(dgl.comp-arc-list is non-empty) THEN 

IF (dgl.generation = *unify-gloh;d-counter*) THEN FOR EACH arc IN new DO push as['. to dgl,comp-arc-list,, ELSE dgl.colnp-arc-list ~ nil: ELSE dgl.genera.tion ~ *unify-glohal-couttter*: dgl.comp-arc-list ~-new; return ('*T*); END: 
FigLure 2: The Q-D Unification Functions Tit(' functions Contl)lenlelttarcs((lgl,dg2) and In-
119 indicates a l)ermanent forwarding link. 
12 EquM in the 'eq' 8ellse. Bec~tuae of forwarding altd cycles, 


it is possible that dgl and dg2 are "eq'. 13 Arc-list contains atomic value if the node is of type :atomi(. 14Catch/throw coastxuct; i.e., immediately return to unify-
dE. 
lSThis was performed ~dter FOR EACH letup in [Tonrahechi, 19911 which couht haw~ c~.uacd it prtddem writ a sttccessful cyclic call. Thanks are due to Marie Boyle of University of Tuebingen fur suggesting the change. 
16Colnplementarcs(dg2jlgl) was called before unifyl recur- siena in [Tomabechi, 1991], Currently it is moved to after all unifyl recuraions successfully return. Thanks are ;dso due to Marie Boyle for suggestiug this. 
17This check was added after [Tomabechi, 1991] to avoid over-writiltg the conlp-arc-list wll(~ll it is wrltt(,it more than once within one Ulfify0 call. Thanks are duc to Peter Neuhaus of Oniversitiid Karlsruhe for reporting this l)roblem. 

C;RAPll NODF" DF',F'F'FERF'NF'ING ] 
FUNCTION dereference-dg(dg): 
f(>rward-dest ~ dg.forward; 
IF (forward-dent is non-empty) THEN 
IF (dg.generation : *unify-global-counter* OR 
rig.generation = 9) THEN 
dereferetu:e-dg( for ward-dent ); 
ELSE dE.forward ~ nil: :; make it GCable retura(dg)', ELSE return(rig); END; 
Figure 3: The Q-D Dereference Function 
t('rsc('tarcs(dgl,dg2) return the sct-diff(,renF`(" (the arcs with labels that exist in dgl but not in dg2) and intersection (the arcs with labels that exist both in dgl and dg2). During th(" sct-difl'erence and sct-iutersection otlera.tiultS, the (,ulttent of colnp-arc-lists art" respected ms parts of arc lists if the genera.tion mark matchs the current va.lu(, of the globa.l tinting counter. Forward(rig1, dE2, :forward-type) puts (tg2 in tile forwa.rd field of dgl. If the keyword in the fun('tion call is :temporary. the eurrev.t valu(, of the *unify-glob;d-counter* is writtea in the generation fiehl of dgl. If the kcyword is :perman(,nt, 9 is writ- ten in the generation fiehl of (lgl. 18 The temporary forwarding links are necessary to handle rcentrancy and cycles. As soon as unification (at any level of r(,cursion through sha.rcd art,s) is performed, a. tem- l)orary forwarding link is made from dg2 to dgl (dE1 to dE2 if dgl is of type :bottom). Thus, during unifi- cation, a. node already unified by othcr recursive calls to unify1 within the same unify0 c',dl has a temporary forwarding link from dg2 to dE1 (ur dgl to dE2). As a result, if this node becomes an int)ut argument node, derefcrencing the node causes dgl a.ud dg2 to lleconte tile Salll(, llo(lc attd unification immediately succeeds. Thus, a subgraph below an Mrea(ly unified nude will not be checked inore than once even if an a.rgument graph has a. cycle. 19 
[ QUASI- DF`STI1UCTIVF, COPYING ] 
FUNCTION copy-dg-wit h-conq*-arcs(dg-underef): dg ~ dereferencc~dg(dg-underef}; IF (dg.copy is iron-empty AND 
dg.copy.generation 2n ~ *unify-gloh',d-countcr*) THEN 

ret urn(dg.copy); 21 
ELSE IF (dg.type = :atomic) THEN 
ncwcopy ~ create-node(); 2~ 
newcopy.type ~ :atolltic; 
newcopy.arc-list ~ dg,arc-list: 
Itewcopy.gel|eratiolt ~ *tinily-global-counter*; 
dg.copy ~ newcopy; 
ret urn(newcopy); 
ELSE IF {dg,type = :bottom) THEN 
ltewcopy ~ creatc-nodel ); 
newcopy, type 4~ :hottoltl; 
I~ewcopy.gem!rlttioll ~ *unify-global-counter*; 
dg.copy ~ newcopy; 
ret urtt( newcopy )i 
ELSE 
18permanent forwardings may be needled by gr~tlltlltar COlll- pliers that merge graphs. 
l°Also, during copying suhaequent to a mlccessful unitica- tioll, two 0d¢:8 COllvergillg into the 8&lltl~ llode will Ilot c~*,lSe ovcrcopying simply because if a node already has a copy then the copy is returned. 

lieW(;Opy ~ (:reilt.:-node(); 
lleWCOpy.type ~ :COlllp|i~x; 
newcopy.g(~neratioll ~ *ltnify-glolnd-countel*: 
dg.col)y ~-lieWco|)y: 23 
FOR ALL arc IN dg,arc-llst DO 

n(~warc ~ ctlpy-arc-alid-ct)lnp-llrc(arc)l pllsh ll()w,%rc into newct)py.ttrc-li,t; IF (dg.coiup-arc-li,t is non-mnpty AND dg.generation -*unify-glohal-counter*) THEN 
FOR ALL c(nnp-ar(: IN dg.conll~-itrc-li~t DO li(~wlirc ~-- Col)y-arc-and-colllli-ltrc(colllp-arc}; plish liewltrc into n¢~wcopy.arc-liut; 
dg,cotnp-arc-list ~ nih 
return (newcopy): 

END; 
FUNCTION Colly-arc-aud- conq)-arc(inpu t - arc }; label ~-input-,xrc.labch V~dllO t'~ copy-dg-witil-coulp-arl:s(input-arc.valul~); return a liCW ~trc with hd,el itltd vahle; 
END; 


Figure 4: Node and Arc Copying Functions 
Q-D Copying + DS-Sharing 
In order to attain strncture-sharing during QmLsi-Destructive gral)h unitication, no niodifieation is nec- essary for the unification functions descrit)ed in the previous section. This section describes the qua.st-destructive copying with strueturc-sharing which re-places the original copying algorithm. Since uni-fication functions are unnt0ditied, the Q-D unities-lion without stru(:ture-sharing eau be mixed trivially with the Q-D unificatitm with strueturc-sharlng if such a mixture is desired (by simply choosing differ-eat copying fimetions). Infi)rlnally, the Q-D copying with structure-sharing is l)erformed in the following way. Atonfie and ])ottom llodes are shared, A COlll-plex node is shared if llo nodes below that node are changed (a node is considered ehange(I by being a target of forwarding or having a valid COlnp-arc-list). If a uode is ehaaged then that information is 1)~sed Ul) the graph path using multil)le-valut~ binding facil-ity when a copy of the nodes are recursively returned. Two wdues are returned, the first value being the Col)y (or original) nolle and the second value being the flag representing whethe, r any of the node below that node (including t, hat node) h;us been ehanged. Atomic aud bottonl nodes are always sharetl: however, they are considered changed if they were a target of forward- ing st) that the 'changed' infornlation is passed up. If the eomI)lex node is a target of forwarding, if no node behiw that node is changed then the ()rigin;d eonlplex node is shared; however, the '(:hanged' inforniatit)n 
20I.e.. the *gtill(Sratioli" fiehl of the iiodt, stored in tile q:olly' field of the "dg' llode. The Mgoritlnn (lescrihed in [Tomabechi, 1991] imt,d ~COlly-ln~rk' fiehl of'dg'. Currently 'generlttion' field replaces tile three lnltrk fiehl described ill the article. 
21I.e.. the cxisthig copy of the ilodc. 22 Creltto8 fin empty node 8tlliCiUr(L ~a'l'lli~ ofl~ratil)li to set it newly i:tl!iited copy node into tim 
'copy' field of Mg' w~ dolill Mter reclirSiOll into tubgtaph~ in tile Mgorithnl description in [Toinabechl. 19911 which wa~ it cause of iufinite D2CllrSiOll with it parlicuhtr type of cycle~ lit the graph. By llloving ill> to tills p(mltion flolll after the recilrtdon, 811ch a pr(~l)hmi Call be effectively avoided. Thilllk8 itr(2 due to 
Peter Neuhaus for reporting tile pro|lima. 
is l>~Lsse(l ut> when the recursion retunts. Below is the a<:tual algoritlnn description for the Q-D copying with structure-sharing. 
[ Q-I) C ............. s...... ......... S ....... 

I 
FUNCTION copy-dg-wit h-conq~-arce-share( dg-u nderef I: dg ~ dereference-dg(dg-underef); IF (dg,col)y i8 ito,-enlpty AND 
dg.ctqiy.generation = *unify-global-counter*) THEN 
IF (dg = rig.copy) THEN ~a 
newcopy ~-create-itode( ): 
newcopy.typc ~-:bottom; 
tmwcopy.gtmt~r ation ~ *unify-gh)b~d-ctm nt er *; 
dg.copy ~-- newt:spy; 
wdues(dg.copy.:changed): 25 
ELSE vMue~(dg,col)y,:changed); 

ELSE IF (dg ~ dg-underef) THEN copy- imde-comp-not - for war ded(dg); ELSE copy-node-cmnp-fi)rwardedidg); END; 
FUNCTION copy~node-comp-not-fi)rwarded(dg): IF (dg,type : :atolnic) THEN values(dg,uil); ;: rt~turn original dg with "liO ch;lllg(~' flag. ELSE IF (dg.type = :bottolll} THEN wdueu(dg.nil): ELSE 
IF (dg.cmnp-arc-liat is no.-empty AND rig,generation = *unify-globaLcounter*) THEN lmWCopy ~ creatt:-node(); newcopy.tylm ~ :eonwlex; n(~wcopy.genet&tiolt ~ *ullify-globAl-collnter*: dg.copy ~ newct)py: FOR ALL arc IN dg.arc-list DO 

newarc first Wdilt~ of copy-arc-and-contp-arc-Mlltre(arc); i)llsh liewitrc into lmwcopy,arc-]ist; FOR ALL conq)-arc IN rig,cutup-arc-list DO ilawltrc ¢~ firl4 t vahlc of copy-~trc-alld-ct )ill p-arc-share( corn [)-arc ): 
])uflh ileWltr(: iltto ilew(:opy.arc-|iat; dg.conlp-arc-list ~ nih wdtieu{ llew(:t~py,:chltlt ged ): 


ELSE 

state ~ IdL arcs ~ ldh dg.copy ~ rig 26 , dg.gtmerittiolt ~ *uliify-giol~al-i;o.nt(!r*; FOR ALL art: IN rig.arc-list DO 
itewar¢,challge~tl ~ (:opy-arC-~lld-t:Olllp-ar(-sh;tr~(arc}; 
pus|t newart: illt~ arcs: 
IF (changed has wdue) THEN 

state ,-I:hllligl~d; 
IF (state has vldue) THEN 

IF (rig.copy # dg) THEN dg.copy.arc-liat , Arcs: dg.copy.type ~ :complex; vldues{ tlg.ct~py,:changed ); 
ELSE 
liewcopy ~ create-node(); 
newcopy.type ~-:comtdex; 
llewcopy.getleratioll ~ *tniify-gl()lnd-ctnlntl~r*; 
newcopy.arc-liat ~ ~trc~; 
dg.copy ~-- m~wl:opy; 
vidues( liewct)py.:t:hallged ) ; 

ELSE 	dg.copy ~ nil; ;;reset copy fiekl values{dg,uil): 


END; 
FUNCTION copy-node-conq)-forwarded{ dg); 
IF (dg.type : :g, tomic) THEN values(dg.:changed); 
;; return origiaM dg with 'changed' flag. 
ELSE IF (rig.type ~-:lmttom) THEN values(dg,:changed); 
ELSE 

IF (dg,comp-arc-li~t is uon-enipty AND dg,generMion : *unify-globM-counter*) THEN newcopy ,-create-node(): newcopy.tylm *-:coilifdex; 

newcopy.gencratio~l ~ *utdfy-global-counter*; 
dg.copy ~ newcopy: 
FOR ALL arc IN dg.arc-list DO 


Ilew&rc (- first value of capy-arc-and-coml)-arc-sharc(arc); pllslt new&re }taro newcopy.arcdist: FOR ALL c<>ml)-arc IN dg.comp-arc-list DO 
ilewar(: first value of copy-arc-and-(:Olllp-ar(:-sh are( colll ])-arc/; 
pudt newarc into l|eWcg)y.arc-list; 
dg.comp-arc-list ~ nil: 
vMm~s(newcopy,:dlanged ); 

ELSE 
stale + nil, arcs ~ tail; slle(:essful tllliticatiOllS to the total ltUlllbcr of Itllifica- tions. Wc parsed cach selltcncc three times on a Sym- I)oli(:s 3620 using three tin}float}on ntethods, namely, 
Wroblewski's algorithln, a qua,si-dcstrttctive lllethod without structure-sharing, and a qu,%i-destructive method with structure-shariug. Wc took tile short- est elapsed time for ea(:h metho<l ('W' represents Wroblewski's algorithnl with a modification to han-dle cycles and wtrialllcs 29, 'QD' represents the <luimi- destructive nletlmd without structure-sharing, slid 'QS' represents the prol)osed lnethod with structure- sharing). Data stru(:tures arc the same for all three 

dg.col)y ~ (Ig, dg.gcneration + *Ulfify-glol>al-counter*; unification methods ex(:el)t for additional fields for 
FOR ALL art: IN dg.arc-list DO 

imwarc,changed +: COl)y-arc-an( -comp-arc:s lare(arc); 
push newarc into arcs; 
IF (dmnged has value) THEN 
stat~ ~ cbal|ged; 
IF (state }tits value)THEN 
IF (rig.copy =fi dg) TItEN 

rig.copy.arc-list ~ arcs: 
dg.copy.type ~ :comt)lex; 
value,(dg.col~y.:changed); 


ELSE 
newcopy ~ create-node(); 
newcopy.type ~-- :complex; 

newcopy.gencration ~ *unify-gbJb~d-(:ounter*; 
newcopy.arc-list ~ a~cs; 
dg.copy ~ neweopy; 
v~dueA( newcopy.:cllangcd); 
ELSE dg,copy ~ nil; 
vahte~(dg,clmnged); ;; considered changed 



END; 

FUNCTION copy-arc-and-comp-arc-dkare(input -arc ); 
destination,cb~tnged 
Col)y-rig-wit h-coml)-~rcs-dtare(in put -,xr(:.value ); 
IF (changed has value I TItEN 
lal)d + inpubarc.label; 
value ~ destination; 
values(a new arc witb lalml and value,:cluulged); 
ELSE rabies(input-arc jail): ;; return original arc END; 
Figure 5: Structure-Sharing Copying Functions 


Experiments 
Table 1 shows the resltlts of our experiments us-ing all HPSG-11,~sed sample Japanese granmtar dc-vdoped at ATR br a conference registration tele-phone dialogue domain. 'Unifs' represents the to-tal ltulnl/er of top-level unifications during a parse (i.c, the munl)er of calls to the top-loyal "unify-dg', and not 'tinily1') 28. 'USratc' represents the ratio of 
24 Currently, all lIOdetl arc Col)ted ill a cych~ il~ order to prevent the split of the copy ~uld the original when node above all uladl~.ngcd original i8 modified. Tbanks are due to Makoto 'I'ak~d,a~i of TIS for suggesting the fix. Of c,urue, a better method, if possihle, would be 1o copy tim whole cycle only wheat at least one node in the cycle i~ modified, 
25'Values' retltrn nlllltil)le values ~rOlll ~t fllnCtioII. In our algoritlmt, two values are retunlcd. The first value is the result of copying, and the second value is ~t flag iMicatiag if tlmre wa~ any modificatiolt to the node or to ally of its desc(!n(lallt8. 
26Temporarily set copy of the dg 1o be itself, 27Multil)te-value-hind call. The first value is homld to 'newarc'. arid the second vahte is bt)und to 'dumged'. 28Unifyl in called several times the number (>f uttify-dg in the gtalnl|l&r ilSC(I ill the eXl)erilllCltt. For exanlpb! nnifyl wi~ 
)l II -ar -list ill tile Q-D lnethod8. 8anle fltllctil)ltS are llsed to interface with Eal'ley~s parser and tile SalIIC sul)fllllCtiOllS are used wherever possible (snch 
;as creation slid access of arcs) l, ll lnilthllize th(! dif- fcrem:eu that are not purely algorlthltfi<:. 'Nmnber of Copies' represents the numl)er of nodes created dur-illg each parse. 'Nlllllber of Arcs' rcprcsents the nlllll- ber of arcs created durillg each parse. 
We used Earley's parsing 'algorithnl for the exper- intent. The Japanese gralmnm' is based on tlPSG analysis ([Ponard and Sag, 1987]) eovering llhe-nomena such as coordination, case adjmlction, ad-junets, control, shLsh categories, zero-pronouns, in terrogativcs, WH constructs, and sonic pragmatics (speaker, hearer relations, politeness, etc.) ([Yoshi-moto and Kogm'e, 1989]}. The grammar covers many of the imllortant linguistic phenomena in conversa-tional Japaucse. The grammar graphs which are con- vertcd front the l)atll equations contaiu 2324 no(tcs, a° Wc used 16 Sclttenecs from a sanlplc telet/hone con-vcrs~tion dialog whi(:h range from very short sen-tenets (one word, i.e., tie 'no') to rdativdy hntg ones (such as soredehakochirakarasochiranitourokuyoush, i- woookuriitashimasu 'In that case, wc [speaker] will send you [hearer] the registration form.'). Thus, tltc number of (toll-level) unifications per senteltce wu'icd widdy (from 6 to over 500). 


5 Discussion: 
Pereira ([Percira, 1985]) attaills structure-sharing I)y having the rcsult graph share information with the origiw, d gr~tphs by storing charges to tile 'envirolt- merit'. There will be tlle log(d) overhead (where d is the nuM)er of nodes ill a graph) associated with Percira's ntetho<l that is rcqttircd during node access to ,~ssenfl>le the whole graph from the 'skeleton' and the updates ill thc 'environment'. Ill the proposed sdtcmc, since tim arcs dircetly lloint to the original graph structures there will be no overhead till" node accesses. Also, during unificatioli, siltce citaltges art! 
called 3299 times for sentence 9 when Itnify-dg was called 480 tillies. 
29 Kogure ([Kogur< 1989]) des(:ribe~ It trivial time modifica- tion to WrohlewRki's algorithm lo handle cycles which is used ill oltr experillleltts, 
3tlDisjunctive equation~ are l)reproceH~ed hy the grammar reader module to expand into cross-multiples, whereas il~ ATR% SL-TraNs syRtem. Kasl)er's method ([Kauper. 1987]) to handle disjunctive feature-strltctures ia adopted. 

sent# Unifs USrate Elapsod timo(nec) W QD QS 
1 6 0.50 o,2o o.15 0.13 2 101 0.34 2,53 1.16 1.10 3 18 0.22 0.40 0.20 0,20 4 71 0.55 2.20 1.24 0.91 5 305 0,37 13.78 6,51 3.65 6 59 0.27 3,20 0.64 0.50 7 6 0,50 0.21 0.13 0.11 8 81 0.51 3.17 1.59 1.21 9 480 0.37 24.62 8.11 5.74 10 555 0.41 40.15 16.39 8.80 ii 109 0.45 4.60 1.71 1.41 12 428 0.33 19.57 8.24 4.45 13 559 0.39 37.76 11.74 6.23 14 52 0.38 3.61 0.90 0.50 15 77 0.55 2.50 1.57 0.93 16 77 0.55 2.53 1.57 0.90 
total 2984 161.23 61.85 36.77 (Z for total) ioo~ 38.4~ 22.8~ 
~Sd)le 1: Comparison 

stored directly in the nodes (in the tluasi-destructivc maturer) thcrc will be no ovcrhead for rctlccting the changes to gral)hs during unitic;ttion. We share the l)rittciph~ of storing changes in a rcsU)rablc way with [Karttuncn, 1986]'s rcvtwsilfle unification and copy graphs only after a socccsshtl unification. However, Kal'ttllllCll~S nlcthod (lots llOt list! strllctllrc-sharilig. Also, }11 Kal'ttullcn's llltttll()t[ 31, whenever it destruc- tive chaage is about to bc made, tile attribute vahle pairs a2 stored in the body of the tlodc arc saved illto all array. The dag node structure itself is idso saved in another arrlty. These wtlucs arc restored after the top lcvcI unification is c(mq)leted. {A t:opy is madc prior to the rcstoratiou Ol)cration if the unification wlus +t successful one.) '['has, ill Karttuncn's lncthod, clmh node ixI the entire argulllcnt gral)h that hius been destructively modified must t)c restored SCl>aratcly by l'eXricviltg the attributc-values savcd ill an array and rcsctting th,! values into the (lag structure skele- tons sltvcd in another array. Ill the Q-D method. Olt(! illCl'ell/ellt to the global COlllltcr c.q.ll iav+didatc all tht'. changes made to tilt! no<tern [Karttunen slid Kay, 1985] suggests the use of lazy evaluation to de- lay dcstructive chalLges during unificatiou. [Goddcn, 1990} presents one method to delay copying until a de- structive change is al)out to take phtcc. Godden uses delayed closures to directly imphm|cnt lazy evalua- titm during unification. While it may be concel)tually straightforward to takc iulvantagc of delayc(I cVahla- tion functionalities ill progranuning laagtlages, actllal efficiency gain fl'on! such a schelnc may not bc signif- icant. This is l)et:aase such a schenle siml)ly shifts t4e time and space consmned for Col)ying to creating and evaluating closures (which couhl be very costly compared to 'dcfstruct" operations to create COl)ics 
31The discussion of Karltunen's lnethod is ba.e,l on the D PATR imphnuent;ttion on Xerox 1109 machines ([Karttunmt, 1986]). 
32I+e., arc stru(:turen: 'label" and 'vld[l(~' ])ilii'~ ill oUr w~cabulary. 
Num of Copies Num of Arcs 

w QD q3 W qD OS 107 79 18 113 123 36 2285 1317 407 2441 1917 760 220 111 26 182 183 62 2151 1564 514 2408 2191 879 9092 5224 1220 9373 7142 2272 997 549 97 874 797 204 107 79 18 113 123 36 2406 1699 401 2572 2334 710 15756 8986 1696 17358 12427 3394 18822 11234 2737 20323 15375 5116 2913 1938 555 3089 2712 992 13363 7491 1586 14321 10218 3059 17741 9417 2483 19014 13055 4471 947 693 107 893 983 199 2137 1513 428 2436 2185 793 2137 1513 428 2436 2185 793 91181 53407 12721 97946 73950 23776 100~ 58,6~ 14~ 100~ 76% 24~ 
of three methods 
which arc often effectively ()l)timized lit many tom ...... • cial ....... lfilcrs). [Kog,|l'C, 1990] anti [Eulelc. 19611 also use the lazy evaluation i(h',a to delay destruc- tive changes. Both Kogurc all(l Eme, h~ avoid direct usage of delayed evMuation by using pointer Oln:ra- tions. As b3mchr suggests, KogurCs method also re- quires a special dcl)endcncy inf(,rmation to bc mifin- tained which adds all overhead ahmg with the cost fin' traversing tile dCl)cudency arcs. Also, a secon(I travcrsa] of the set of dellelldellt liodes i8 required for actually pcrfl)rming the copying. Emele proposes a method of dcrcfercncing by adding enviromnent in- forlltatioli tllld, carries it scqtl(Hl(:t! of gCllCl'atioll COllll* tcrs so that a specific generation node (:all I)(~ fOlllld by traversing tim forwarding links until a node with that generation is found. While this allows undoing destructive changes cheaply by backtracking the en- virolllOCllt, every tinlc a spccilic graph is to bc at:- (:cssed the whoh! gt'aph ilcctls tO bc rccollstrll(:ted by following the fol'wardillg pointers ,~cqucntildly as speciticd in the environment list (cxt:et)~ for the root node) to find the node that shal'CS the smne genera- tion number as the root llOde. Therefore, similar to Pcrcira's mcthotl, there will be Nlog(d) ovcrhcad iLs- sociated with constructing t!ach graph every tinle & gral)h is accessed, where (1 is the llUillbCr of nodes ill the graph and N is the average depth of the tmviron- lllClttal dcfcrcncc chain, This would cause a probh!nl if the algtlrithm is adolltcd fin' a large-sclde systcm ill which result graphs arc unified agidnst other graphs many times. Like Wroblewski's method, "all three lazy methods (i.c, Godden's, Kogure's and Emele's) suf- fer fi'mn the t)roblenl of Early Copying ms defined in [Tonlabcchi, 1991]. This is because the copies that arc incrcnmntally created u 1, to tile point of failure during the same topAcvel unification arc wasted. The prob- lent is inherent ill increlnental copying scheme and this probhml is elinfil|ated completely in [Karttuncn, 
19861 and ill tile Q-D nmtltod. 3a 
There is one l/otential problent with the structure,- 
sharing idea whMt is shared by each of the schemes 
inchlding tile proposed tnethod. This ltallpens when 
operations other tllan ttnification modify the graphs. 
(This is typical whco a parser cuts off" a part of a 
graph for sltbsequellt analysisa4.) When such ol)-
erations are perfornmd, structure-sharing of t)ottolll 
(vlu'iablc) nodes stay cause probhmts when a sub-
graph cotttaitdog a 1)ottmn is shared by two different 
graphs and these graphs are used as argtllllelltS of a 
utfification function (either ~Ls the part of the same 
input graph or as ehmumts of dgl and dg2). When a 
gt'aplL that shares st bottl)lO (lode iN llOt Ilsed ill its en- 
tirety, then the, represented i:lmstraint postulated by 
the path leading to the bottotn no(h; is no longer the 
same, Therefl>re, when such a graph appears in the same unification aloog with soIoe other graph with which it DS shares the same bottotn node. there will 1)e a false FS-Sharing. (If the graph is used in its entirety this is not a problem since the two graph paths would unify anyway.) This problenl happens mdy when neither of the two graphs that DS-Sltares the same I)ottolll node wan ultified against SOille other graph before al)pearing in the santo unification, as {If either was once unified, h)rwardiug wouht have avoided this prol)lent). The methods to avoid such a problent can be 1) As long as these convergence of bottoln nodes are used h)r features that are not pressed up during i)arsing, the ln'oblems does not affect the result of parse in any way whMt scents the ca,se with the gr~mtmars at ATII azl(l CMU. 2) A parser call tie modified so that when it modifies a graph other than through graph unification a6, it et'eatcs copies of the arc stru(:tures containing the bottotn nodes. In the prolmsed tnethod this can be done by call-ing the copy function without structure-sharing lle-fl)re a parser ntodifics a grallh. 3) A parser can lie rood(tied so that it does not (:lit off parts of graphs and use the graphs in their entirety (this should not add emnplexity (mcc strttctttre-sharing is introduced to unification). Thus, althtmgh the space and time reductioo attained by structure-sharing (Jail t)e sig-nificant. DS-Shariag can cause l)roblems unless it is 
ttsed with a eautiott (by making sure variM)le sharing 
aaLazy methods delay eopyiug until a destructive chaalge is to be perforlne.d Do that unnecessary copies are not cre-ated within a lmrticular recurs(on into a unification function; howover, 8il|ce each shared arc recllrsion is indellendent (llOll-deterlllillistic). (!villi if there are 11o unltecesa&ry copies created at ,dl iu otte particular relalrsioll, if there is a failure in 8Ollllr other shared art: recurs(on (at some depth), then the copied that are created hy successful shared arc recurs(ass up to the point of detection of failure will beconm wasted, As long as the haste contr<fl structure retnltins incremental, this is inher- (!lit ia the increlllental |uethod. In otheI wolds, the problem is inhereut in these ilmremental methods by definition. 
34 For example, lnltny parse[.~ cut off a subgraph of the path 0 hJr applying further rules whmz it rule is accepted. 35Such cases lltay happen whell the 8allle rule (such as V V} augluented with a heavy use of convergence ill the bottonl nodes is applied malty times during a parse. 36Stlch as when a rule is accepted and suhgraph of O path is Cltt off. 
does not cause crroncous sharing by using these or 
some othm" methods). 


6 Conclusion 
The structure-sharing scltemc introduced ill this pa-per made the Q-D Mg(~ritlnn run significantly f~mter. The original gain of the Q-D algorit, hnt was due to the fact that it does not create ally Over Copies or Early Col>ies whereas iIIcrelllelltal (:opyillg sfllI~Ille inherently produces Early Copies (iLs defined in [Totnal)echi, 19911) when a unification fails. Tilt: pro- l)osed schenm lllakes the Q-D algotfflmi fully i~vl)i(1 lh~dundaltt Collies as well by only copying the low-est nodes that need to be eoI)ied due to destrtt(:tive chatlges caused by successful unifications only. Since there will bc virtually uo overhead associated with structure=sharlng (except far returning two vahl(!s ill- stead (If oDc' to pa.ss tip :chattge(l illforltlatioll wht!ll rt!- curs(oil for copying rcturos), the perfornlatlee of the prol)osed strnl:ture-sharing schellle should llOt drop eveii when the granmlar size is significantly scaled Ul). With the denttmstratcd speed of the algorithm. as well as the ability to handle cyclicity in the graphs. mid ease of switching betwemt strueture-sharittg attd non-structure sharing, the algorithm couhl lie a viable alternative to existing tttfifit:ation algorithnts used in current nature| language systems. 


References 
[Emele, 1991] Erode. M, "Unificatimt with Lazy Non-Redundant Copying'. In Proc. of A CL-91, 1991. 
[Godden. 1990] Godden, K. "Lazy Uuification" In Proc. of ACL-90. 1990. 
[Katitunen. 1986] Karttuuen. L. "D-PATR: A Deveh)pment EnyirOltlllellt for IJnifi(:a.til)it-13mued Gr0.llllllalrs". In Proc. of COLING-86, 1986. (Also, Report CSLI-86-61 Stanford Uni- versity). 
[Karttunen and Kay, 1985] Katttum)n. L. ~nd M. Kay. "8tnu- tnre Sharing with Binary Tr(~s". In Proc. of ACL-85. 1985. 
[Kasper, 1987] Kasper. R. "A Unifice.tion Method for Disjunc- tive Feature Descriptim~s". In Prec. of ACL-87, 1987. 
IKogute, 1989] Kogure, K. A Study oil Feature St1*l~cture.~ and Unificatim~. ATR TechuicM Report. TR-l-O032. 1988. 
[Kogure. 1990] Kogurc, K. "Strategic Lazy Incremental Copy Graph Unification". In Prom of COLING-go, 1990. 
[Marimoto. et el, 199(1I Morimoto, T.. H. Ilda, A. Kurem~tsu, 
K. 8hikano, and T. Aizawa. "Spoken Language Translation: 
Toward Realizing an Automatic Telepholu! Interprelation 

System". In P'roc. of l'nfoJapan 1990, 1990. 
[Pereira, 1985] Pereira, P. "A Slructure-Sharing Representa- tion for Unification-Based Grammar Formallsms". In Proc. of ACL-8& 1985. 
[Pollard ~nd Sag. 1987] Pollard, C. and L Sag. Infovmatio.--based Syntax and Semantics. Vol 1. CSLI, 1987. 
[Yoshimoto and Kogure, 1989] Yoshilnoto, K. and K. Kogure. 
Japanese Senfence Analy.~is by means of Phrase Strltctu.re 
Grammar: ATR Technical Report. TR-1-0949, 1989. 
[Tolnabechi, 1991] Tomahechi, H. "Quasi-Destructive Graph Unification". lit Proc. of ACL-91, 1991. 
[Wroblewski, 1987] Wrohlewski. D."Noudestructlve Graph Unification", In Proc. of AAAI87. 1987. 





