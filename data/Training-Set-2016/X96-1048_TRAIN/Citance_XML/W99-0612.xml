<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Identifying and classifying personal, geographic, institutional or other names in a text is an important task for numerous applications.</S>
		<S sid ="2" ssid = "2">This paper describes and evaluates a language-independent boot- strapping algorithm based on iterative learning and re-estimation of contextual and mOrphological patterns captured in hierarchically smoothed trie models.</S>
		<S sid ="3" ssid = "3">The algorithm learns from unannotated text and achieves competitive performance when trained on a very short labelled name list with no other required language-specific information, tokenizers or tools.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="4" ssid = "4">The ability to determine the named entities in a text has been established as an important task for several natural language processing areas, including information retrieval, machine translation, information extraction and language understanding.</S>
			<S sid ="5" ssid = "5">For the 1995 Message Understanding Conference (MUC6), a separate named entity recognition task was developed and the best systems achieved impressive accuracy (with an F-measure approaching 95%).</S>
			<S sid ="6" ssid = "6">What should be underlined here is that these systems were trained for a specific domain and a particular langnage (English), typically making use of hand-coded rules, taggers, parsers and semantic lexicons.</S>
			<S sid ="7" ssid = "7">Indeed, most named entity recognizers that have been published either use tagged text, perform syntactical and morphological analysis or use semantic information for contextual clues.</S>
			<S sid ="8" ssid = "8">Even the systems that do not make use of extensive knowledge about a particular language, such as Nominator (Choi et al., 1997), still typically use large data files containing lists of names, exceptions, personal and organizational identifiers..</S>
			<S sid ="9" ssid = "9">Our aim has been to build a maximally langnage- independent system for both named-entity identification and classification, using minimal information about the source language.</S>
			<S sid ="10" ssid = "10">The applicability of AI-style algorithms and supervised methods is limited in the multilingual case because of the cost of knowledge databases and manually annotated corpora.</S>
			<S sid ="11" ssid = "11">Therefore, a much more suitable approach is to consider an EM-style bootstrapping algorithm.</S>
			<S sid ="12" ssid = "12">In terms of world knowledge, the simplest and most relevant resource for this task is a database of known names.</S>
			<S sid ="13" ssid = "13">For each entity class to be recognized and tagged, it is assumed that the user can provide a short list (order of one hundred) of unambiguous examples (seeds).</S>
			<S sid ="14" ssid = "14">Of course the more examples provided, the better the results, but what we try to prove is that even with minimal knowledge good results can be achieved.</S>
			<S sid ="15" ssid = "15">Additionally some basic particularities of the language should be known: capitalization (if it exists and is relevant -some languages do not make use of capitalization; in others, such as German, the capitalization is not of great help), allowable word separators (if they exist), and a few frequent exceptions (like the pronoun &quot;/&quot; in English).</S>
			<S sid ="16" ssid = "16">Although such information can be utilised if present, it is not required, and no other assumptions are made in the general model.</S>
			<S sid ="17" ssid = "17">1.1 Word-Internal and Contextual Information.</S>
			<S sid ="18" ssid = "18">The algorithm relies on both word internal and contextual clues as relatively independent evidence sources that drive the bootstrapping algorithm.</S>
			<S sid ="19" ssid = "19">The first category refers to the morphological structure of the word and makes use of the paradigm that for certain classes of entities some prefixes and suffixes are good indicators.</S>
			<S sid ="20" ssid = "20">For example, knowing that &quot;Maria&quot;, &quot;Marinela&quot; and &quot;Maricica&quot; are feminine first names in Romanian, the same classification may be a good guess for &quot;Mariana&quot;, based on common prefix.</S>
			<S sid ="21" ssid = "21">Suffixes are typically even more informative, for example &quot;-escu&quot; is an almost perfect indicator of a last name in Romanian, the same applies to &quot;-wski&quot; in Polish, &quot;-ovic&quot; and &quot;-ivic&quot; in SerboCroatian, &quot;-son&quot; in English etc. Such morphological information is automatically learned during boot- strapping.</S>
			<S sid ="22" ssid = "22">Contextual patterns (e.g. &quot;Mr.&quot;, &quot;in&quot; and &quot;mayor of&quot; in left context) are also clearly crucial to named entity identification and classification, especially for names that do not follow a typical morphological pattern for their word class, are of foreign origin or polysemous (for example, many places or institutions are named after persons, such as &quot;Washington&quot; or &quot;Madison&quot;, or, in some cases, vice-versa: &quot;Ion Popescu Topolog&quot; is the name of a Romanian writer, who added to his name the name of the river &quot;Topolog&quot;).</S>
			<S sid ="23" ssid = "23">Clearly, in many: cases, the context for only one occurrence of a new word and its morphological information is not enough to make a decision.</S>
			<S sid ="24" ssid = "24">But, as noted in Katz (1996), a newly introduced entity will be repeated, &quot;if not for breaking the monotonous effect of pronoun use~ then for emphasis and clarity&quot;.</S>
			<S sid ="25" ssid = "25">Moreover, he claims that the number of instances of the new entity is not associated with the document length but with the importance of the entity with regard to the subject/discourse.</S>
			<S sid ="26" ssid = "26">We will use this property in conjunction with the one sense per discourse tendency noted by Gale, Church and Yarowsky (1992b), who showed that words strongly tend to exhibit only one sense in a document/discourse.</S>
			<S sid ="27" ssid = "27">By gathering contextual information about the entity from each of its occurrences in the text and using morphological clues as well, we expect to classify entities more effectively than if they are considered in isolation, especially those that are very important with regard to the&apos; subject.</S>
			<S sid ="28" ssid = "28">When analyzing large texts, a segmentation phase should be considered, so that all the instances of a name in a segment have a high probability of belonging to the same class, and thus the contextual information for all instances within a segment c&apos;an be used jointly when making a decision.</S>
			<S sid ="29" ssid = "29">Since the precision of the segmentation is not critical, a language independent segmentation system like the one presented by Amithay, Richmond and Smith (1997) is adequately reliable for this task.</S>
			<S sid ="30" ssid = "30">1.2 Tokenized Text vs. Plain Text There are two basic alternatives for handling a text.</S>
			<S sid ="31" ssid = "31">The first one is to tokenize it and classify the individual tokens or group of tokens.</S>
			<S sid ="32" ssid = "32">This alternative works for languages that use word separators (such as spaces or punctuation), where a relatively simple set of separator patterns can adequately tokenize the text.</S>
			<S sid ="33" ssid = "33">The second alternative is to classify entities simply with respect to a given starting and ending character position, without knowing the word boundaries, but just the probability (that can be learned automatically) of a boundary given the neighboring contexts.</S>
			<S sid ="34" ssid = "34">This second alternative works for languages like Chinese, where no separators between the words are typically used.</S>
			<S sid ="35" ssid = "35">Since for the first class of languages we can define a priori probabilities for boundaries that will match the actual separators, this second approach represents a generalization of the one using tokenized text.</S>
			<S sid ="36" ssid = "36">However, the first method, in which the text is tokenized, presents!</S>
			<S sid ="37" ssid = "37">the advantage that statistics for.</S>
			<S sid ="38" ssid = "38">both tokens and types can be kept and, as the results show, the statistics for types seem to be more reliable than those for tokens.</S>
			<S sid ="39" ssid = "39">Using the second method, there is no single definition of &quot;type&quot;, given that there are multiple possible boundaries for each token instance, but there are ways to gather statistics, such as considering what we may call &quot;probable types&quot; according to the boundary probabilities or keeping statistics on sistrings (semi-infinite strings).</S>
			<S sid ="40" ssid = "40">Some other advantages and disadvantages of the two methods will be discussed below.</S>
			<S sid ="41" ssid = "41">2 The Basic Model Before describing the algorithm, we will present a brief overview of some of its goals:.</S>
			<S sid ="42" ssid = "42">• a language independent core model • the ability to exploit basic language-specific features • the ability to learn from small named entity lists (on the order of 100 total training names) • the capability to handle both large and small texts • good class-scalability properties (the possibility of defining as many named entity types as desired, so that for different languages or different purposes the user can choose different classes of words to be recognized) • the capability to store the information learned from each instance for further use Three important concepts are used in our model: 2.1 &apos;rrie structures are used for both morphological and contextual information Tries provide an effective, efficient and flexible data structure for storing both contextual and morphological patterns and statistics.</S>
			<S sid ="43" ssid = "43">First, they are very compact representations.</S>
			<S sid ="44" ssid = "44">Second, they support a natural hierarchical smoothing procedure for distributional class statistics.</S>
			<S sid ="45" ssid = "45">We consider character- based tries, in which each node contains a probability distribution (when working with tokenized text, two distributions are considered in each node, one for tokens and one for types).</S>
			<S sid ="46" ssid = "46">The distribution stored at each node contain the probability of each name class given the history ending at that node.</S>
			<S sid ="47" ssid = "47">Each distribution also has two standard classes, named &quot;questionable&quot; (unassigned probability mass in terms of entity classes, to be motivated below) and &quot;nonentity&apos;.</S>
			<S sid ="48" ssid = "48">To simplify the notations, we will refer to a start and end point bounded portion of text being analyzed (in order to determine if it represents a named entity or not) as a token.</S>
			<S sid ="49" ssid = "49">Two tries are used for context (left and right) and two for internal morphological patterns of tokens.</S>
			<S sid ="50" ssid = "50">Figure i shows an example of a morphological prefix trie, which stores the characters of tokens from root ) ters lll2...ln, (i.e. the path in the trie is root -ll -12 - ...</S>
			<S sid ="51" ssid = "51">-In) the general smoothing model is: a c n # ! n r o i I I I I I e d e u c I I I I x # a # p e ! # e I # information stored in a node: character(&quot;#&quot;) raw distribution: quest I nonentity I person I place I inst list of (right) context links are#a#nice# [ Figure 1: Morphological prefix trie for &quot;Alex and Anda are a nice couple&quot; left to right from given starting points (with optional word boundaries indicated by &quot;#&quot;).</S>
			<S sid ="52" ssid = "52">Suffix tries (typically more informative) have equivalent structure but reversed direction.</S>
			<S sid ="53" ssid = "53">The left and right context tries have the same structure as well, but the list of links refers now to the tokens which have the particular context represented by the path from the root to the current node.</S>
			<S sid ="54" ssid = "54">For right context, the letters are introduced in the trie in normal order, for left context they are considered in the reversed order (in our example, &quot;Anda&quot; has as left context &quot;dna#xela#&quot;).</S>
			<S sid ="55" ssid = "55">Similarly, nodes of the context tries contain links to the tokens that occurred in the particular contexts defined by the paths.</S>
			<S sid ="56" ssid = "56">Two bipartite graph structures are created in this way by these links.</S>
			<S sid ="57" ssid = "57">For reasons that will be explained later, raw counts are kept for the distributions.</S>
			<S sid ="58" ssid = "58">The probability of a token/context as being in or indicating a class is computed along the whole path from the root to the terminal node of the token/context.</S>
			<S sid ="59" ssid = "59">In this way, effective smoothing is realized for rare tokens or contexts.</S>
			<S sid ="60" ssid = "60">Considering a token/context formed from charac- n P(class~ltll2...In ) = ~ A~P(class3111t2...li), i=1 n whereas E [O, 1]and ~Ai=l i=1 It is reasonable to expect that smaller lambdas should correspond to smaller indices, or even that A1 _&lt; A2 _&lt; ...</S>
			<S sid ="61" ssid = "61">_&lt; An.</S>
			<S sid ="62" ssid = "62">In order to keep the number of parameters low, we used the following model: F(class~llal2...ln) = ~F(class~llx ) n + ~ °tn-iF(cclassj[lll2&quot;&quot;li) i=2 where a, ~ E (0, 1), ~ having a small value The symbol F is used instead of P since we have raw distributions (frequencies) and a normalization step is needed to compute the final probability distribution.</S>
			<S sid ="63" ssid = "63">A simpler model can use just one parameter (setting g = an), but this has limited flexibility in optimizing the hierarchical inheritance -the probability of a class given the first letter is often not very informative for some languages (such as English or Romanian) or, by contrast, may be extremely important for others (e.g. Japanese).</S>
			<SUBSECTION>2.2 EM-style bootstrapping The basic concept of this bootstrapping procedure is to iteratively leverage relatively independent sources of information.</SUBSECTION>
			<S sid ="64" ssid = "64">Beginning with some seed names for each class, the algorithm learns contextual patterns that are indicative for those classes and then iteratively learns new class members and word-internal morphological clues.</S>
			<S sid ="65" ssid = "65">Through this cycle, probability distributions for class given token, prefix/suffix.</S>
			<S sid ="66" ssid = "66">or context are incrementally refined.</S>
			<S sid ="67" ssid = "67">More details are given when describing stage 2 of the algorithm.</S>
			<SUBSECTION>2.3 Unassigned probability mass as opposed to the classical maximum entropy principle.</SUBSECTION>
			<S sid ="68" ssid = "68">When faced with a highly skewed observed class distribution for which there is little confidence due to small sample size, a typical response to this uncertainty in statistical machine learning systems is to backoff or smooth to the more general class distribution, which is typically more uniform.</S>
			<S sid ="69" ssid = "69">Unfortunately, this representation is difficult to distinguish from a conditional distribution based on a very large sample (and hence estimated with confidence) that just happens to have a similar fairly uniform true distribution.</S>
			<S sid ="70" ssid = "70">One would like a representation that does not obscure this distinction, and represents the uncertainty of the distribution separately.</S>
			<S sid ="71" ssid = "71">We resolve this lproblem while retaining a single probability distribution over classes by adding a separate &quot;questi0nable&quot; (or unassigned) cell that reflects the uncertainty of the distribution.</S>
			<S sid ="72" ssid = "72">Probability mass continues to be distributed among the remaining class cells proportional to the observed distribution in the :data, but with a total sum (&lt; 1) that reflects the confidence in the distribution and is equal to 1 - P(q&apos;uestionable).</S>
			<S sid ="73" ssid = "73">This approach has the advantage of explicitly representing the uncertainty in a given class distribution, facilitating the further development of an interactive system, while retaining a single probability distribution that simplifies trie architecture and model combinatiofi.</S>
			<S sid ="74" ssid = "74">Incremental learning essentially becomes the process of gradually shifting probability mass from questionable/uncertain to one of the primary categories.</S>
			<S sid ="75" ssid = "75">3 The Algorithm.</S>
			<S sid ="76" ssid = "76">The algorithm can!</S>
			<S sid ="77" ssid = "77">be divided into five stages, which are summarized below.</S>
			<S sid ="78" ssid = "78">Stage 0: build the initial training list of class representatives Stage 1: read the text and build the left and right morphological and context tries Stage 2: introduce the training information in the tries and re-estimate the distributions by boot- strapping Stage 3: identify and classify the named entities in the text using competing classifiers Stage 4: update the entity and context training space, using the new extracted information Stage O: This stage is performed once for each langnage/task and cbnsists of defining the classes and filling in the initial class seed data with examples provided by the user.</S>
			<S sid ="79" ssid = "79">The list of class training names should be as unambiguous as possible and (ideally) also relatively common.</S>
			<S sid ="80" ssid = "80">It is also necessary to have a relatively large unannotated text for bootstrapping the contextual models and classifying new named entities.</S>
			<S sid ="81" ssid = "81">Examples Of such training seeds and text for Romanian language are given in Tables 1 and 21 . For the primary experiments reported in this paper, we have studied a relatively difficult 3-way named entity partition between:First (given) names, Last (family) names and Place &apos;names.</S>
			<S sid ="82" ssid = "82">The first two tend to be relatively hard to distinguish in most languages.</S>
			<S sid ="83" ssid = "83">A 1The text refers %0 the mayor of a small town of Alba county, who was so drunk while officiating at a wedding that he shook the bride&apos;s hand and kissed the groom.</S>
			<S sid ="84" ssid = "84">simpler person/place-based distinction more comparable to the MUC6 EMAMEX task is evaluated in Table 3(d).</S>
			<S sid ="85" ssid = "85">Training Data (seed wordlists): F.NAME L.NAME PLACE Andrei Iliescu Abrud Adam Popescu AlbaIulia Alexandru Ionescu Arad Aurel Nitu Bac~u Bogdan T~nase Botosani Cosmin Tudose Bucuresti Constantin Rotariu Brasov C~t~lin Ciurea Br~ila Costin Bucur Buz~u Claudiu Gherman Calafat Table h Sample training wordlists for Romanian Target Evaluation Text (labels not used for training) Primarul comunei &lt;place&gt; Rosia Montane &lt;/place&gt; judetul &lt;place&gt; Alba &lt;/place&gt; &lt;fname&gt; David &lt;/fname&gt; &lt;iname&gt; Botar &lt;/iname&gt; a intrat in legend~ datori%~ unor intimpl~ri de-a dreptul penibile, relatate in &quot;Evenimentul zilei&quot;.</S>
			<S sid ="86" ssid = "86">Practic, primul gospodar al celei mai bogate comune in aur din &lt;place&gt; Muntii Apuseni &lt;/place&gt; este mai tot timpul beat-crit~, drept pentru care, la oficierea unei c~s~torii, a s~rutat mina mirelui, a strins mina miresei si a intocmit certificat de deces in locul celui de c~s~torie.</S>
			<S sid ="87" ssid = "87">Recent, &lt;fname&gt; Andrei &lt;/fname&gt; &lt;iname&gt; P~tunescu &lt;/iname&gt; fiul poetului, a intentionat s~ achizitioneze gospod~ria unei bucurestence care se stabilise de o vreme in &lt;place&gt; Rosia MontanK &lt;/place&gt; La prim~trie ~ns~, turmentatul primar 1-a trimis pe fiul lui &lt;fname&gt; Adrian &lt;/fname&gt; &lt;iname&gt; P~unescu &lt;/iname&gt; s~-i cumpere ceva de b~ut, pentru a se putea concentra ~ndeajuns asupra hirtiilor tranzactiei imobiliare.</S>
			<S sid ="88" ssid = "88">&lt;fname&gt; LUCIAN &lt;/fname&gt; &lt;iname&gt; DOBRATER &lt;/iname&gt; Table 2: Sample test data for Romanian Stage 1: There are two ways to start this stage, either by tokenizing the text or considering it in raw form.</S>
			<S sid ="89" ssid = "89">When tokenization is used, each token is inserted in the two morphological tries: one that keeps the letters of the tokens in the normal (prefix) order, another that keeps the letter in the reverse (suffix) order.</S>
			<S sid ="90" ssid = "90">For each letter on the path, the raw distributions are changed by adding the a priori probability Probabilitydistributionorder: node non-n a m e ~ ~ I N 10.1,110.3810.2710.=1 0.2 I I u 10.07110.2210.5510.1210.04 [ [ A 10.07110.0410.6310.2210.04 I I c 10.051102110.7010.031 0 I [i Io.1511o.o31o.271o.551 o I I s Io.olll 0 10.99] 0 I 0 I IEloll 0 I a I0101 •z~,~°&quot;311°°&apos;l°sTI ° I ° I I L Io.,11 0 I 0 Io.s7[ 0 ] (&quot;-escu&quot; subtree) I E 10.99110;011 0 I 0 I 0 I I U Io.1311 0 I 0 10.87I 0 I I T10.99110.011 o l 0101 If 10.1311 0 I 0 [o.a71 0 [ (&quot;iulian&quot; subtree) I s 10.99110.011 0 I 0 I 0 I (&quot;sterian&quot; subtree) Figure 2: An example of normalized but unsmoothed distributions from the suffix morphological trie for Romanian.</S>
			<S sid ="91" ssid = "91">The paths shown are for Iulian, a &quot;first name&quot; entity, contained in the training word list; Ster/an a &quot;last name&quot;, not in the training data; and a partial path for the tokens ending in -escu.</S>
			<S sid ="92" ssid = "92">of the token belonging to each class (language dependent information may be used here).</S>
			<S sid ="93" ssid = "93">For example, in the case of IndoEuropean languages, if the token starts with an uppercase letter, we add 1 full count (all probability mass) to the &quot;questionable&quot; sum, as this entity is initially fully ambiguous.</S>
			<S sid ="94" ssid = "94">If the token starts with lowercase (and hence is an unlikely name) in this case we add the bulk of the probability mass 6 (e.g.6 t&gt; 0.9) to &quot;nonentity&quot; and the remainder (15) to &quot;questionable&quot; (otherwise unassigned).</S>
			<S sid ="95" ssid = "95">Other language-specific orthographic clues could potentially affect this initial probability mass assignment.</S>
			<S sid ="96" ssid = "96">When no tokenization is applied, we have to consider possible starting and ending points.</S>
			<S sid ="97" ssid = "97">Therefore, the strings (which, for simplicity, we will refer as well as tokens) introduced in the prefix morphological trie and the ones introduced in the suffix trie may differ.</S>
			<S sid ="98" ssid = "98">The left context of each token is introduced, letters in reverse order, in the left context trie, with pointers to the token in the morphlogical prefix trie; the right context of each token is introduced, in normal order, in the right context trie, keeping pointers to the token in the suffix trie.</S>
			<S sid ="99" ssid = "99">The distributions along the paths are modified according to the a pr/- ori distribution of the targeted token.</S>
			<S sid ="100" ssid = "100">Stage 2: This stage is the core bootstrapping phase of the algorithm.</S>
			<S sid ="101" ssid = "101">In essence, as contextual models become better estimated, they identify additional named entities with increasing confidence, allowing reestimation and improvement of the internal morphological models.</S>
			<S sid ="102" ssid = "102">The additional training data that this yields allows the contextual models to be augmented and reestimated, and the cycle continues until convergence.</S>
			<S sid ="103" ssid = "103">One approach to this bootstrapping process is to use a standard continuous EM (Expectation- Maximization) family of algorithms (Baum, 1972; Dempster et al., 1977).</S>
			<S sid ="104" ssid = "104">The proposed approach outlined below is a discrete variant that is much less computationally intensive, and has the advantage of distinguishing between unknown probability distributions and those which are simply evenly distributed.</S>
			<S sid ="105" ssid = "105">The approach is conservative in that it only utilizes the class estimations for newly classified data in the retraining process if the class probability passes a confidence threshold, as defined below.</S>
			<S sid ="106" ssid = "106">The concept of confidence threshold can be captured through the following definitions of dominant and semi-dominant.</S>
			<S sid ="107" ssid = "107">Let us consider a discrete finite probability distribution P = (Pl, ...,Pn).</S>
			<S sid ="108" ssid = "108">We say that P has a dominant if there is an i in {1...n} such that pi &gt; 0.5, or in other words if n ~Pj &lt;Pi-j=l 94 We say that P has an a-semi-dominant with respect to an event k, where a &gt; 1, if it does not have k as dominant and there exist i in {1...n} such that n j:l jCk A few commentsi about these definitions are necessary: it can be .easily observed that not every distribution has a dominant, even though it has a maximum value.</S>
			<S sid ="109" ssid = "109">The second definition, of a-semi- dominant, makes sense if we consider a particular event k that is not relevant (or the result cannot be measured).</S>
			<S sid ="110" ssid = "110">By rembving this event and normalizing the rest of the values, we obtain a new distribution (of size n-l) having i an a-dominant.</S>
			<S sid ="111" ssid = "111">The core of stage 2 is the bootstrapping procedure.</S>
			<S sid ="112" ssid = "112">The known names (either from the original training list or otherwise learned data) are inserted sequentially into the morphological tries, modifying the probability distributions of the nodes on the paths accordingly (the data structure is illustrated in Figures 1 and 2) . If the new distribution in one of the nodes on the path of a known token gains a dominant (for example &quot;placer&apos;) then the effect of this change is propagated by reestimating other node distributions given this change.</S>
			<S sid ="113" ssid = "113">Each distribution on the context paths in which that token occurred in the text is modified, by subtracting from the &quot;questionable&quot; mass a quantity proportional to the number of times the respective token was found in that context and adding it to the dominant-position (e.g. &quot;place&quot;) mass. For the newly obtained distributions that gained a dominant :(in our example &quot;place&quot;) in the context trie, the bootstrapping procedure is called for all tokens that Occurred in that context, and so on, recursively.</S>
			<S sid ="114" ssid = "114">Here it is very important that we consider raw distributions and not normalize them.</S>
			<S sid ="115" ssid = "115">For example, if word &quot;Mariana&quot; occurs x times with the right context &quot;merge&quot; (meaning &quot;goes&quot;) and the distribution for &quot;rhariana#&quot; has now been identified with the dominant &quot;first name&quot;, then x units from the &quot;questionable&quot; mass can be moved to &quot;first name&quot; mass along the path of &quot;merge#&quot; in the right context trie.</S>
			<S sid ="116" ssid = "116">If semi-dominants are used instead of dominants then we have to account for the fact that the semi-dominants may change over time, so the probability mass must be moved either from &quot;questionable&quot; position Or previous semi-dominant position, if a semi-dominant state has been reached before.</S>
			<S sid ="117" ssid = "117">It may be easily observed that stage 2 has a sequential characteristic, because the updating is done after reading each name incrementally.</S>
			<S sid ="118" ssid = "118">When using dominants the Order does not affect the process, because of the face that once a dominant state is reached, it cannot change to another dominant state in the future (probability mass is moved only from &quot;questionable&quot;).</S>
			<S sid ="119" ssid = "119">In the case of semi-dominants, the data ordering in the training file does influence the learning procedure.</S>
			<S sid ="120" ssid = "120">The more conservative strategy of using dominants rather then semi-dominants has, on the other hand, the disadvantage of cancelling or postponing the utilisation of many words.</S>
			<S sid ="121" ssid = "121">For example, if both &quot;questionable&quot; and &quot;first name&quot; have 49% of the mass then subsequent reestimation iterations are not initiated for this data, even though the alternative name classes are very unlikely.</S>
			<S sid ="122" ssid = "122">Considering those advantages and disadvantages, we used the less conservative semi-dominant approach as the default model.</S>
			<S sid ="123" ssid = "123">Stage 3: In this stage the text is re-analysed sequentially, and for each token (given a start-end point pair) a decision is made.</S>
			<S sid ="124" ssid = "124">Here the bipartite structure of the two pairs of tries has a central role: during stage 2, the left context and prefix tries interact with each other and so do the right context and suffix tries, but there&apos;s no interference between the two pairs during the bootstrapping stage.</S>
			<S sid ="125" ssid = "125">Therefore, for each instance of a token in the text, four classifiers are available, a different one given by each trie.</S>
			<S sid ="126" ssid = "126">The decision with regard to the presence of an entity and its classification is made by combining them.</S>
			<S sid ="127" ssid = "127">Comparative trials indicate that higher performance is achieved by initially having the clas- sifters vote.</S>
			<S sid ="128" ssid = "128">Results indicate that the most accurate classifications are obtained from the two independently bootstrapped morphological tries (they incorporate the morphological information about the token to be classified, and, during the bootstrapping, they also incorporate information from all the contexts in which the token occurred).</S>
			<S sid ="129" ssid = "129">If the two agree (they have semi-dominants and they are the same) then the corresponding class is returned.</S>
			<S sid ="130" ssid = "130">Otherwise, agreement is tested between other paired independent classifiers (in order of empirically measured reliability).</S>
			<S sid ="131" ssid = "131">If no agreement is found, then a simple linear combination of all four is considered for the decision.</S>
			<S sid ="132" ssid = "132">This approach yields 6% higher F-measure than the simple interpolation of classifiers for the default parameters.</S>
			<S sid ="133" ssid = "133">Stage ~ : The newly classified tokens and contexts are saved for future use as potential seed data in subsequent named-entity classification on new texts.</S>
			<S sid ="134" ssid = "134">4 Results.</S>
			<S sid ="135" ssid = "135">The basic measures for evaluation of this work are precision and recall.</S>
			<S sid ="136" ssid = "136">Precision (P) represents the percentage of the entities that the system recognized which are actually correct.</S>
			<S sid ="137" ssid = "137">Recall (R) represents the percentage of the correct named entities in the text that the system identified.</S>
			<S sid ="138" ssid = "138">Both measures are incorporated in the F-measure, F = 2PR/(P + R).</S>
			<S sid ="139" ssid = "139">It would be inappropriate to compare the results of a language independent system with the ones designed for only one language.</S>
			<S sid ="140" ssid = "140">As Day and Palmer (1997) observed, &quot;the fact that existing systems perform extremely well on mixed-case English newswire corpora is certainly related to the years of research and organized evaluations on this specific task in this language.</S>
			<S sid ="141" ssid = "141">It is not clear what resources are required to adapt systems to new languages.&quot;</S>
			<S sid ="142" ssid = "142">It is important to mention that the F-measure for the human performance on this task is about 96%, (Sundheim 1995).</S>
			<S sid ="143" ssid = "143">Our experiments on Romanian text were consistent with this figure.</S>
			<S sid ="144" ssid = "144">4.1 Baseline measures.</S>
			<S sid ="145" ssid = "145">In order to obtain a baseline performance for this method we considered the performance of a system that tags only the examples found in one of the the original training wordlists.</S>
			<S sid ="146" ssid = "146">We consider this to be a plausible lower bound measure if the training words have not been selected from the test text.</S>
			<S sid ="147" ssid = "147">Day and Palmer (1997) showed that a baseline F- measure score for the ENAMEX task varies from 21.2% for English to 73.2% for Chinese.</S>
			<S sid ="148" ssid = "148">It is important to mention that, when they computed these figures, they trained their language independent system on large annotated corpora (e.g. the Wall Street Journal for English).</S>
			<S sid ="149" ssid = "149">The fact that the precision obtained by the baseline approach is not 100% indicates that the seed training names for each class are not completely unambiguous, and that a certain degree of ambiguity is generally unavoidable (in this case, mainly because of the interference between first names and last names).</S>
			<S sid ="150" ssid = "150">Another significant performance measure is forced classification accuracy, where the entities have been previously identified in the text and the only task is selecting their name class.</S>
			<S sid ="151" ssid = "151">To obtain baseline performance for this measure, we considered a System that uses the original training word labels if there is an exact match, with all other entities labeled with a default &quot;last name&quot; tag, the most common class in all languages studied.</S>
			<S sid ="152" ssid = "152">The baseline accuracy was measured at 61.18% for Romanian.</S>
			<S sid ="153" ssid = "153">System accuracies range from 77.12% to 91.76% on this same data.</S>
			<S sid ="154" ssid = "154">4.2 Evaluation of basic estimation methods.</S>
			<S sid ="155" ssid = "155">The results shown in Table 3 were obtained for a Romanian text having 12320 words, from which 438 were entities, using a training seed set of 300 names (115 first names, 125 last names, and 60 city/country names).</S>
			<S sid ="156" ssid = "156">The baseline measures and default system (a) are as described above.</S>
			<S sid ="157" ssid = "157">In configuration (b), the based parameters of the system have been optimized for Romanian, using greedy search on an independent development test (devtest) set, yielding a slight increase in F-measure.</S>
			<S sid ="158" ssid = "158">Configuration (c) used the default parameters, but the more conservative &quot;dominant&quot; criterion was utilized, clearly favoring precision at the expense of recall.</S>
			<S sid ="159" ssid = "159">Configuration (d), which is relevant for the ENAMEX task, represents the performance of the system when classes &quot;first name&quot; and &quot;last name&quot; are combined into &quot;person&quot; (whenever two or more such entities are adjacent, we consider the whole group as a &quot;person&quot; entity).</S>
			<S sid ="160" ssid = "160">Configuration (e) shows contrastive performance when using standard continuous EM smoothing on the same data and data structures.</S>
			<S sid ="161" ssid = "161">4.3 Evaluation by language and knowledge.</S>
			<S sid ="162" ssid = "162">source Table 4 shows system performance for 5 fairly diverse languages: Romanian, English, Greek, Turkish and Hindi.</S>
			<S sid ="163" ssid = "163">The initial 4 rows provide some basic details on the training data available for each language.</S>
			<S sid ="164" ssid = "164">Note that when annotators were generating the lists of 150300 seed words, they had access to a development test from which to extract samples, but they were not constrained to this text and could add additional ones from memory.</S>
			<S sid ="165" ssid = "165">Furthermore, it was quite unpredictable how many contexts would actually be found for a given word in the development texts, as some appeared several times and many did not appear at all.</S>
			<S sid ="166" ssid = "166">Thus the total number of contextual matches for the seed words was quite variable, from 113249, and difficult to control.</S>
			<S sid ="167" ssid = "167">It is also the case that not all additional contexts bring comparable new benefit, as many secondary instances of the same word in a given related document collection tend to have similar or identical surrounding contexts to the first instance (e.g. &quot;Mayor of XXX&quot; or &quot;XXX said&quot;), so in general it is quite difficult to control the actual training information content just by the number of raw seed word types that are annotated.</S>
			<S sid ="168" ssid = "168">For each of these languages, 5 levels of information sources are evaluated.</S>
			<S sid ="169" ssid = "169">The baseline case is as previously described for Table 3.</S>
			<S sid ="170" ssid = "170">The context-only case restricts system training to the two (left and right) contextual tries, ignoring the prefix/suffix morphological information.</S>
			<S sid ="171" ssid = "171">The morphology only case, in contrast, restricts the system to only the two (prefix and suffix) morphological models.</S>
			<S sid ="172" ssid = "172">These can be estimated from the 3 training wordlists (150300 words total), but without an independent source of information (e.g. context) via which bootstrapping can iterate, there is no available path by which these Romanian Precision Recall F-measure Accuracy Baseline: 98.67 34.02 50.58 61.18 System Performance using: (a) default settings (using semi-dominants) 76.95 64.99 70.47 78.49 (b) re-estimated smoothing parameters 80.17 62.93 70.51 78.93 (c) learning wi~h dominants 91.06 51.38 65.69 78.26 (d) ENAMEX~like &quot;Person&quot; / &quot;Place&quot; classes 82.38 69.57 75.43 91.76 (e) continuous:EM approach 74.02 60.64 66.67 77.12 Table 3: Comparison of the performance of basic estimation methods on Romaninan Language ! [ Romanian English Greek Turkish Hindi Training text siz~ 12320 15738 10445 5207 18806 Total training seed words 300 190 210 150 150 Contextual matches for seeds 149 205 113 133 249 Labeled entities for testing 438 204 210 203 303 Baseline: 98.67 ] 34.01 83.33 [ 12.25 100 [ 18.09 86.66 [ 19.21 94.42 ] 20.26 (Precision/Recal i//F-measure) 50.58 21.36 30.64 31.45 33.23 Context Only: 96.59 [ 19.45 82.35 I 6.86 87.50 I 3.33 53.331 11.82 84.21 [ 9.58 (Precision/Recal]//F-measure) 32.38 12.67 6.42 19.35 17.20 Morphology Only: 73.79 [ 52.97 84.42 [ 31.86 78.35 I 36.19 75.32 ] 28.57 89.01 I 24.25 (Precision/Recall//F-measure) 61.67 46.26 49.51 41.43 38.12 Context and Morphology: 78.381 53.09 82.95 [ 35.78 77.06 I 40.00 60.99 [ 42.36 81.37 I 24.85 (Precision/Recal!//F-measure) 63.30 50.00 52.66 50.00 38.07 Full bootstrapping: 76.95 I 64.99 83.67 ] 40.20 76.47 [ 43.33 6o.38 1 47.29 83.04 I 27.84 ( Precision/ Recall / / F-measure ) 70.47 54.30 55.32 53.04 41.70 Baseline classification accuracy 61.18 62.74 55.23 I 61.08 [ 61.79 System classification accuracy Table 4: Comparison of performance by language and knowledge source models can learn the behaviour of previously unseen is in all cases greater than for the morphology or affixes and conquer new territory.</S>
			<S sid ="173" ssid = "173">Thus the model context source used alone.</S>
			<S sid ="174" ssid = "174">Furthermore, the full it- is entirely static On just the initial training data.</S>
			<S sid ="175" ssid = "175">erative bootstrapping clearly yields substantial im- For the same reasOns, the context only model is also provement over the static models, almost exclusively static.</S>
			<S sid ="176" ssid = "176">In this case there is a possible bootstrapping in the form of increased recall (and its corresponding path using alternating left and right context to ex- boost the the F-measure).</S>
			<S sid ="177" ssid = "177">pand coverage to new contexts, but this tends to be Cross-language analysis yields further insight.</S>
			<S sid ="178" ssid = "178">not robust and wa s not pursued.</S>
			<S sid ="179" ssid = "179">Interestingly, recall First, recall is much higher for the 4 languages for morphology only is typically much higher than in in which case is explicitly marked and is a clue the context only case.</S>
			<S sid ="180" ssid = "180">The reason for this is that the for named entity identification (Romanian, English, morphology models are full hierarchically smoothed Greek and Turkish) than for a language like Hindi, character tries rather than word token tries, and where there are no case distinctions and hence any hence have much &apos;~ denser initial statistics for small word could potentially be a named entity.</S>
			<S sid ="181" ssid = "181">A lan- training data sets~ proving greater partial matching guage such as German would be roughly in the mid- potential for previously unseen words.</S>
			<S sid ="182" ssid = "182">dle, where lowercase words have low probability as In an effort to I test the contribution of the full named entities, but capitalized words are highly am- iterative boostrapping, the &quot;context and morpholbiguous between common and proper nouns.</S>
			<S sid ="183" ssid = "183">Be-ogy only&quot; results &apos;, are based on the combination of cause approximately 96% of words in the Hindi text all 4 tries, but w:ithout any bootstrapping.</S>
			<S sid ="184" ssid = "184">Thus are not named entities, without additional ortho- they are trained ekclusively on the 150300 training graphic clues the prior probability for &quot;nonentity&quot; examples.</S>
			<S sid ="185" ssid = "185">Performance for the combined sources is so strong that the morphological or contextual evi80 8O 60 --I ixlI~q&quot;l/, m ~B [] Precision 60 bb 40 ~m E] Recall 40 ~ F \ x 20 /,I 15~ [] F-measure 20 F t ~&apos;.</S>
			<S sid ="186" ssid = "186">N &apos;~ N F 0 t ~ lk 2k 5k 10k 40 75 150 300 Size of the raw text for Total number of seed bootstrapping (words) names Figure 3: Learning curves for Romanian dence in favor of one of the named entity classes must be very compelling to overcome this bias.</S>
			<S sid ="187" ssid = "187">With only 50 training words per context this is difficult, and in the face of such strong odds against any of the named entity classes the conservative nature of the learning algorithm only braves an entity label (correctly) for 38% more words than the baseline model.</S>
			<S sid ="188" ssid = "188">In contrast, its performance on entity classification rather than identification, measured by forced choice accuracy in labelling the given entities, is comparable to all the other languages, with 79% accuracy relative to the 62% baseline.</S>
			<S sid ="189" ssid = "189">2 4.4 Evaluation at different training set sizes.</S>
			<S sid ="190" ssid = "190">Figure 3 demonstrates that the performance of the algorithm is highly sensitive to the size of the training data.</S>
			<S sid ="191" ssid = "191">Based on Romanian, the first graph shows that as the size of the raw text for bootstrapping increases, F-measure performance increases roughly logrithmically, due almost exclusively to increases in precision.</S>
			<S sid ="192" ssid = "192">(Approximately the same number of unique entities are being identified, but due to the increased number of examples of each, their classification is more accurate).</S>
			<S sid ="193" ssid = "193">This is avery encouraging trend, as the web and other online sources provides virtually unlimited raw text in most major languages, and substantial online text for virtually all languages.</S>
			<S sid ="194" ssid = "194">So extrapolating far beyond the 10K word level is relatively low cost and very feasible.</S>
			<S sid ="195" ssid = "195">The second graph shows that F-measure performance also increases roughly logrithmically with the total length of the seed wordlists in the range 40300.</S>
			<S sid ="196" ssid = "196">This increase is due entirely to improved recall, which doubles over this small range.</S>
			<S sid ="197" ssid = "197">This trend sug-.</S>
			<S sid ="198" ssid = "198">2Note again that this baseline is more competitive than typical, as it not only assigns the majority tag (&quot;last name&quot;), but when there is an exact match with the training wordlist (e.g. &quot;deepak&quot;), a common occurrence given repeated high- frequency names in the Hindi data, the training classification is used as the baseline answer gests that there is considerable benefit to be gained by additional human annotation, or seed wordlist acquisition from existing online lexicons.</S>
			<S sid ="199" ssid = "199">However, relative to case of raw text acquisition, such additional annotations tend to be much costlier, and there is a clear cost-benefit tradeoff to further investment in annotation.</S>
			<S sid ="200" ssid = "200">In summary, however, these evaluation results are satisfying in that they (a) show clear and consistent trends across several diverse languages, (b) show clear trends for improvement as training resources grow, and (c) show that comparable (and robust) classification results can be achieved on this diversity of languages.</S>
			<S sid ="201" ssid = "201">5 Future work.</S>
			<S sid ="202" ssid = "202">For future work, natural next steps include incorporating a language independent word segmentation phase like the one proposed by Amitay, Richmond and Smith (1997), to improve the performance on large texts.</S>
			<S sid ="203" ssid = "203">Different statistics can be pre-computed for different languages and language families and stored in external files.</S>
			<S sid ="204" ssid = "204">For example, the a priori probability of a named entity given the set of characteristics of its representation in the text, such as position, capitalization, and relative position of other entities (e.g.: first name followed by last name).</S>
			<S sid ="205" ssid = "205">A further step is the implementation of a supervised active learning system based on the present algorithm, in which the most relevant words for future disambiguation is presented to the user to be classified and the feedback used for bootstrapping.</S>
			<S sid ="206" ssid = "206">The selection of candidate examples for tagging would be based on both the unassigned probability mass and the frequency of occurrence.</S>
			<S sid ="207" ssid = "207">Active learning strategies (Lewis and Gale, 1994) are a natural path for efficiently selecting contexts for human annotation.</S>
			<S sid ="208" ssid = "208">Conclusion of the Fifth Conference on Applied Natural Lan- This paper has presented an algorithm for the minimally supervised learning of named entity recognizers given short name lists as seed data (typically 40100 example wordS per entity class).</S>
			<S sid ="209" ssid = "209">The algorithm uses hierarchically ismoothed trie structures for modeling morphological and contextual probabilities effectively in a language independent framework, overcoming the need for fixed token boundaries or history lengths.</S>
			<S sid ="210" ssid = "210">Th e combination of relatively independent morphological and contextual evidence sources in an iterative bootstrapping framework converges upon a successful inamed entity recognizer, achieving a competitive 70.5%-75.4% F-measure (measuring both named entity identification and classification) when applied to Romanian text.</S>
			<S sid ="211" ssid = "211">Fixed k-way classification accuracy on given entities ranges between 73%-79% on 5 diverse languages for a difficult firstname/l~stname/place partition, and approaches 92% accuracy for the simpler person/place discrimination.</S>
			<S sid ="212" ssid = "212">These results were achieved using only unannotated training texts, with absolutely no required language-specific information, tokenizers or other tools, and requiring no more than 15 minutes total human effort in training (for short wordlist creation) The observed robust and consistent performance and very rapid, low cost rampup across 5 quite different languages shows the potential for further successful and diverse applications of this work to new languages and domains.</S>
	</SECTION>
	<SECTION title="Acknowledgements">
</PAPER>
