<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We present an implementation of a part-of-speech tagger based on a hidden Markov model.</S>
		<S sid ="2" ssid = "2">The methodology enables robust and accurate tagging with few resource requirements.</S>
		<S sid ="3" ssid = "3">Only a lexicon and some unlabeled training text are required.</S>
		<S sid ="4" ssid = "4">Accuracy exceeds 96%.</S>
		<S sid ="5" ssid = "5">We describe implementation strategies and optimizations which result in high-speed operation.</S>
		<S sid ="6" ssid = "6">Three applications for tagging are described: phrase recognition; word sense disambiguation; and grammatical function assignment.</S>
		<S sid ="7" ssid = "7">1 Desiderata Many words are ambiguous in their part of speech.</S>
		<S sid ="8" ssid = "8">For example, &quot;tag&quot; can be a noun or a verb.</S>
		<S sid ="9" ssid = "9">However, when a word appears in the context of other words, the ambiguity is often reduced: in &apos;% tag is a part-of-speech label,&quot; the word &quot;tag&quot; can only be a noun.</S>
		<S sid ="10" ssid = "10">A part-of-speech tagger is a system that uses context to assign parts of speech to words.</S>
		<S sid ="11" ssid = "11">Automatic text tagging is an important first step in discovering the linguistic structure of large text corpora.</S>
		<S sid ="12" ssid = "12">Part-of-speech information facilitates higher-level analysis, such as recognizing noun phrases and other patterns in text.</S>
		<S sid ="13" ssid = "13">For a tagger to function as a practical component in a language processing system, we believe that a tagger must be: Robust Text corpora contain ungrammatical constructions, isolated phrases (such as titles), and non- linguistic data (such as tables).</S>
		<S sid ="14" ssid = "14">Corpora are also likely to contain words that are unknown to the tagger.</S>
		<S sid ="15" ssid = "15">It is desirable that a tagger deal gracefully with these situations.</S>
		<S sid ="16" ssid = "16">Efficient If a tagger is to be used to analyze arbitrarily large corpora, it must be efficient--performing in time linear in the number of words tagged.</S>
		<S sid ="17" ssid = "17">Any training required should also be fast, enabling rapid turnaround with new corpora and new text genres.</S>
		<S sid ="18" ssid = "18">Accurate A tagger should attempt to assign the correct part-of-speech tag to every word encountered.</S>
		<S sid ="19" ssid = "19">Tunab le A tagger should be able to take advantage of linguistic insights.</S>
		<S sid ="20" ssid = "20">One should be able to correct systematic errors by supplying appropriate a priori &quot;hints.&quot;</S>
		<S sid ="21" ssid = "21">It should be possible to give different hints for different corpora.</S>
		<S sid ="22" ssid = "22">Reusable The effort required to retarget a tagger to new corpora, new tagsets, and new languages should be minimal.</S>
	</ABSTRACT>
	<SECTION title="Background" number = "1">
			<S sid ="23" ssid = "23">Several different approaches have been used for building text taggers.</S>
			<S sid ="24" ssid = "24">Greene and Rubin used a rule-based approach in the TAGGIT program [Greene and Rubin, 1971], which was an aid in tagging the Brown corpus [Francis and Ku~era, 1982].</S>
			<S sid ="25" ssid = "25">TAGGIT disambiguated 77% of the corpus; the rest was done manually over a period of several years.</S>
			<S sid ="26" ssid = "26">More recently, Koskenniemi also used a rule-based approach implemented with finite-state machines [Koskenniemi, 1990].</S>
			<S sid ="27" ssid = "27">Statistical methods have also been used (e.g., [DeRose, 1988], [Garside et al., 1987]).</S>
			<S sid ="28" ssid = "28">These provide the capability of resolving ambiguity on the basis of most likely interpretation.</S>
			<S sid ="29" ssid = "29">A form of Markov model has been widely used that assumes that a word depends probabilistically on just its part-of-speech category, which in turn depends solely on the categories of the preceding two words.</S>
			<S sid ="30" ssid = "30">Two types of training (i.e., parameter estimation) have been used with this model.</S>
			<S sid ="31" ssid = "31">The first makes use of a tagged training corpus.</S>
			<S sid ="32" ssid = "32">Derouault and Merialdo use a bootstrap method for training [Derouault and Merialdo, 1986].</S>
			<S sid ="33" ssid = "33">At first, a relatively small amount of text is manually tagged and used to train a partially accurate model.</S>
			<S sid ="34" ssid = "34">The model is then used to tag more text, and the tags are manually corrected and then used to retrain the model.</S>
			<S sid ="35" ssid = "35">Church uses the tagged Brown corpus for training [Church, 1988].</S>
			<S sid ="36" ssid = "36">These models involve probabilities for each word in the lexicon, so large tagged corpora are required for reliable estimation.</S>
			<S sid ="37" ssid = "37">The second method of training does not require a tagged training corpus.</S>
			<S sid ="38" ssid = "38">In this situation the Baum-Welch algorithm (also known as the forward-backward algorithm) can be used [Baum, 1972].</S>
			<S sid ="39" ssid = "39">Under this regime the model is called a hidden Markov model (HMM), as state transitions (i.e., part-of-speech categories) are assumed to be unobservable.</S>
			<S sid ="40" ssid = "40">Jelinek has used this method for training a text tagger [Jelinek, 1985].</S>
			<S sid ="41" ssid = "41">Parameter smoothing can be conveniently achieved using the method of deleted interpolation in which weighted estimates are taken from second- and first-order models and a uniform probability distribution [Jelinek and Mercer, 1980].</S>
			<S sid ="42" ssid = "42">Kupiec used word equivalence classes (referred to here as ambiguity classes) based on parts of speech, to pool data from individual words [Kupiec, 1989b].</S>
			<S sid ="43" ssid = "43">The most common words are still represented individually, as sufficient data exist for robust estimation.</S>
			<S sid ="44" ssid = "44">133 However all other words are represented according to the set of possible categories they can assume.</S>
			<S sid ="45" ssid = "45">In this manner, the vocabulary of 50,000 words in the Brown corpus can be reduced to approximately 400 distinct ambiguity classes [Kupiec, 1992].</S>
			<S sid ="46" ssid = "46">To further reduce the number of parameters, a first-order model can be employed (this assumes that a word&apos;s category depends only on the immediately preceding word&apos;s category).</S>
			<S sid ="47" ssid = "47">In [Kupiec, 1989a], networks are used to selectively augment the context in a basic first- order model, rather than using uniformly second-order dependencies.</S>
			<SUBSECTION>2.2 Our approach.</SUBSECTION>
			<S sid ="48" ssid = "48">We next describe how our choice of techniques satisfies the criteria listed in section 1.</S>
			<S sid ="49" ssid = "49">The use of an HMM permits complete flexibility in the choice of training corpora.</S>
			<S sid ="50" ssid = "50">Text from any desired domain can be used, and a tagger can be tailored for use with a particular text database by training on a portion of that database.</S>
			<S sid ="51" ssid = "51">Lexicons containing alternative tag sets can be easily accommodated without any need for relabeling the training corpus, affording further flexibility in the use of specialized tags.</S>
			<S sid ="52" ssid = "52">As the resources required are simply a lexicon and a suitably large sample of ordinary text, taggers can be built with minimal effort, even for other languages, such as French (e.g., [Kupiec, 1992]).</S>
			<S sid ="53" ssid = "53">The use of ambiguity classes and a first-order model reduces the number of parameters to be estimated without significant reduction in accuracy (discussed in section 5).</S>
			<S sid ="54" ssid = "54">This also enables a tagger to be reliably trained using only moderate amounts of text.</S>
			<S sid ="55" ssid = "55">We have produced reasonable results training on as few as 3,000 sentences.</S>
			<S sid ="56" ssid = "56">Fewer parameters also reduce the time required for training.</S>
			<S sid ="57" ssid = "57">Relatively few ambiguity classes are sufficient for wide coverage, so it is unlikely that adding new words to the lexicon requires retraining, as their ambiguity classes are already accommodated.</S>
			<S sid ="58" ssid = "58">Vocabulary independence is achieved by predicting categories for words not in the lexicon, using both context and suffix information.</S>
			<S sid ="59" ssid = "59">Probabilities corresponding to category sequences that never occurred in the training data are assigned small, nonzero values, ensuring that the model will accept any sequence of tokens, while still providing the most likely tagging.</S>
			<S sid ="60" ssid = "60">By using the fact that words are typically associated with only a few part-of- speech categories, and carefully ordering the computation, the algorithms have linear complexity (section 3.3).</S>
			<S sid ="61" ssid = "61">3 H idden Markov Mode l ing The hidden Markov modeling component of our tagger is implemented as an independent module following the specification given in [Levinson et al., 1983], with special attention to space and time efficiency issues.</S>
			<S sid ="62" ssid = "62">Only first-order modeling is addressed and will be presumed for the remainder of this discussion.</S>
			<S sid ="63" ssid = "63">3.1 Formalism.</S>
			<S sid ="64" ssid = "64">In brief, an HMM is a doubly stochastic process that generates sequence of symbols S = { Si, S2,...,ST}, Si E W I&lt; i&lt;T, where W is some finite set of possible symbols, by composing an underlying Markov process with a state-dependent symbol generator (i.e., a Markov process with noise), i Th Markov process captures the notion of sequence depen dency and is described by a set of N states, a matrix c transition probabilities A = {aij} 1 &lt;_ i, j &lt;_ N where ai is the probability of moving from state i to state j, and vector of initial probabilities H = {rq} 1 &lt; i &lt; N where is the probability of starting in state i. The symbol ger erator is a state-dependent measure on V described by matrix of symbol probabilities B = {bjk} 1 _&lt; j &lt;__ N an 1 &lt; k &lt; M where M = IWI and bjk is the probability generating symbol s~ given that the Markov process is i state j.2 In part-of-speech tagging, we will model word order d, pendency through an underlying Markov process that ot crates in terms of lexical tags, &apos;yet we will only be ab to observe the sets of tags, or ambiguity classes, that aJ possible for individual words.</S>
			<S sid ="65" ssid = "65">The ambiguity class of eac word is the set of its permitted parts of speech, only or of which is correct in context.</S>
			<S sid ="66" ssid = "66">Given the parameters A, and H, hidden Markov modeling allows us to compute tt most probable sequence of state transitions, and hence tt mostly likely sequence of lexical tags, corresponding to sequence of ambiguity classes.</S>
			<S sid ="67" ssid = "67">In the following, N can identified with the number of possible.tags, and W wit the set of all ambiguity classes.</S>
			<S sid ="68" ssid = "68">Applying an HMM consists of two tasks: estimating tt model parameters A, B and H from a training set; ar computing the most likely sequence of underlying sta transitions given new observations.</S>
			<S sid ="69" ssid = "69">Maximum likeliho( estimates (that is, estimates that maximize the probabili of the training set) can be found through application of ternating expectation in a procedure known as the Baur Welch, or forward-backward, algorithm [Baum, 1972].</S>
			<S sid ="70" ssid = "70">proceeds by recursively defining two sets of probabiliti, the forward probabilities, at+i(J)= [ ~-~at(i)ai~]i=i b,(St+i) 1 &lt;t &lt;Tl , ( where at( i ) = ribi(Si) for all i; and the backward prob bilities, N = Ti &lt; t &lt; i , ( j= i where [3T(j) = 1 for all j. The forward probabili at(i) is the joint probability of the sequence up to tir t, {Si, S2, . . .</S>
			<S sid ="71" ssid = "71">,St} , and the event that the Markov pr cess is in state i at time t. Similarly, the backwa probability [3t(j) is the probability of seeing the sequen {St+i, St+2 ....</S>
			<S sid ="72" ssid = "72">, ST} given that the Markov process is state i at time t. It follows that the probability of t entire sequence is N N P = E E °~t(i)ai~bJ(St+i)/3t+i(j) imi j= i for any t in the range l&lt;t &lt;T- 1.a iFor an introduction to hidden Markov modeling see [l: biner and Juang, 1986].</S>
			<S sid ="73" ssid = "73">2In the following we will write hi(St ) for bjk if St = s~.</S>
			<S sid ="74" ssid = "74">3This is most conveniently evaluated at t = T - 1, in whi ca e P = 134 Given an initial choice for the parameters A, B, and II the expected number of transitions, 7ij, from state i to state j conditioned on the observation sequence S may be computed as follows: T-1 1 7ij = -fi E at(i)aijbj(St+l)~t+l(j).</S>
			<S sid ="75" ssid = "75">t= l Hence we can estimate aij by: _ ET: 5&apos;i = N Ej=l 7ij ET:I 1 at(i)~t(i) Similarly, bj~ and 7ri can be estimated as follows: bjk = Et~s,: , , at(j)~t(j) ET=I at(j)Zt (j) and (3) (4) 1 ~i---- ~Ot1(i)~1(i).</S>
			<S sid ="76" ssid = "76">(5) In summary, to find maximum likelihood estimates for A, B, and II, via the Baum-Welch algorithm, one chooses some starting values, applies equations 35 to compute new values, and then iterates until convergence.</S>
			<S sid ="77" ssid = "77">It can be shown that this algorithm will converge, although possibly to a non-global maximum [Baum, 1972].</S>
			<S sid ="78" ssid = "78">Once a model has been estimated, selecting the most likely underlying sequence of state transitions corresponding to an observation S can be thought of as a maximization over all sequences that might generate S. An efficient dynamic programming procedure, known as the Viterbi algorithm [Viterbi, 1967], arranges for this computation to proceed in time proportional to T. Suppose V = {v(t)} 1 &lt; t &lt; T is a state sequence that generates S, then the probability that V generates S is, T P(v) = %(ub~(1)(S1) H a~(t-1)~(t)b~(t)(St).</S>
			<S sid ="79" ssid = "79">t=2 • To find the most probable such sequence we start by defining ¢1(i) = ~rib~(S1) for 1 &lt; i &lt; N and then perform the recursion et( j) = ~a&lt;x[¢t-l(i)aij]bj(St) (6) and Ct(j) = maxtCt_ l ( i ) I&lt;i&lt;N for 2 &lt; t &lt; T and i _&lt; j _&lt; N. The crucial observation is-that-for each time t and each state i one need only consider the most probable sequence arriving at state i at time t. The probability of the most probable sequence is maxl&lt;_i&lt;.N[¢T(i)] while the sequence itself can be reconstructed by defining v(T) = maxl--&lt;_li&lt;g eT(i) and v(tI) = et (q t ) for T &gt; t &gt; 2.</S>
			<S sid ="80" ssid = "80">3.2 Numer ica l Stab i l i ty.</S>
			<S sid ="81" ssid = "81">The Baum-Welch algorithm (equations 15) and the Viterbi algorithm (equation 6) involve operations on products of numbers constrained to be between 0 and 1.</S>
			<S sid ="82" ssid = "82">Since these products can easily underflow, measures must be taken to rescale.</S>
			<S sid ="83" ssid = "83">One approach premultiplies the a and 13 probabilities with an accumulating product depending on t [Levin- son et al., 1983].</S>
			<S sid ="84" ssid = "84">Let 51(i) = al(i) and define ct = 5t i l&lt;t&lt;T. Now define &amp;t(i) = ctK~t(i) and use a in place of a in equation 1 to define &amp; for the next iteration: 5t+l( j ) = &amp;t(i)aij bj(St+l) l&lt;t&lt;T-1 . Note that E in__=l ~t(i) = 1 for 1 &lt; t &lt; T. Similarly, let ~T(i) = ~T(i) and define 3t(i) = ct~t(i) for T &gt; t &gt; 1 where N ~t(i) = E aiJ bj(St+l)3t+l(j) j=l Tl&lt;t&lt;l . The scaled backward and forward probabilities, 5 and ~, can be exchanged for the unscaled probabilities in equations 35 without affecting the value of the ratios.</S>
			<S sid ="85" ssid = "85">To see this, note that at(i) = C[at(i) and ~t(i) = ~t(i)C/+l where J C~=Hct . Now, in terms of the scaled probabilities, equation 5, for example, can be seen to be unchanged: (~ 1 (i)f}l (i) _ EN=I aT(i) E~=l CTaT(i) = ~&apos;i.</S>
			<S sid ="86" ssid = "86">A slight difficulty occurs in equation 3 that can be cured by the addition of a new term, ct+l, in each product of the upper sum: T-1 ^ • ^ . ~~t=l at(z)aijbj(St+, )~t+l(J)Ct+l ^ ET_~ll &amp;t( i)~t( i) = a,j. Numerical instability in the Viterbi algorithm can be ameliorated by operating on a logarithmic scale [Levinson et al., 1983].</S>
			<S sid ="87" ssid = "87">That is, one maximizes the log probability of each sequence of state transitions, log(P(v)) = + log(b (1)(Sl)) + T E log(a~(t_ 1)~(t)) + log(b~(t)(St)).</S>
			<S sid ="88" ssid = "88">t=2 Hence, equation 6 is replaced by et(J) = max [¢t-1(i) + log(ao)] + logbj(St).</S>
			<S sid ="89" ssid = "89">I&lt; i&lt;N Care must be taken with zero probabilities.</S>
			<S sid ="90" ssid = "90">However, this can be elegantly handled through the use of IEEE negative infinity [P754, 1981].</S>
			<S sid ="91" ssid = "91">135 3.3 Reduc ing T ime Complex i ty.</S>
			<S sid ="92" ssid = "92">As can be seen from equations 15, the time cost of training is O(TN~).</S>
			<S sid ="93" ssid = "93">Similarly, as given in equation 6, the Viterbi algorithm is also O(TN2).</S>
			<S sid ="94" ssid = "94">However, in part-of-speech tagging, the problem structure dictates that the matrix of symbol probabilities B is sparsely populated.</S>
			<S sid ="95" ssid = "95">That is, bij 3£ 0 iff the ambiguity class corresponding to symbol j includes the part-of-speech tag associated with state i. In practice, the degree of overlap between ambiguity classes is relatively low; some tokens are assigned unique tags, and hence have only one nonzero symbol probability.</S>
			<S sid ="96" ssid = "96">The sparseness of B leads one to consider restructuring equations 16 so a check for zero symbol probability can obviate the need for further computation.</S>
			<S sid ="97" ssid = "97">Equation 1 is already conveniently factored so that the dependence on bj(St+l) is outside the inner sum.</S>
			<S sid ="98" ssid = "98">Hence, ifk is the average number of nonzero entries in each row of B, the cost of computing equation 1 can be reduced to O(kTN).</S>
			<S sid ="99" ssid = "99">Equations 24 can be similarly reduced by switching the order of iteration.</S>
			<S sid ="100" ssid = "100">For example, in equation 2, rather than for a given t computing/3t(i) for each i one at a time, one can accumulate terms for all i in parallel.</S>
			<S sid ="101" ssid = "101">The net effect of this rewriting is to place a bj(St+l) = 0 check outside the innermost iteration.</S>
			<S sid ="102" ssid = "102">Equations 3 and 4 submit to a similar approach.</S>
			<S sid ="103" ssid = "103">Equation 5 is already only O(N).</S>
			<S sid ="104" ssid = "104">Hence, the overall cost of training can be reduced to O(kTN), which, in our experience, amounts to an order of magnitude speed- upfl The time complexity of the Viterbi algorithm can also be reduced to O(kTN) by noting that bj(St) can be factored out of the maximization of equation 6.</S>
			<S sid ="105" ssid = "105">3.4 Controlling Space Complexity Adding up the sizes of the probabil ity matrices A, B, and H, it is easy to see that the storage cost for directly representing one model is proportional to N(N -t- M + 1).</S>
			<S sid ="106" ssid = "106">Running the Baum-Welch algorithm requires storage for the sequence of observations, the a and /3 probabilities, the vector {ci}, and copies of the A and B matrices (since the originals cannot be overwritten until the end of each iteration).</S>
			<S sid ="107" ssid = "107">Hence, the grand total of space required for training is proportional to T q- 2N(T q- N + M + 1)..</S>
			<S sid ="108" ssid = "108">Since N and M are fixed by the model, the only parameter that can be varied to reduce storage costs is T. Now, adequate training requires processing from tens of thousands to hundreds of thousands of tokens [Kupiec, 1989a].</S>
			<S sid ="109" ssid = "109">The training set can be considered one long sequence, it which case T is very large indeed, or it can be broken up into a number of smaller sequences at convenient boundaries.</S>
			<S sid ="110" ssid = "110">In first-order hidden Markov modeling, the stochastic process effectively restarts at unambiguous tokens, such as sentence and paragraph markers, hence these tokens are convenient points at which to break the training set.</S>
			<S sid ="111" ssid = "111">If the BaumWeleh algorithm is run separately (from the same starting point) on each piece, the resulting trained models must be recombined in some way.</S>
			<S sid ="112" ssid = "112">One obvious approach is simply to average.</S>
			<S sid ="113" ssid = "113">However, this fails if any two 4An equivalent approach maintains a mapping from states i to nonzero symbol probabilities and simply avoids, in the inner iteration, computing products which must be zero [Kupiec, 1992].</S>
			<S sid ="114" ssid = "114">states are indistinguishable (in the sense that they had the same transition probabilities and the same symbol probabilities at start), because states are then not matched across trained models.</S>
			<S sid ="115" ssid = "115">It is therefore important that each state have a distinguished role, which is relatively easy to achieve in part-of-speech tagging.</S>
			<S sid ="116" ssid = "116">Our implementation of the Baum-Welch algorithm breaks up the input into fixed-sized pieces of training text.</S>
			<S sid ="117" ssid = "117">The Baum-Welch algorithm is then run separately on each piece and the results are averaged together.</S>
			<S sid ="118" ssid = "118">Running the Viterbi algorithm requires storage for the sequence of observations, a vector of current maxes, a scratch array of the same size, and a matrix of ¢ indices, for a total proportional to T + N(2 + T) and a grand total (including the model) of T -t- N(N H- M + T ÷ 3).</S>
			<S sid ="119" ssid = "119">Again, N and M are fixed.</S>
			<S sid ="120" ssid = "120">However, T need not be longer than a single sentence, since, as was observed above, the HMM, and hence the Viterbi algorithm, restarts at sentence boundaries.</S>
			<S sid ="121" ssid = "121">3.5 Mode l Tun ing.</S>
			<S sid ="122" ssid = "122">An HMM for part-of-speech tagging can be tuned in a variety of ways.</S>
			<S sid ="123" ssid = "123">First, the choice of tagset and lexicon determines the initial model.</S>
			<S sid ="124" ssid = "124">Second, empirical and a priori information can influence the choice of starting values for the Baum-Welch algorithm.</S>
			<S sid ="125" ssid = "125">For example, counting instances of ambiguity classes in running text allows one to assign non-uniform starting probabilities in A for a particular tag&apos;s realization as a particular ambiguity class.</S>
			<S sid ="126" ssid = "126">Alternatively, one can state a priori that a particular ambiguity class is most likely to be the reflection of some subset of its component tags.</S>
			<S sid ="127" ssid = "127">For example, if an ambiguity class consisting of the open class tags is used for unknown words, one may encode the fact that most unknown words are nouns or proper nouns by biasing the initial probabilities in B. Another biasing of starting values can arises from noting that some tags are unlikely to be followed by others.</S>
			<S sid ="128" ssid = "128">For example, the lexical item &quot;to&quot; maps to an ambiguity class containing two tags, infinitive-marker and to-as- preposition, neither of which occurs in any other ambiguity class.</S>
			<S sid ="129" ssid = "129">If nothing more were stated, the HMM would have two states which were indistinguishable.</S>
			<S sid ="130" ssid = "130">This can be remedied by setting the initial transition probabilities from infinitive-marker to strongly favor transitions to such states as verb-uninflected and adverb.</S>
			<S sid ="131" ssid = "131">Our implementation allows for two sorts of biasing of starting values: ambiguity classes can be annotated with favored tags; and states can be annotated with favored transitions.</S>
			<S sid ="132" ssid = "132">These biases may be specified either as sets or as set complements.</S>
			<S sid ="133" ssid = "133">Biases are implemented by replacing the disfavored probabilities with a small constant (machine epsilon) and redistributing mass to the other possibilities.</S>
			<S sid ="134" ssid = "134">This has the effect of disfavoring the indicated outcomes without disallowing them; sufficient converse data can rehabilitate these values.</S>
			<S sid ="135" ssid = "135">4 Arch i tec ture.</S>
			<S sid ="136" ssid = "136">In support of this and other work, we have developed a system architecture for text access [Cutting et al., 1991].</S>
			<S sid ="137" ssid = "137">This architecture defines five components for such systems: 136 Search Index Analysis Corpus °4 °°°° . . .</S>
			<S sid ="138" ssid = "138">~°°°°°°° &quot; &apos; - .°° o.O° °°°oo ....&quot;&quot;(further analysis) &quot;&quot;&quot; stem, tag l //~:/ Tagging -~ Training . / ? ~t ra inedHMM/ ambiguityelass,&lt;stem,tag&gt;* ~/ambigu i tyc lass Lexicon token l Tokenizer -... character ~&apos;°o~,oQ.°° . . ° , . , ° °°°°°°°~ °° . . .</S>
			<S sid ="139" ssid = "139">, • Figure 1: Tagger Modules in System Context corpus, which provides text in a generic manner; analysis, which extracts terms from the text; index which stores term occurrence statistics; and search, which utilizes these statistics to resolve queries.</S>
			<S sid ="140" ssid = "140">The part-of-speech tagger described here is implemented as an analysis module.</S>
			<S sid ="141" ssid = "141">Figure 1 illustrates the overall architecture, showing the tagger analysis implementation in detail.</S>
			<S sid ="142" ssid = "142">The tagger itself has a modular architecture, isolating behind standard protocols those elements which may vary, enabling easy substitution of alternate implementations.</S>
			<S sid ="143" ssid = "143">Also illustrated here are the data types which flow between tagger components.</S>
			<S sid ="144" ssid = "144">As an analysis implementation, the tagger must generate terms from text.</S>
			<S sid ="145" ssid = "145">In this context, a term is a word stem annotated with part of speech.</S>
			<S sid ="146" ssid = "146">Text enters the analysis subsystem where the first processing module it encounters is the tokenizer, whose duty is to convert text (a sequence of characters) into a sequence of tokens.</S>
			<S sid ="147" ssid = "147">Sentence boundaries are also identified by the tokenizer and are passed as reserved tokens.</S>
			<S sid ="148" ssid = "148">The tokenizer subsequently passes tokens to the lexicon.</S>
			<S sid ="149" ssid = "149">Here tokens are converted into a set of stems, each annotated with a part-of-speech tag.</S>
			<S sid ="150" ssid = "150">The set of tags identifies an ambiguity class.</S>
			<S sid ="151" ssid = "151">The identification of these classes is also the responsibility of the lexicon.</S>
			<S sid ="152" ssid = "152">Thus the lexicon delivers a set of stems paired with tags, and an ambiguity c lass . The training module takes long sequences of ambiguity classes as input.</S>
			<S sid ="153" ssid = "153">It uses the Baum-Welch algorithm to produce a trained HMM, an input to the tagging module.</S>
			<S sid ="154" ssid = "154">Training is typically performed on a sample of the corpus at hand, with the trained HMM being saved for subsequent use on the corpus at large.</S>
			<S sid ="155" ssid = "155">The tagging module buffers sequences of ambiguity classes between sentence boundaries.</S>
			<S sid ="156" ssid = "156">These sequences are disambiguated by computing the maximal path through the HMM with the Viterbi algorithm.</S>
			<S sid ="157" ssid = "157">Operating at sentence granularity provides fast throughput without loss of accuracy, as sentence boundaries are unambiguous.</S>
			<S sid ="158" ssid = "158">The resulting sequence of tags is used to select the appropriate stems.</S>
			<S sid ="159" ssid = "159">Pairs of stems and tags are subsequently emitted.</S>
			<S sid ="160" ssid = "160">The tagger may function as a complete analysis component, providing tagged text to search and indexing components, or as a subsystem of a more elaborate analysis, such as phrase recognition.</S>
			<S sid ="161" ssid = "161">4.1 Token izer Implementation The problem of tokenization has been well addressed by much work in compilation of programming languages.</S>
			<S sid ="162" ssid = "162">The accepted approach is to specify token classes with regular expressions.</S>
			<S sid ="163" ssid = "163">These may be compiled into a single deterministic finite state automaton which partitions character streams into labeled tokens [Aho et al., 1986, Lesk, 1975]..</S>
			<S sid ="164" ssid = "164">In the context of tagging, we require at least two token classes: sentence boundary and word.</S>
			<S sid ="165" ssid = "165">Other classes may include numbers, paragraph boundaries and various sorts of punctuation (e.g., braces of various types, commas).</S>
			<S sid ="166" ssid = "166">However, for simplicity, we will henceforth assume only words and sentence boundaries are extracted.</S>
			<S sid ="167" ssid = "167">Just as with programming languages, with text it is not always possible to unambiguously specify the required token classes with regular expressions.</S>
			<S sid ="168" ssid = "168">However the addition of a simple lookahead mechanism which allows specification of right context ameliorates this [Aho et al., 1986, Lesk, 1975].</S>
			<S sid ="169" ssid = "169">For example, a sentence boundary in English text might be identified by a period, followed by white- space, followed by an uppercase letter.</S>
			<S sid ="170" ssid = "170">However the up- 137 percase letter must not be consumed, as it is the first component of the next token.</S>
			<S sid ="171" ssid = "171">A lookahead mechanism allows us to specify in the sentence-boundary regular expression that the final character matched should not be considered a part of the token.</S>
			<S sid ="172" ssid = "172">This method meets our stated goals for the overall system.</S>
			<S sid ="173" ssid = "173">It is efficient, requiring that each character be examined only once (modulo lookahead).</S>
			<S sid ="174" ssid = "174">It is easily parameter- izable, providing the expressive power to concisely define accurate and robust token classes.</S>
			<S sid ="175" ssid = "175">4.2 Lex icon Imp lementat ion.</S>
			<S sid ="176" ssid = "176">The lexicon module is responsible for enumerating parts of speech and their associated stems for each word it is given.</S>
			<S sid ="177" ssid = "177">For the English word &quot;does,&quot; the lexicon might return &quot;do, verb&quot; and &quot;doe, plural-noun.&quot;</S>
			<S sid ="178" ssid = "178">It is also responsible for identifying ambiguity classes based upon sets of tags.</S>
			<S sid ="179" ssid = "179">We have employed a three-stage implementation: First, we consult a manually-constructed lexicon to find stems and parts of speech.</S>
			<S sid ="180" ssid = "180">Exhaustive lexicons of this sort are expensive, if not impossible, to produce.</S>
			<S sid ="181" ssid = "181">Fortunately, a small set of words accounts for the vast majority of word occurences.</S>
			<S sid ="182" ssid = "182">Thus high coverage can be obtained without prohibitive effort.</S>
			<S sid ="183" ssid = "183">Words not found in the manually constructed lexicon are generally both open class and regularly inflected.</S>
			<S sid ="184" ssid = "184">As a second stage, a language-specific method can be employed to guess ambiguity classes for unknown words.</S>
			<S sid ="185" ssid = "185">For many languages (e.g., English and French), word suffixes provide strong cues to words&apos; possible categories.</S>
			<S sid ="186" ssid = "186">Probabalistic predictions of a word&apos;s category can be made by analyzing suffixes in untagged text [Kupiec, 1992, Meteer e* al., 1991].</S>
			<S sid ="187" ssid = "187">As a final stage, if a word is not in the manually constructed lexicon, and its suffix is not recognized, a default ambiguity class is used.</S>
			<S sid ="188" ssid = "188">This class typically contains all the open class categories in the language.</S>
			<S sid ="189" ssid = "189">Dictionaries and suffix tables are both efficiently implementable as letter trees, or tries [Knuth, 1973], which require that each character of a word be examined only once during a lookup.</S>
			<S sid ="190" ssid = "190">5 Per fo rmance.</S>
			<S sid ="191" ssid = "191">In this section, we detail how our tagger meets the desiderata that we outlined in section 1.</S>
			<S sid ="192" ssid = "192">5.1 Efficient The system is implemented in Common Lisp [Steele, 1990].</S>
			<S sid ="193" ssid = "193">All timings reported are for a Sun SPARCStation2.</S>
			<S sid ="194" ssid = "194">The English lexicon used contains 38 tags (M -- 38) and 174 ambiguity classes (N -- 174)..</S>
			<S sid ="195" ssid = "195">Training was performed on 25,000 words in articles selected randomly from Grolier&apos;s Encyclopedia.</S>
			<S sid ="196" ssid = "196">Five iterations of training were performed in a total time of 115 CPU seconds.</S>
			<S sid ="197" ssid = "197">Following is a time breakdown by component: Training: average #seconds per token tokenizer lexicon 1 iteration 5 iterations total 640 400 680 3400 4600 Tagging was performed on 115,822 words in a collection of articles by the journalist Dave Barry.</S>
			<S sid ="198" ssid = "198">This required a total of of 143 CPU seconds.</S>
			<S sid ="199" ssid = "199">The time breakdown for this was as follows: Tagging: average #seconds per token tokenizer lexicon Viterbi total 604 388 233 1235 It can be seen from these figures that training on a new corpus may be accomplished in a matter of minutes, and that tens of megabytes of text may then be tagged per hour.</S>
			<S sid ="200" ssid = "200">5.2 Accurate and Robust.</S>
			<S sid ="201" ssid = "201">When using a lexicon and tagset built from the tagged text of the Brown corpus [Francis and Ku~era, 1982], training on one half of the corpus (about 500,000 words) and tagging the other, 96% of word instances were assigned the correct tag.</S>
			<S sid ="202" ssid = "202">Eight iterations of training were used.</S>
			<S sid ="203" ssid = "203">This level of accuracy is comparable to the best achieved by other taggers [Church, 1988, Merialdo, 1991].</S>
			<S sid ="204" ssid = "204">The Brown Corpus contains fragments and ungrammaticalities, thus providing a good demonstration of robustness.</S>
			<S sid ="205" ssid = "205">5.3 Tunable and Reusable.</S>
			<S sid ="206" ssid = "206">A tagger should be tunable, so that systematic tagging errors and anomalies can be addressed.</S>
			<S sid ="207" ssid = "207">Similarly, it is important that it be fast and easy to target the tagger to new genres and languages, and to experiment with different tagsets reflecting different insights into the linguistic phenomena found in text.</S>
			<S sid ="208" ssid = "208">In section 3.5, we describe how the HMM implementation itself supports tuning.</S>
			<S sid ="209" ssid = "209">In addition, our implementation supports a number of explicit parameters to facilitate tuning and reuse, including specification of lexicon and training corpus.</S>
			<S sid ="210" ssid = "210">There is also support for a flexible tagset.</S>
			<S sid ="211" ssid = "211">For example, if we want to collapse distinctions in the lexicon, such as those between positive, comparative, and superlative adjectives, we only have to make a small change in the mapping from lexicon to tagset.</S>
			<S sid ="212" ssid = "212">Similarly, if we wish to make finer grain distinctions than those available in the lexicon, such as case marking on pronouns, there is a simple way to note such exceptions.</S>
			<S sid ="213" ssid = "213">6 Applications.</S>
			<S sid ="214" ssid = "214">We have used the tagger in a number of applications.</S>
			<S sid ="215" ssid = "215">Wc describe three applications here: phrase recognition; word sense disambiguation; and grammatical function assignment.</S>
			<S sid ="216" ssid = "216">These projects are part of a research effort to use shallow analysis techniques to extract content from unrestricted text.</S>
			<S sid ="217" ssid = "217">6.1 Phrase Recognition.</S>
			<S sid ="218" ssid = "218">We have constructed a system that recognizes simpl~ phrases when given as input the sequence of tags for a sentence.</S>
			<S sid ="219" ssid = "219">There are recognizers for noun phrases, verb groups adverbial phrases, and prepositional phrases.</S>
			<S sid ="220" ssid = "220">Each of thes~ phrases comprises a contiguous sequence of tags that satis.</S>
			<S sid ="221" ssid = "221">ties a simple grammar.</S>
			<S sid ="222" ssid = "222">For example, a noun phrase can b~ a unary sequence containing a pronoun tag or an arbitrar.</S>
			<S sid ="223" ssid = "223">ily long sequence of noun and adjective tags, possibly pre.</S>
			<S sid ="224" ssid = "224">ceded by a determiner tag and possibly with an embeddec possessive marker.</S>
			<S sid ="225" ssid = "225">The longest possible sequence is fount (e.g., &quot;the program committee&quot; but not &quot;the program&quot;) 138 Conjunctions are not recognized as part of any phrase; for example, in the fragment &quot;the cats and dogs,&quot; &quot;the cats&quot; and &quot;dogs&quot; will be recognized as two noun phrases.</S>
			<S sid ="226" ssid = "226">Prepositional phrase attachment is not performed at this stage of processing.</S>
			<S sid ="227" ssid = "227">This approach to phrase recognition in some cases captures only parts of some phrases; however, our approach minimizes false positives, so that we can rely on the recognizers&apos; results.</S>
			<S sid ="228" ssid = "228">6.2 Word Sense Disamblguatlon Part-of-speech tagging in and of itself is a useful tool in lexical disambiguation; for example, knowing that &quot;dig&quot; is being used as a noun rather than as a verb indicates the word&apos;s appropriate meaning.</S>
			<S sid ="229" ssid = "229">But many words have multiple meanings even while occupying the same part of speech.</S>
			<S sid ="230" ssid = "230">To this end, the tagger has been used in the implementation of an experimental noun homograph disambiguation algorithm [Hearst, 1991].</S>
			<S sid ="231" ssid = "231">The algorithm (known as CatchWord) performs supervised training over a large text corpus, gathering lexical, orthographic, and simple syntactic evidence for each sense of the ambiguous noun.</S>
			<S sid ="232" ssid = "232">After a period of training, CatchWord classifies new instances of the noun by checking its context against that of previously observed instances and choosing the sense for which the most evidence is found.</S>
			<S sid ="233" ssid = "233">Because the sense distinctions made are coarse, the disambiguation can be accomplished without the expense of knowledge bases or inference mechanisms.</S>
			<S sid ="234" ssid = "234">Initial tests resulted in accuracies of around 90% for nouns with strongly distinct senses..</S>
			<S sid ="235" ssid = "235">This algorithm uses the tagger in two ways: (i) to determine the part of speech of the target word (filtering out the non-noun usages) and (ii) as a step in the phrase recognition analysis of the context surrounding the noun.</S>
			<S sid ="236" ssid = "236">6.3 Grammatical Function Assignment The phrase recognizers also provide input to a system, Sopa [Sibun, 1991], which recognizes nominal arguments of verbs, specifically, Subject, Object, and Predicative Arguments.</S>
			<S sid ="237" ssid = "237">Sopa does not rely on information (such as arity or voice) specific to the particular verbs involved.</S>
			<S sid ="238" ssid = "238">The first step in assigning grammatical functions is to partition the tag sequence of each sentence into phrases.</S>
			<S sid ="239" ssid = "239">The phrase types include those mentioned in section 6.1, additional types to account for conjunctions, complementizers, and indicators of sentence boundaries, and an &quot;unknown&quot; type.</S>
			<S sid ="240" ssid = "240">After a sentence has been partitioned, each simple noun phrase is examined in the context of the phrase to its left and the phrase to its right.</S>
			<S sid ="241" ssid = "241">On the basis of this local context and a set of rules, the noun phrase is marked as a syntactic Subject, Object, Predicative, or is not marked at all.</S>
			<S sid ="242" ssid = "242">A label of Predicative is assigned only if it can be determined that the governing verb group is a form of a predicating verb (e.g., a form of &quot;be&quot;).</S>
			<S sid ="243" ssid = "243">Because this cannot always be determined, some Predicatives are labeled Objects.</S>
			<S sid ="244" ssid = "244">If a noun phrase is labeled, it is also annotated as to whether the governing verb is the closest verb group to the right or to the left.</S>
			<S sid ="245" ssid = "245">The algorithm has an accuracy of approximately 800&quot;/o in assigning grammatical functions..</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="246" ssid = "246">We would like to thank Marti Hearst for her contributions to this paper, Lauri Karttunen and Annie Zaenen for their work on lexicons, and Kris Halvorsen for supporting this project.</S>
	</SECTION>
</PAPER>
