<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">This article concerns the estimation of a particular kind of probability, namely, the probability of a noun sense appearing as a particular argument of a predicate.</S>
		<S sid ="2" ssid = "2">In order to overcome the accompanying sparse-data problem, the proposal here is to define the probabilities in terms of senses from a semantic hierarchy and exploit the fact that the senses can be grouped into classes consisting of semantically similar senses.</S>
		<S sid ="3" ssid = "3">There is a particular focus on the problem of how to determine a suitable class for a given sense, or, alternatively, how to determine a suitable level of generalization in the hierarchy.</S>
		<S sid ="4" ssid = "4">A procedure is developed that uses a chi-square test to determine a suitable level of generalization.</S>
		<S sid ="5" ssid = "5">In order to test the performance of the estimation method, a pseudo-disambiguation task is used, together with two alternative estimation methods.</S>
		<S sid ="6" ssid = "6">Each method uses a different generalization procedure; the first alternative uses the minimum description length principle, and the second uses Resnik’s measure of selectional preference.</S>
		<S sid ="7" ssid = "7">In addition, the performance of our method is investigated using both the standard Pearson chi- square statistic and the log-likelihood chi-square statistic.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="8" ssid = "8">This article concerns the problem of how to estimate the probabilities of noun senses appearing as particular arguments of predicates.</S>
			<S sid ="9" ssid = "9">Such probabilities can be useful for a variety of natural language processing (NLP) tasks, such as structural disambiguation and statistical parsing, word sense disambiguation, anaphora resolution, and language modeling.</S>
			<S sid ="10" ssid = "10">To see how such knowledge can be used to resolve structural ambiguities, consider the following prepositional phrase attachment ambiguity: Example 1 Fred ate strawberries with a spoon.</S>
			<S sid ="11" ssid = "11">The ambiguity arises because the prepositional phrase with a spoon can attach to either strawberries or ate.</S>
			<S sid ="12" ssid = "12">The ambiguity can be resolved by noting that the correct sense of spoon is more likely to be an argument of “ate-with” than “strawberries-with” (Li and Abe 1998; Clark and Weir 2000).</S>
			<S sid ="13" ssid = "13">The problem with estimating a probability model defined over a large vocabulary of predicates and noun senses is that this involves a huge number of parameters, which results in a sparse-data problem.</S>
			<S sid ="14" ssid = "14">In order to reduce the number of parameters, we propose to define a probability model over senses in a semantic hierarchy and ∗ Division of Informatics, University of Edinburgh, 2 Buccleuch Place, Edinburgh, EH8 9LW, UK.</S>
			<S sid ="15" ssid = "15">Email: stephenc@cogsci.ed.ac.uk.</S>
			<S sid ="16" ssid = "16">† School of Cognitive and Computing Sciences, University of Sussex, Brighton, BN1 9QH, UK.</S>
			<S sid ="17" ssid = "17">Email: david.weir@cogs.susx.ac.uk.</S>
			<S sid ="18" ssid = "18">Qc 2002 Association for Computational Linguistics to exploit the fact that senses can be grouped into classes consisting of semantically similar senses.</S>
			<S sid ="19" ssid = "19">The assumption underlying this approach is that the probability of a particular noun sense can be approximated by a probability based on a suitably chosen class.</S>
			<S sid ="20" ssid = "20">For example, it seems reasonable to suppose that the probability of (the food sense of) chicken appearing as an object of the verb eat can be approximated in some way by a probability based on a class such as FOOD.</S>
			<S sid ="21" ssid = "21">There are two elements involved in the problem of using a class to estimate the probability of a noun sense.</S>
			<S sid ="22" ssid = "22">First, given a suitably chosen class, how can that class be used to estimate the probability of the sense?</S>
			<S sid ="23" ssid = "23">And second, given a particular noun sense, how can a suitable class be determined?</S>
			<S sid ="24" ssid = "24">This article offers novel solutions to both problems, and there is a particular focus on the second question, which can be thought of as how to find a suitable level of generalization in the hierarchy.1 The semantic hierarchy used here is the noun hierarchy of WordNet (Fellbaum 1998), version 1.6.</S>
			<S sid ="25" ssid = "25">Previous work has considered how to estimate probabilities using classes from WordNet in the context of acquiring selectional preferences (Resnik 1998; Ribas 1995; Li and Abe 1998; McCarthy 2000), and this previous work has also addressed the question of how to determine a suitable level of generalization in the hierarchy.</S>
			<S sid ="26" ssid = "26">Li and Abe use the minimum description length principle to obtain a level of generalization, and Resnik uses a simple technique based on a statistical measure of selectional preference.</S>
			<S sid ="27" ssid = "27">(The work by Ribas builds on that by Resnik, and the work by McCarthy builds on that by Li and Abe.)</S>
			<S sid ="28" ssid = "28">We compare our estimation method with those of Resnik and Li and Abe, using a pseudo-disambiguation task.</S>
			<S sid ="29" ssid = "29">Our method outperforms these alternatives on the pseudo-disambiguation task, and an analysis of the results shows that the generalization methods of Resnik and Li and Abe appear to be overgeneralizing, at least for this task.</S>
			<S sid ="30" ssid = "30">Note that the problem being addressed here is the engineering problem of estimating predicate argument probabilities, with the aim of producing estimates that will be useful for NLP applications.</S>
			<S sid ="31" ssid = "31">In particular, we are not addressing the problem of acquiring selectional restrictions in the way this is usually construed (Resnik 1993; Ribas 1995; McCarthy 1997; Li and Abe 1998; Wagner 2000).</S>
			<S sid ="32" ssid = "32">The purpose of using a semantic hierarchy for generalization is to overcome the sparse data problem, rather than find a level of abstraction that best represents the selectional restrictions of some predicate.</S>
			<S sid ="33" ssid = "33">This point is considered further in Section 5.</S>
			<S sid ="34" ssid = "34">The next section describes the noun hierarchy from WordNet and gives a more precise description of the probabilities to be estimated.</S>
			<S sid ="35" ssid = "35">Section 3 shows how a class from WordNet can be used to estimate the probability of a noun sense.</S>
			<S sid ="36" ssid = "36">Section 4 shows how a chi-square test is used as part of the generalization procedure, and Section 5 describes the generalization procedure.</S>
			<S sid ="37" ssid = "37">Section 6 describes the alternative class-based estimation methods used in the pseudo-disambiguation experiments, and Section 7 presents those experiments.</S>
	</SECTION>
	<SECTION title="The Semantic Hierarchy. " number = "2">
			<S sid ="38" ssid = "1">The noun hierarchy of WordNet consists of senses, or what Miller (1998) calls lexicalized concepts, organized according to the “is-a-kind-of” relation.</S>
			<S sid ="39" ssid = "2">Note that we are using concept to refer to a lexicalized concept or sense and not to a set of senses; we use class to refer to a set of senses.</S>
			<S sid ="40" ssid = "3">There are around 66,000 different concepts in the noun hierarchy 1 A third element of the problem, namely, how to obtain arguments of predicates as training data, is not considered here.</S>
			<S sid ="41" ssid = "4">We assume the existence of such data, obtained from a treebank or shallow parser.</S>
			<S sid ="42" ssid = "5">188 of WordNet version 1.6.</S>
			<S sid ="43" ssid = "6">A concept in WordNet is represented by a “synset,” which is the set of synonymous words that can be used to denote that concept.</S>
			<S sid ="44" ssid = "7">For example, 2 the synset for the concept (cocaine) is { cocaine, cocain, coke, snow, C }.</S>
			<S sid ="45" ssid = "8">Let syn(c) be the synset for concept c, and let cn(n)= { c | n ∈ syn(c) } be the set of concepts that can be denoted by noun n. The hierarchy has the structure of a directed acyclic graph (although only around 1% of the nodes have more than one parent), where the edges of the graph constitute what we call the “direct–isa” relation.</S>
			<S sid ="46" ssid = "9">Let isa be the transitive, reflexive closure of direct–isa; then cl isa c implies cl is a kind of c. If cl isa c, then c is a hypernym of cl and cl is a hyponym of c. In fact, the hierarchy is not a single hierarchy but instead consists of nine separate subhierarchies, each headed by the most general kind of concept, such as (entity), (abstraction), (event), and (psychological feature).</S>
			<S sid ="47" ssid = "10">For the purposes of this work we add a common root dominating the nine subhierarchies, which we denote (root).</S>
			<S sid ="48" ssid = "11">There are some important points that need to be clarified regarding the hierarchy.</S>
			<S sid ="49" ssid = "12">First, every concept in the hierarchy has a nonempty synset (except the notional con cept (root)).</S>
			<S sid ="50" ssid = "13">Even the most general concepts, such as (entity), can be denoted by some noun; the synset for (entity) is { entity, something }.</S>
			<S sid ="51" ssid = "14">Second, there is an important distinc tion between an individual concept and a set of concepts.</S>
			<S sid ="52" ssid = "15">For example, the individual concept (entity) should not be confused with the set or class consisting of concepts denoting kinds of entities.</S>
			<S sid ="53" ssid = "16">To make this distinction clear, we use c = { cl | cl isa c } to denote the set of concepts dominated by concept c, including c itself.</S>
			<S sid ="54" ssid = "17">For example, (animal) is the set consisting of those concepts corresponding to kinds of animals (including (animal) itself).</S>
			<S sid ="55" ssid = "18">The probability of a concept appearing as an argument of a predicate is written p(c | v, r), where c is a concept in WordNet, v is a predicate, and r is an argument position.3 The focus in this article is on the arguments of verbs, but the techniques discussed can be applied to any predicate that takes nominal arguments, such as adjectives.</S>
			<S sid ="56" ssid = "19">The probability p(c | v, r) is to be interpreted as follows: This is the probability that some noun n in syn(c), when denoting concept c, appears in position r of verb v (given v and r).</S>
			<S sid ="57" ssid = "20">The example used throughout the article is p((dog) | run, subj), which is the conditional probability that some noun in the synset of (dog), when denoting the concept (dog), appears in the subject position of the verb run.</S>
			<S sid ="58" ssid = "21">Note that, in practice, no distinction is made between the different senses of a verb (although the techniques do allow such a distinction) and that each use of a noun is assumed to correspond to exactly one concept.4</S>
	</SECTION>
	<SECTION title="Class-Based Probability Estimation. " number = "3">
			<S sid ="59" ssid = "1">This section explains how a set of concepts, or class, from WordNet can be used to estimate the probability of an individual concept.</S>
			<S sid ="60" ssid = "2">More specifically, we explain how a set of concepts cl, where cl is some hypernym of concept c, can be used to estimate p(c | v, r).</S>
			<S sid ="61" ssid = "3">(Recall that cl denotes the set of concepts dominated by cl, including cl itself.)</S>
			<S sid ="62" ssid = "4">One possible approach would be simply to substitute cl for the individual concept c. This is a poor solution, however, since p(cl | v, r) is the conditional probability that 2 Angled brackets are used to denote concepts in the hierarchy..</S>
			<S sid ="63" ssid = "5">3 The term predicate is used loosely here, in that the predicate does not have to be a semantic object but.</S>
			<S sid ="64" ssid = "6">can simply be a word form.</S>
			<S sid ="65" ssid = "7">4 A recent paper that extends the acquisition of selectional preferences to sense-sense relationships is Agirre and Martinez (2001).</S>
			<S sid ="66" ssid = "8">189 some noun denoting a concept in cl appears in position r of verb v. For example, p((animal) | run, subj) is the probability that some noun denoting a kind of animal appears in the subject position of the verb run.</S>
			<S sid ="67" ssid = "9">Probabilities of sets of concepts are obtained by summing over the concepts in the set: p(cl | v, r)= , p(cll | v, r) (1) cII∈cI This means that p((animal) | run, subj) is likely to be much greater than p((dog) | run, subj) and thus is not a good approximation of p((dog)| run, subj).</S>
			<S sid ="68" ssid = "10">What can be done, though, is to condition on sets of concepts.</S>
			<S sid ="69" ssid = "11">If it can be shown that p(v | cl, r), for some hypernym cl of c, is a reasonable approximation of p(v | c, r), then we have a way of estimating p(c | v, r).</S>
			<S sid ="70" ssid = "12">The probability p(v | c, r) can be obtained from p(c | v, r) using Bayes’ theorem: p(c | r) p(c | v, r)= p(v | c, r) p(v (2) | r) Since p(c | r) and p(v | r) are conditioned on the argument slot only, we assume these can be estimated satisfactorily using relative frequency estimates.</S>
			<S sid ="71" ssid = "13">Alternatively, a standard smoothing technique such as Good-Turing could be used.5 This leaves p(v | c, r).</S>
			<S sid ="72" ssid = "14">Continuing with the (dog) example, the proposal is to estimate p(run | (dog), subj) using a relative-frequency estimate of p(run | (animal), subj) or an estimate based on a similar, suitably chosen class.</S>
			<S sid ="73" ssid = "15">Thus, assuming this choice of class, p((dog) | run, subj) would be approximated as follows: p((dog)| subj) p((dog)| run, subj) ≈ p(run | (animal), subj) p(run (3) | subj) The following derivation shows that if p(v | cl, r) = k for each child cl of cl, and i i p(v | cl, r)= k, then p(v | cl, r) is also equal to k: p(v | r) p(v | cl, r) = p(cl | v, r) p(c (4) r) p(v | r) ( \ = , p(cl | v, r)+ p(cl | v, r) (5) p(cl | r) i p(v | r) ( p(cl | r) p(cl | r)\ = p(cl | r) 1 , p(v | cl, r) i ( i p(v | r) + p(v | cl, r) \ p(v | r) (6) = , k p(cl | r)+ k p(cl | r) (7) p(cl | r) i k ( \ = , p(cl | r)+ p(cl | r) (8) p(cl | r) i = k (9) 5 Unsmoothed estimates were used in this work..</S>
			<S sid ="74" ssid = "16">190 Note that the proof applies only to a tree, since the proof assumes that cl is partitioned by cl and the sets of concepts dominated by each of the daughters of cl, which is not necessarily true for a directed acyclic graph (DAG).</S>
			<S sid ="75" ssid = "17">WordNet is a DAG but is a close approximation to a tree, and so we assume this will not be a problem in practice.6 The derivation in (4)–(9) shows how probabilities conditioned on sets of concepts can remain constant when moving up the hierarchy, and this suggests a way of finding a suitable set, cl, as a generalization for concept c: Initially set cl equal to c and move up the hierarchy, changing the value of cl, until there is a significant change in p(v | cl, r).</S>
			<S sid ="76" ssid = "18">Estimates of p(v | cl, r), for each child cl of cl, can be compared to see whether i i p(v | cl, r) has significantly changed.</S>
			<S sid ="77" ssid = "19">(We ignore the probability p(v | cl, r) and consider the probabilities p(v | cl, r) only.)</S>
			<S sid ="78" ssid = "20">Note that this procedure rests on the assumption that p(v | c, r) is close to p(v | c, r).</S>
			<S sid ="79" ssid = "21">(In fact, p(v | c, r) is equal to p(v | c, r) when c is a leaf node.)</S>
			<S sid ="80" ssid = "22">So when finding a suitable level for the estimation of p((sandwich) | eat, obj), for example, we first assume that p(eat | (sandwich), obj) is a good approximation of p(eat | (sandwich), obj) and then apply the procedure to p(eat | (sandwich), obj).</S>
			<S sid ="81" ssid = "23">A feature of the proposed generalization procedure is that comparing probabilities of the form p(v | C, r), where C is a class, is closely related to comparing ratios of probabilities of the form p(C | v, r)/p(C | r) (for a given verb and argument position): p(C | v, r) p(v | C, r)= p(C p(v r) (10) | r) Note that, for a given verb and argument position, p(v | r) is constant across classes.</S>
			<S sid ="82" ssid = "24">Equation (10) is of interest because the ratio p(C | v, r)/p(C | r) can be interpreted as a measure of association between the verb v and class C. This ratio is similar to point- wise mutual information (Church and Hanks 1990) and also forms part of Resnik’s association score, which will be introduced in Section 6.</S>
			<S sid ="83" ssid = "25">Thus the generalization procedure can be thought of as one that finds “homogeneous” areas of the hierarchy, that is, areas consisting of classes that are associated to a similar degree with the verb (Clark and Weir 1999).</S>
			<S sid ="84" ssid = "26">Finally, we note that the proposed estimation method does not guarantee that the estimates form a probability distribution over the concepts in the hierarchy, and so a normalization factor is required: psc(c | v, r)= ˆp(v [c, v, r], r) ˆp(c|r) ˆp(v|r) cI∈C ˆp(v | [cl, v, r], r) ˆp(v|r) (11) We use psc to denote an estimate obtained using our method (since the technique finds sets of semantically similar senses, or “similarity classes”) and [c, v, r] to denote the class chosen for concept c in position r of verb v; ˆp denotes a relative frequency estimate, and C denotes the set of concepts in the hierarchy.</S>
			<S sid ="85" ssid = "27">Before providing the details of the generalization procedure, we give the relative- frequency estimates of the relevant probabilities and deal with the problem of am 6 Li and Abe (1998) also develop a theoretical framework that applies only to a tree and turn WordNet.</S>
			<S sid ="86" ssid = "28">into a tree by copying each subgraph with multiple parents.</S>
			<S sid ="87" ssid = "29">One way to extend the experiments in Section 7 would be to investigate whether this transformation has an impact on the results of those experiments.</S>
			<S sid ="88" ssid = "30">191 biguous data.</S>
			<S sid ="89" ssid = "31">The relative-frequency estimates are as follows: ˆp(c | r) = f (c,r) = ),vI∈V f (c, vl, r) (12) f (r) ),v c l l ˆp(v | r) = f (v,r) I∈V ), I∈C f (c , v , r) = ),cI∈C f (cl, v, r) (13) f (r) ),v c l l I∈V ), I∈C f (c , v , r) ),cII∈cI f (cll, v, r) ˆp(v | cl, r) = f (cI ,v,r) = (14) f (cI ,r) ),vI∈V ),cII∈cI f (cll, vl, r) where f (c, v, r) is the number of (n, v, r) triples in the data in which n is being used to denote c, and V is the set of verbs in the data.</S>
			<S sid ="90" ssid = "32">The problem is that the estimates are defined in terms of frequencies of senses, whereas the data are assumed to be in the form of (n, v, r) triples: a noun, verb, and argument position.</S>
			<S sid ="91" ssid = "33">All the data used in this work have been obtained from the British National Corpus (BNC), using the system of Briscoe and Carroll (1997), which consists of a shallow-parsing component that is able to identify verbal arguments.</S>
			<S sid ="92" ssid = "34">We take a simple approach to the problem of estimating the frequencies of senses, by distributing the count for each noun in the data evenly among all senses of the noun: ˆf (c, v, r)= , n∈syn(c) f (n, v, r) |cn(n)| (15) where ˆf (c, v, r) is an estimate of the number of times that concept c appears in position r of verb v, and |cn(n)| is the cardinality of cn(n).</S>
			<S sid ="93" ssid = "35">This is the approach taken by Li and Abe (1998), Ribas (1995), and McCarthy (2000).7 Resnik (1998) explains how this apparently crude technique works surprisingly well.</S>
			<S sid ="94" ssid = "36">Alternative approaches are described in Clark and Weir (1999) (see also Clark [2001]), Abney and Light (1999), and Ciaramita and Johnson (2000).</S>
	</SECTION>
	<SECTION title="Using a Chi-Square Test to Compare  Probabilities. " number = "4">
			<S sid ="95" ssid = "1">In this section we show how to test whether p(v | cl, r) changes significantly when considering a node higher in the hierarchy.</S>
			<S sid ="96" ssid = "2">Consider the problem of deciding whether p(run | (canine), subj) is a good approximation of p(run | (dog), subj).</S>
			<S sid ="97" ssid = "3">((canine) is the parent of (dog) in WordNet.)</S>
			<S sid ="98" ssid = "4">To do this, the probabilities p(run | cl, subj) are compared using a chi-square test, where the cl are the children of ( ).</S>
			<S sid ="99" ssid = "5">In this case, the null i hypothesis of the test is that the probabilities canine p(run | ci, subj) are the same for each child ci.</S>
			<S sid ="100" ssid = "6">By judging the strength of the evidence against the null hypothesis, how similar the true probabilities are likely to be can be determined.</S>
			<S sid ="101" ssid = "7">If the test indicates that the probabilities are sufficiently unlikely to be the same, then the null hypothesis is rejected, and the conclusion is that p(run | (canine), subj) is not a good approximation of p(run | (dog), subj).</S>
			<S sid ="102" ssid = "8">An example contingency table, based on counts obtained from a subset of the BNC using the system of Briscoe and Carroll, is given in Table 1.</S>
			<S sid ="103" ssid = "9">(Recall that the frequencies are estimated by distributing the count for a noun equally among the noun’s senses; this explains the fractional counts.)</S>
			<S sid ="104" ssid = "10">One column contains estimates of counts arising 7 Resnik takes a similar approach but divides the count evenly among the noun’s senses and all the.</S>
			<S sid ="105" ssid = "11">hypernyms of those senses.</S>
			<S sid ="106" ssid = "12">192 Contingency table for the children of (canine) in the subject position of run.</S>
			<S sid ="107" ssid = "13">ci ˆf(ci, run, subj) ˆf(ci, subj) ˆf(ci, run, subj) ˆf(ci, subj)= ), ∈V ˆf(ci, v, subj) (bitch) 0.3 (0.5) 26.7 (26.6) 27.0 (dog) 12.8 (10.5) 620.4 (622.7) 633.2 (wolf) 0.3 (0.6) 38.7 (38.4) 39.0 (jackal) 0.0 (0.3) 20.0 (19.7) 20.0 (wild dog) 0.0 (0.0) 3.0 (3.0) 3.0 (hyena) 0.0 (0.2) 10.0 (9.8) 10.0 (fox) 0.0 (1.2) 72.3 (71.1) 72.3 13.4 791.1 804.5 from concepts in ci appearing in the subject position of the verb run: ˆf (ci, run, subj).</S>
			<S sid ="108" ssid = "14">A second column presents estimates of counts arising from concepts in ci appearing in the subject position of a verb other than run.</S>
			<S sid ="109" ssid = "15">The figures in brackets are the expected values if the null hypothesis is true.</S>
			<S sid ="110" ssid = "16">There is a choice of which statistic to use in conjunction with the chi-square test.</S>
			<S sid ="111" ssid = "17">The usual statistic encountered in textbooks is the Pearson chi-square statistic, denoted X2: (oij − eij)2 eij (16) i,j where oij is the observed value for the cell in row i and column j, and eij is the corresponding expected value.</S>
			<S sid ="112" ssid = "18">An alternative statistic is the log-likelihood chi-square statistic, denoted G2:8 G2 = 2 , oij log oij (17) i,j e eij The two statistics have similar values when the counts in the contingency table are large (Agresti 1996).</S>
			<S sid ="113" ssid = "19">The statistics behave differently, however, when the table contains low counts, and, since corpus data are likely to lead to some low counts, the question of which statistic to use is an important one.</S>
			<S sid ="114" ssid = "20">Dunning (1993) argues for the use of G2 rather than X2, based on an analysis of the sampling distributions of G2 and X2, and results obtained when using the statistics to acquire highly associated bigrams.</S>
			<S sid ="115" ssid = "21">We consider Dunning’s analysis at the end of this section, and the question of whether to use G2 or X2 will be discussed further there.</S>
			<S sid ="116" ssid = "22">For now, we continue with the discussion of how the chi-square test is used in the generalization procedure.</S>
			<S sid ="117" ssid = "23">For Table 1, the value of G2 is 3.8, and the value of X2 is 2.5.</S>
			<S sid ="118" ssid = "24">Assuming a level of significance of α = 0.05, the critical value is 12.6 (for six degrees of freedom).</S>
			<S sid ="119" ssid = "25">Thus, for this α value, the null hypothesis would not be rejected for either statistic, and the conclusion would be that there is no reason to suppose that p(run | (canine), subj) is not a reasonable approximation of p(run | (dog), subj).</S>
			<S sid ="120" ssid = "26">8 An alternative formula for G2 is given in Dunning (1993), but the two are equivalent..</S>
			<S sid ="121" ssid = "27">193 Contingency table for the children of (liquid) in the object position of drink.</S>
			<S sid ="122" ssid = "28">ci ˆf(ci, drink, obj) ˆf(ci, obj) ˆf (ci, drink, obj) ˆf(ci, obj)= ), ∈V ˆf(ci, v, obj) (beverage) 261.0 (238.7) 2,367.7 (2,390.0) 2,628.7 (supernatant) 0.0 (0.1) 1.0 (0.9) 1.0 (alcohol) 11.5 (9.4) 92.0 (94.1) 103.5 (ammonia) 0.0 (0.8) 8.5 (7.7) 8.5 (antifreeze) 0.0 (0.1) 1.0 (0.9) 1.0 (distillate) 0.0 (0.5) 6.0 (5.5) 6.0 (water) 12.0 (31.6) 335.7 (316.1) 347.7 (ink) 0.0 (2.9) 32.0 (29.1) 32.0 (liquor) 0.7 (1.1) 11.6 (11.2) 12.3 285.2 2,855.5 3,140.7 As a further example, Table 2 gives counts for the children of (liquid) in the object position of drink.</S>
			<S sid ="123" ssid = "29">Again, the counts have been obtained from a subset of the BNC using the system of Briscoe and Carroll.</S>
			<S sid ="124" ssid = "30">Not all the sets dominated by the children of (liquid) are shown, as some, such as (sheep dip), never appear in the object position of a verb in the data.</S>
			<S sid ="125" ssid = "31">This example is designed to show a case in which the null hypothesis is rejected.</S>
			<S sid ="126" ssid = "32">The value of G2 for this table is 29.0, and the value of X2 is 21.2.</S>
			<S sid ="127" ssid = "33">So for G2, even if an α value as low as 0.0005 were being used (for which the critical value is 27.9 for eight degrees of freedom), the null hypothesis would still be rejected.</S>
			<S sid ="128" ssid = "34">For X2, the null hypothesis is rejected for α values greater than 0.005.</S>
			<S sid ="129" ssid = "35">This seems reasonable, since the probabilities associated with the children of (liquid) and the object position of drink would be expected to show a lot of variation across the children.</S>
			<S sid ="130" ssid = "36">A key question is how to select the appropriate value for α.</S>
			<S sid ="131" ssid = "37">One solution is to treat α as a parameter and set it empirically by taking a held-out test set and choosing the value of α that maximizes performance on the relevant task.</S>
			<S sid ="132" ssid = "38">For example, Clark and Weir (2000) describes a prepositional phrase attachment algorithm that employs probability estimates obtained using the WordNet method described here.</S>
			<S sid ="133" ssid = "39">To set the value of α, the performance of the algorithm on a development set could be compared across different values of α, and the value that leads to the best performance could be chosen.</S>
			<S sid ="134" ssid = "40">Note that this approach sets no constraints on the value of α: The value could be as high as 0.995 or as low as 0.0005, depending on the particular application.</S>
			<S sid ="135" ssid = "41">There may be cases in which the conditions for the appropriate application of a chi- square test are not met.</S>
			<S sid ="136" ssid = "42">One condition that is likely to be violated is the requirement that expected values in the contingency table not be too small.</S>
			<S sid ="137" ssid = "43">(A rule of thumb often found in textbooks is that the expected values should be greater than five.)</S>
			<S sid ="138" ssid = "44">One response to this problem is to apply some kind of thresholding and either ignore counts below the threshold, or apply the test only to tables that do not contain low counts.</S>
			<S sid ="139" ssid = "45">Ribas (1995), Li and Abe (1998), McCarthy (2000), and Wagner (2000) all use some kind of thresholding when dealing with counts in the hierarchy (although not in the context of a chi-square test).</S>
			<S sid ="140" ssid = "46">Another approach would be to use Fisher’s exact test (Agresti 1996; Pedersen 1996), which can be applied to tables regardless of the size of 194 the counts they contain.</S>
			<S sid ="141" ssid = "47">The main problem with this test is that it is computationally expensive, especially for large contingency tables.</S>
			<S sid ="142" ssid = "48">What we have found in practice is that applying the chi-square test to tables dominated by low counts tends to produce an insignificant result, and the null hypothesis is not rejected.</S>
			<S sid ="143" ssid = "49">The consequences of this for the generalization procedure are that low count tables tend to result in the procedure moving up to the next node in the hierarchy.</S>
			<S sid ="144" ssid = "50">But given that the purpose of the generalization is to overcome the sparse- data problem, moving up a node is desirable, and therefore we do not modify the test for tables with low counts.</S>
			<S sid ="145" ssid = "51">The final issue to consider is which chi-square statistic to use.</S>
			<S sid ="146" ssid = "52">Dunning (1993) argues for the use of G2 rather than X2, based on the claim that the sampling distribution of G2 approaches the true chi-square distribution quicker than the sampling distribution of X2.</S>
			<S sid ="147" ssid = "53">However, Agresti (1996, page 34) makes the opposite claim: “The sampling distributions of X2 and G2 get closer to chi-squared as the sample size n increases....</S>
			<S sid ="148" ssid = "54">The convergence is quicker for X2 than G2.” In addition, Pedersen (2001) questions whether one statistic should be preferred over the other for the bigram acquisition task and cites Cressie and Read (1984), who argue that there are some cases where the Pearson statistic is more reliable than the log-likelihood statistic.</S>
			<S sid ="149" ssid = "55">Finally, the results of the pseudo-disambiguation experiments presented in Section 7 are at least as good, if not better, when using X2 rather than G2, and so we conclude that the question of which statistic to use should be answered on a per application basis.</S>
	</SECTION>
	<SECTION title="The Generalization Procedure. " number = "5">
			<S sid ="150" ssid = "1">The procedure for finding a suitable class, cl, to generalize concept c in position r of verb v works as follows.</S>
			<S sid ="151" ssid = "2">(We refer to cl as the “similarity class” of c with respect to v and r and the hypernym cl as top(c, v, r), since the chosen hypernym sits at the “top” of the similarity class.)</S>
			<S sid ="152" ssid = "3">Initially, concept c is assigned to a variable top.</S>
			<S sid ="153" ssid = "4">Then, by working up the hierarchy, successive hypernyms of c are assigned to top, and this process continues until the probabilities associated with the sets of concepts dominated by top and the siblings of top are significantly different.</S>
			<S sid ="154" ssid = "5">Once a node is reached that results in a significant result for the chi-square test, the procedure stops, and top is returned as top(c, v, r).</S>
			<S sid ="155" ssid = "6">In cases where a concept has more than one parent, the parent is chosen that results in the lowest value of the chi-square statistic, as this indicates the probabilities are the most similar.</S>
			<S sid ="156" ssid = "7">The set top(c, v, r) is the similarity class of c for verb v and position r. Figure 1 gives an algorithm for determining top(c, v, r).</S>
			<S sid ="157" ssid = "8">Figure 2 gives an example of the procedure at work.</S>
			<S sid ="158" ssid = "9">Here, top((soup), stir, obj) is being determined.</S>
			<S sid ="159" ssid = "10">The example is based on data from a subset of the BNC, with 303 cases of an argument in the object position of stir.</S>
			<S sid ="160" ssid = "11">The G2 statistic is used, together with an α value of 0.05.</S>
			<S sid ="161" ssid = "12">Initially, top is set to (soup), and the probabilities corresponding to the children of (dish) are compared: p(stir | (soup), obj), p(stir | (lasagne), obj), p(stir | (haggis), obj), and so on for the rest of the children.</S>
			<S sid ="162" ssid = "13">The chi-square test results in a G2 value of 14.5, compared to a critical value of 55.8.</S>
			<S sid ="163" ssid = "14">Since G2 is less than the critical value, the procedure moves up to the next node.</S>
			<S sid ="164" ssid = "15">This process continues until a significant result is obtained, which first occurs at (substance) when comparing the children of (object).</S>
			<S sid ="165" ssid = "16">Thus (substance) is the chosen level of generalization.</S>
			<S sid ="166" ssid = "17">Now we show how the chosen level of generalization varies with α and how it varies with the size of the data set.</S>
			<S sid ="167" ssid = "18">A note of clarification is required before presenting the results.</S>
			<S sid ="168" ssid = "19">In related work on acquiring selectional preferences (Ribas 1995; McCarthy 195 Algorithm top(c, v, r): top ← c sig result ← false comment parentmin gives lowest G2 value, G2 while not sig result &amp; top /= (root) do 2 min ←∞ for all parents of top do calculate G2 for sets dominated by children of parent if G2 &lt; G2 then G2 ← G2 parent end pare ntmi n ← end if chi squar e test for paren tmin is signif icant the n sig res ult ← tru e else move up to next node: top ← paren tmin return top Figure 1 An algorithm for determining top(c, v, r).</S>
			<S sid ="169" ssid = "20">u+ +A + u + + 31 1 u u w u+ w J J u Figure 2 An example generalization: Determining top((soup), stir, obj).</S>
			<S sid ="170" ssid = "21">196 1997; Li and Abe 1998; Wagner 2000), the level of generalization is often determined for a small number of handpicked verbs and the result compared with the researcher’s intuition about the most appropriate level for representing a selectional preference.</S>
			<S sid ="171" ssid = "22">According to this approach, if (sandwich) were chosen to represent (hotdog) in the object position of eat, this might be considered an undergeneralization, since (food) might be considered more appropriate.</S>
			<S sid ="172" ssid = "23">For this work we argue that such an evaluation is not appropriate; since the purpose of this work is probability estimation, the most appropriate level is the one that leads to the most accurate estimate, and this may or may not agree with intuition.</S>
			<S sid ="173" ssid = "24">Furthermore, we show in Section 7 that to generalize unnecessarily can be harmful for some tasks: If we already have lots of data regarding (sandwich), why generalize any higher?</S>
			<S sid ="174" ssid = "25">Thus the purpose of this section is not to show that the acquired levels are “correct,” but simply to show how the levels vary with α and the sample size.</S>
			<S sid ="175" ssid = "26">To show how the level of generalization varies with changes in α, top(c, v, obj) was determined for a number of handpicked (c, v, obj) triples over a range of values for α.</S>
			<S sid ="176" ssid = "27">The triples were chosen to give a range of strongly and weakly selecting verbs and a range of verb frequencies.</S>
			<S sid ="177" ssid = "28">The data were again extracted from a subset of the BNC using the system of Briscoe and Carroll (1997), and the G2 statistic was used in the chi-square test.</S>
			<S sid ="178" ssid = "29">The results are shown in Table 3.</S>
			<S sid ="179" ssid = "30">The number of times the verb occurred with some object is also given in the table.</S>
			<S sid ="180" ssid = "31">The results suggest that the generalization level becomes more specific as α increases.</S>
			<S sid ="181" ssid = "32">This is to be expected, since, given a contingency table chosen at random, a higher value of α is more likely to lead to a significant result than a lower value of α.</S>
			<S sid ="182" ssid = "33">We also see that, for some cases, the value of α has little effect on the level.</S>
			<S sid ="183" ssid = "34">We would expect there to be less change in the level of generalization for strongly selecting verbs, such as drink and eat, and a greater range of levels for weakly selecting verbs such as see.</S>
			<S sid ="184" ssid = "35">This is because any significant difference in probabilities is likely to be more marked for a strongly selecting verb, and likely to be significant over a wider range of α values.</S>
			<S sid ="185" ssid = "36">The table only provides anecdotal evidence, but provides some support to this argument.</S>
			<S sid ="186" ssid = "37">To investigate more generally how the level of generalization varies with changes in α, and also with changes in sample size, we took 6, 000 (c, v, obj) triples and calculated the difference in depth between c and top(c, v, r) for each triple.</S>
			<S sid ="187" ssid = "38">The 6, 000 triples were taken from the first experimental test set described in Section 7, and the training data from this experiment were used to provide the counts.</S>
			<S sid ="188" ssid = "39">(The test set contains nouns, rather than noun senses, and so the sense of the noun that is most probable given the verb and object slot was used.)</S>
			<S sid ="189" ssid = "40">An average difference in depth was then calculated.</S>
			<S sid ="190" ssid = "41">To give an example of how the difference in depth was calculated, suppose (dog) generalized to (placental mammal) via (canine) and (carnivore); in this case the difference would be three.</S>
			<S sid ="191" ssid = "42">The results for various levels of α and different sample sizes are shown in Table 4.</S>
			<S sid ="192" ssid = "43">The figures in each column arise from using the contingency tables based on the complete training data, but with each count in the table multiplied by the percentage at the head of the column.</S>
			<S sid ="193" ssid = "44">Thus the 50% column is based on contingency tables in which each original count is multiplied by 50%, which is equivalent to using a sample one-half the size of the original training set.</S>
			<S sid ="194" ssid = "45">Reading across a row shows how the generalization varies with sample size, and reading down a column shows how it varies with α.</S>
			<S sid ="195" ssid = "46">The results show clearly that the extent of generalization decreases with an increase in the value of α, supporting the trend observed in Table 3.</S>
			<S sid ="196" ssid = "47">The results also show that the extent of generalization increases with a decrease in sample 197 Table 3 Example levels of generalization for different values of α.</S>
			<S sid ="197" ssid = "48">(c, v, r), f(v, r) α ((coffee), drink, obj) 0.0005 (coffee)(BEVERAGE)(food) ...</S>
			<S sid ="198" ssid = "49">(object)(entity) 0.05 (coffee)(BEVERAGE)(food) ...</S>
			<S sid ="199" ssid = "50">(object)(entity) f (drink, obj)= 849 0.5 (coffee)(BEVERAGE)(food) ...</S>
			<S sid ="200" ssid = "51">(object)(entity) 0.995 (coffee)(BEVERAGE)(food) ...</S>
			<S sid ="201" ssid = "52">(object)(entity) ((hotdog), eat, obj) 0.0005 (hotdog)(sandwich)(snack food)(DISH) ...</S>
			<S sid ="202" ssid = "53">(food) ...</S>
			<S sid ="203" ssid = "54">(entity) 0.05 (hotdog)(sandwich)(snack food)(DISH) ...</S>
			<S sid ="204" ssid = "55">(food) ...</S>
			<S sid ="205" ssid = "56">(entity) f (eat, obj)= 1,703 0.5 (hotdog)(sandwich)(snack food)(DISH) ...</S>
			<S sid ="206" ssid = "57">(food) ...</S>
			<S sid ="207" ssid = "58">(entity) 0.995 (hotdog)(SANDWICH)(snack food)(dish) ...</S>
			<S sid ="208" ssid = "59">(food) ...</S>
			<S sid ="209" ssid = "60">(entity) ((Socrates), kiss, obj) 0.0005 (Socrates) ...</S>
			<S sid ="210" ssid = "61">(person)(life form)(CAUSAL AGENT)(entity) 0.05 (Socrates) ...</S>
			<S sid ="211" ssid = "62">(person)(life form)(CAUSAL AGENT)(entity) f (kiss, obj)= 345 0.5 (Socrates) ...</S>
			<S sid ="212" ssid = "63">(person)(life form)(CAUSAL AGENT)(entity) 0.995 (Socrates) ...</S>
			<S sid ="213" ssid = "64">(PERSON)(life form)(causal agent)(entity) ((dream), remember, obj) 0.0005 (dream) ...</S>
			<S sid ="214" ssid = "65">(preoccupation)(cognitive state)(STATE) 0.05 (dream) ...</S>
			<S sid ="215" ssid = "66">(preoccupation)(cognitive state)(STATE) f (remember, obj)= 1,982 0.5 (dream) ...</S>
			<S sid ="216" ssid = "67">(preoccupation)(COGNITIVE STATE)(state) 0.995 (dream) ...</S>
			<S sid ="217" ssid = "68">(PREOCCUPATION)(cognitive state)(state) ((man), see, obj) 0.0005 (man) ...</S>
			<S sid ="218" ssid = "69">(mammal) ...</S>
			<S sid ="219" ssid = "70">(ANIMAL)(life form)(entity) 0.05 (man) ...</S>
			<S sid ="220" ssid = "71">(MAMMAL) ...</S>
			<S sid ="221" ssid = "72">(animal)(life form)(entity) f (see, obj)= 16,757 0.5 (man) ...</S>
			<S sid ="222" ssid = "73">(MAMMAL) ...</S>
			<S sid ="223" ssid = "74">(animal)(life form)(entity) 0.995 (MAN) ...</S>
			<S sid ="224" ssid = "75">(mammal) ...</S>
			<S sid ="225" ssid = "76">(animal)(life form)(entity) ((belief), abandon, obj) 0.0005 (belief)(mental object)(cognition)(PSYCHOLOGICAL FEATURE) 0.05 (belief)(MENTAL OBJECT)(cognition)(psychological feature) f (abandon, obj)= 673 0.5 (BELIEF)(mental object)(cognition)(psychological feature) 0.995 (BELIEF)(mental object)(cognition)(psychological feature) ((nightmare), have, obj) 0.0005 (nightmare)(dreaming)(IMAGINATION) ...</S>
			<S sid ="226" ssid = "77">(psychological feature) 0.05 (nightmare)(dreaming)(IMAGINATION) ...</S>
			<S sid ="227" ssid = "78">(psychological feature) f (have, obj)= 93,683 0.5 (nightmare)(DREAMING)(imagination) ...</S>
			<S sid ="228" ssid = "79">(psychological feature) 0.995 (nightmare)(DREAMING)(imagination) ...</S>
			<S sid ="229" ssid = "80">(psychological feature) Note: The selected level is shown in upper case.</S>
			<S sid ="230" ssid = "81">Table 4 Extent of generalization for different values of α and sample sizes.</S>
			<S sid ="231" ssid = "82">α 100% 50% 10% 1% 0.0005 3.3 3.9 5.0 5.6 0.05 2.8 3.5 4.6 5.6 0.5 2.1 2.9 4.1 5.4 0.995 1.2 1.5 2.6 3.9 size.</S>
			<S sid ="232" ssid = "83">Again, this is to be expected, since any difference in probability estimates is less likely to be significant for tables with low counts.</S>
	</SECTION>
	<SECTION title="Alternative Class-Based Estimation Methods. " number = "6">
			<S sid ="233" ssid = "1">The approaches used for comparison are that of Resnik (1993, 1998), subsequently developed by Ribas (1995), and that of Li and Abe (1998), which has been adopted by McCarthy (2000).</S>
			<S sid ="234" ssid = "2">These have been chosen because they directly address the question of how to find a suitable level of generalization in WordNet.</S>
			<S sid ="235" ssid = "3">198 The first alternative uses the “association score,” which is a measure of how well a set of concepts, C, satisfies the selectional preferences of a verb, v, for an argument position, r:9 p(C | v, r) A(C, v, r)= p(C | v, r) log2 p(C (18) | r) An estimate of the association score, Aˆ (C, v, r), can be obtained using relative frequency estimates of the probabilities.</S>
			<S sid ="236" ssid = "4">The key question is how to determine a suitable level of generalization for concept c, or, alternatively, how to find a suitable class to represent concept c (assuming the choice is from those classes that contain all concepts dominated by some hypernym of c).</S>
			<S sid ="237" ssid = "5">Resnik’s solution to this problem (which he neatly refers to as the “vertical-ambiguity” problem) is to choose the class that maximizes the association score.</S>
			<S sid ="238" ssid = "6">It is not clear that the class with the highest association score is always the most appropriate level of generalization.</S>
			<S sid ="239" ssid = "7">For example, this approach does not always generalize appropriately for arguments that are negatively associated with some verb.</S>
			<S sid ="240" ssid = "8">To see why, consider the problem of deciding how well the concept (location) satisfies the preferences of the verb eat for its object.</S>
			<S sid ="241" ssid = "9">Since locations are not the kinds of things that are typically eaten, a suitable level of generalization would correspond to a class that has a low association score with respect to eat.</S>
			<S sid ="242" ssid = "10">However, (location) is a kind of (entity) in WordNet,10 and choosing the class with the highest association score is likely to produce (entity) as the chosen class.</S>
			<S sid ="243" ssid = "11">This is a problem, because the association score of (entity) with respect to eat may be too high to reflect the fact that (location) is a very unlikely object of the verb.</S>
			<S sid ="244" ssid = "12">Note that the solution to the vertical-ambiguity problem presented in the previous sections is able to generalize appropriately in such cases.</S>
			<S sid ="245" ssid = "13">Continuing with the eat (location) example, our generalization procedure is unlikely to get as high as (entity) (assuming a reasonable number of examples of eat in the training data), since the probabilities corresponding to the daughters of (entity) are likely to be very different with respect to the object position of eat.</S>
			<S sid ="246" ssid = "14">The second alternative uses the minimum description length (MDL) principle.</S>
			<S sid ="247" ssid = "15">Li and Abe use MDL to select a set of classes from a hierarchy, together with their associated probabilities, to represent the selectional preferences of a particular verb.</S>
			<S sid ="248" ssid = "16">The preferences and class-based probabilities are then used to estimate probabilities of the form p(n | v, r), where n is a noun, v is a verb, and r is an argument slot.</S>
			<S sid ="249" ssid = "17">Li and Abe’s application of MDL requires the hierarchy to be in the form of a thesaurus, in which each leaf node represents a noun and internal nodes represent the class of nouns that the node dominates.</S>
			<S sid ="250" ssid = "18">The hierarchy is also assumed to be in the form of a tree.</S>
			<S sid ="251" ssid = "19">The class-based models consist of a partition of the set of nouns (leaf nodes) and a probability associated with each class in the partition.</S>
			<S sid ="252" ssid = "20">The probabilities are the conditional probabilities of each class, given the relevant verb and argument position.</S>
			<S sid ="253" ssid = "21">Li and Abe refer to such a partition as a “cut” and the cut together with the probabilities as a “tree cut model.” The probabilities of the classes in a cut, Γ, satisfy the following constraint: , p(C | v, r)= 1 (19) C∈Γ 9 The definition used here is that given by Ribas (1995)..</S>
			<S sid ="254" ssid = "22">10 For example, the hypernyms of the concept (Dallas) are as follows: (city), (municipality),.</S>
			<S sid ="255" ssid = "23">(urban area), (geographical area), (region), (location), (object), (entity).</S>
			<S sid ="256" ssid = "24">199 &lt;root&gt; &lt;entity&gt; &lt;abstraction&gt; &lt;mushroom&gt; Figure 3 &lt;lobster&gt; &lt;lobster&gt; &lt;pizza&gt; &lt;rope&gt; Possible cut returned by MDL.</S>
			<S sid ="257" ssid = "25">In order to determine the probability of a noun, the probability of a class is assumed to be distributed uniformly among the members of that class: p(n | v, r)= 1 |C| p(C | v, r) for all n ∈ C (20) Since WordNet is a hierarchy with noun senses, rather than nouns, at the nodes, Li and Abe deal with the issue of word sense ambiguity using the method described in Section 3, by dividing the count for a noun equally among the concepts whose synsets contain the noun.</S>
			<S sid ="258" ssid = "26">Also, since WordNet is a DAG, Li and Abe turn WordNet into a tree by copying each subgraph with multiple parents.</S>
			<S sid ="259" ssid = "27">And so that each noun in the data appears (in a synset) at a leaf node, Li and Abe remove those parts of the hierarchy dominated by a noun in the data (but only for that instance of WordNet corresponding to the relevant verb).</S>
			<S sid ="260" ssid = "28">An example cut showing part of the WordNet hierarchy is shown in Figure 3 (based on an example from Li and Abe [1998]; the dashed lines indicate parts of the hierarchy that are not shown in the diagram).</S>
			<S sid ="261" ssid = "29">This is a possible cut for the object position of the verb eat, and the cut consists of the following classes: (life form), (solid), (fluid), (food), (artifact), (space), (time), (set).</S>
			<S sid ="262" ssid = "30">(The particular choice of classes for the cut in this example is not too important; the example is designed to show how probabilities of senses are estimated from class probabilities.)</S>
			<S sid ="263" ssid = "31">Since the class in the cut containing (pizza) is (food), the probability p((pizza) | eat, obj) would be estimated as p((food) | eat, obj)/|(food)|.</S>
			<S sid ="264" ssid = "32">Similarly, since the class in the cut containing (mushroom) is (life form), the probability p((mushroom)| eat, obj) would be estimated as p((life form)| eat, obj)/|(life form)|.</S>
			<S sid ="265" ssid = "33">The uniform-distribution assumption (20) means that cuts close to the root of the hierarchy result in a greater smoothing of the probability estimates than cuts near the leaves.</S>
			<S sid ="266" ssid = "34">Thus there is a trade-off between choosing a model that has a cut near the leaves, which is likely to overfit the data, and a more general (simple) model near the root, which is likely to underfit the data.</S>
			<S sid ="267" ssid = "35">MDL looks ideally suited to the task of model selection, since it is designed to deal with precisely this trade-off.</S>
			<S sid ="268" ssid = "36">The simplicity of a model is measured using the model description length, which is an information-theoretic 200 term and denotes the number of bits required to encode the model.</S>
			<S sid ="269" ssid = "37">The fit to the data is measured using the data description length, which is the number of bits required to encode the data (relative to the model).</S>
			<S sid ="270" ssid = "38">The overall description length is the sum of the model description length and the data description length, and the MDL principle is to select the model with the shortest description length.</S>
			<S sid ="271" ssid = "39">We used McCarthy’s (2000) implementation of MDL.</S>
			<S sid ="272" ssid = "40">So that every noun is represented at a leaf node, McCarthy does not remove parts of the hierarchy, as Li and Abe do, but instead creates new leaf nodes for each synset at an internal node.</S>
			<S sid ="273" ssid = "41">McCarthy also does not transform WordNet into a tree, which is strictly required for Li and Abe’s application of MDL.</S>
			<S sid ="274" ssid = "42">This did create a problem with overgeneralization: Many of the cuts returned by MDL were overgeneralizing at the (entity) node.</S>
			<S sid ="275" ssid = "43">The reason is that (person), which is close to (entity) and dominated by (entity), has two parents: (life form) and (causal agent).</S>
			<S sid ="276" ssid = "44">This DAG-like property was responsible for the over- generalization, and so we removed the link between (person) and (causal agent).</S>
			<S sid ="277" ssid = "45">This appeared to solve the problem, and the results presented later for the average degree of generalization do not show an overgeneralization compared with those given in Li and Abe (1998).</S>
	</SECTION>
	<SECTION title="Pseudo-Disambiguation Experiments. " number = "7">
			<S sid ="278" ssid = "1">The task we used to compare the class-based estimation techniques is a decision task previously used by Pereira, Tishby, and Lee (1993) and Rooth et al.</S>
			<S sid ="279" ssid = "2">(1999).</S>
			<S sid ="280" ssid = "3">The task is to decide which of two verbs, v and vl, is more likely to take a given noun, n, as an object.</S>
			<S sid ="281" ssid = "4">The test and training data were obtained as follows.</S>
			<S sid ="282" ssid = "5">A number of verb–direct object pairs were extracted from a subset of the BNC, using the system of Briscoe and Carroll.</S>
			<S sid ="283" ssid = "6">All those pairs containing a noun not in WordNet were removed, and each verb and argument was lemmatized.</S>
			<S sid ="284" ssid = "7">This resulted in a data set of around 1.3 million (v, n) pairs.</S>
			<S sid ="285" ssid = "8">To form a test set, 3,000 of these pairs were randomly selected such that each selected pair contained a fairly frequent verb.</S>
			<S sid ="286" ssid = "9">(Following Pereira, Tishby, and Lee, only those verbs that occurred between 500 and 5,000 times in the data were considered.)</S>
			<S sid ="287" ssid = "10">Each instance of a selected pair was then deleted from the data to ensure that the test data were unseen.</S>
			<S sid ="288" ssid = "11">The remaining pairs formed the training data.</S>
			<S sid ="289" ssid = "12">To complete the test set, a further fairly frequent verb, vl, was randomly chosen for each (v, n) pair.</S>
			<S sid ="290" ssid = "13">The random choice was made according to the verb’s frequency in the original data set, subject to the condition that the pair (vl, n) did not occur in the training data.</S>
			<S sid ="291" ssid = "14">Given the set of (v, n, vl) triples, the task is to decide whether (v, n) or (vl, n) is the correct pair.11 We acknowledge that the task is somewhat artificial, but pseudo-disambiguation tasks of this kind are becoming popular in statistical NLP because of the ease with which training and test data can be created.</S>
			<S sid ="292" ssid = "15">We also feel that the pseudo-disambig- uation task is useful for evaluating the different estimation methods, since it directly addresses the question of how likely a particular predicate is to take a given noun as an argument.</S>
			<S sid ="293" ssid = "16">An evaluation using a PP attachment task was attempted in Clark and Weir (2000), but the evaluation was limited by the relatively small size of the Penn Treebank.</S>
			<S sid ="294" ssid = "17">11 We note that this procedure does not guarantee that the correct pair is more likely than the incorrect.</S>
			<S sid ="295" ssid = "18">pair, because of noise in the data from the parser and also because a highly plausible incorrect pair could be generated by chance.</S>
			<S sid ="296" ssid = "19">201 Results for the pseudo-disambiguation task.</S>
			<S sid ="297" ssid = "20">Generalization technique % correct av.gen. sd.gen. Similarity class α = 0.0005 73.8 3.3 2.0 α = 0.05 73.4 2.8 1.9 α = 0.3 73.0 2.4 1.8 α = 0.75 73.9 1.9 1.6 α = 0.995 73.8 1.2 1.2 Low class 73.6 0.9 1.0 MDL 68.3 4.1 1.9 Assoc 63.9 4.2 2.1 Note: av.gen. is the average number of generalized levels; sd.gen. is the standard deviation.</S>
			<S sid ="298" ssid = "21">Using our approach, the disambiguation decision for each (v, n, vl) triple was made according to the following procedure: if max c∈cn(n) p (c v, obj) &gt; max c∈cn(n) psc(c | vl, obj) then choose (v, n) else if max c∈cn(n) p (c vl, obj) &gt; max c∈cn(n) psc(c | v, obj) then choose (vl, n) else choose at random If n has more than one sense, the sense is chosen that maximizes the relevant probability estimate; this explains the maximization over cn(n).</S>
			<S sid ="299" ssid = "22">The probability estimates were obtained using our class-based method, and the G2 statistic was used for the chi square test.</S>
			<S sid ="300" ssid = "23">This procedure was also used for the MDL alternative, but using the MDL method to estimate the probabilities.</S>
			<S sid ="301" ssid = "24">Using the association score for each test triple, the decision was made according to the following procedure: if max max Aˆ (cl, v, obj) &gt; max max Aˆ (cl, vl, obj) c∈cn(n) cI∈h(c) then choose (v, n) c∈cn(n) cI∈h(c) else if max max Aˆ (cl, vl, obj) &gt; max max Aˆ (cl, v, obj) c∈cn(n) cI∈h(c) then choose (vl, n) else choose at random c∈cn(n) cI∈h(c) We use h(c) to denote the set consisting of the hypernyms of c. The inner maximization is over h(c), assuming c is the chosen sense of n, which corresponds to Resnik’s method of choosing a set to represent c. The outer maximization is over the senses of n, cn(n), which determines the sense of n by choosing the sense that maximizes the association score.</S>
			<S sid ="302" ssid = "25">The first set of results is given in Table 5.</S>
			<S sid ="303" ssid = "26">Our technique is referred to as the “similarity class” technique, and the approach using the association score is referred 202 Results for the pseudo-disambiguation task with one-fifth training data.</S>
			<S sid ="304" ssid = "27">Generalization technique % correct av.gen. sd.gen. Similarity class α = 0.0005 66.7 4.5 1.9 α = 0.05 68.4 4.1 1.9 α = 0.3 70.2 3.7 1.9 α = 0.75 72.3 3.0 1.9 α = 0.995 72.4 1.9 1.6 Low class 71.9 1.1 1.1 MDL 62.9 4.7 1.9 Assoc 62.6 4.1 2.0 Note: av.gen. is the average number of generalized levels; sd.gen. is the standard deviation.</S>
			<S sid ="305" ssid = "28">to as “Assoc.” The results are given for a range of α values and demonstrate clearly that the performance of similarity class varies little with changes in α and that similarity class outperforms both MDL and Assoc.12 We also give a score for our approach using a simple generalization procedure, which we call “low class.” The procedure is to select the first class that has a count greater than zero (relative to the verb and argument position), which is likely to return a low level of generalization, on the whole.</S>
			<S sid ="306" ssid = "29">The results show that our generalization technique only narrowly outperforms the simple alternative.</S>
			<S sid ="307" ssid = "30">Note that, although low class is based on a very simple generalization method, the estimation method is still using our class-based technique, by applying Bayes’ theorem and conditioning on a class, as described in Section 3; the difference is in how the class is chosen.</S>
			<S sid ="308" ssid = "31">To investigate the results, we calculated the average number of generalized levels for each approach.</S>
			<S sid ="309" ssid = "32">The number of generalized levels for a concept c (relative to a verb v and argument position r) is the difference in depth between c and top(c, v, r), as explained in Section 5.</S>
			<S sid ="310" ssid = "33">For each test case, the number of generalized levels for both verbs, v and vl, was calculated, but only for the chosen sense of n. The results are given in the third column of Table 5 and demonstrate clearly that both MDL and Assoc are generalizing to a greater extent than similarity class.</S>
			<S sid ="311" ssid = "34">(The fourth column gives a standard deviation figure.)</S>
			<S sid ="312" ssid = "35">These results suggest that MDL and Assoc are overgeneralizing, at least for the purposes of this task.</S>
			<S sid ="313" ssid = "36">To investigate why the value for α had no impact on the results, we repeated the experiment, but with one fifth of the data.</S>
			<S sid ="314" ssid = "37">A new data set was created by taking every fifth pair of the original 1.3 million pairs.</S>
			<S sid ="315" ssid = "38">A test set of 3,000 triples was created from this new data set, as before, but this time only verbs that occurred between 100 and 1,000 times were considered.</S>
			<S sid ="316" ssid = "39">The results using these test and training data are given in Table 6.</S>
			<S sid ="317" ssid = "40">These results show a variation in performance across values for α, with an optimal performance when α is around 0.75.</S>
			<S sid ="318" ssid = "41">(Of course, in practice, the value for α would need to be optimized on a held-out set.)</S>
			<S sid ="319" ssid = "42">But even with this variation, similarity class is still outperforming MDL and Assoc across the whole range of α values.</S>
			<S sid ="320" ssid = "43">Note that the 12 The results given for similarity class are different from those given in Clark and Weir (2001) because.</S>
			<S sid ="321" ssid = "44">the probability estimates used in Clark and Weir (2001) were not normalized.</S>
			<S sid ="322" ssid = "45">203 Disambiguation results for G2 and X2.</S>
			<S sid ="323" ssid = "46">α value % correct (G2) % correct (X2) 0.0005 73.8 (3.3) 74.1 (3.0) 0.05 73.4 (2.8) 73.8 (2.5) 0.3 73.0 (2.4) 74.1 (2.2) 0.75 73.9 (1.9) 74.3 (1.8) 0.995 73.8 (1.2) 73.3 (1.2) α values corresponding to the lowest scores lead to a significant amount of generalization, which provides additional evidence that MDL and Assoc are overgeneralizing for this task.</S>
			<S sid ="324" ssid = "47">The low-class method scores highly for this data set also, but given that the task is one that apparently favors a low level of generalization, the high score is not too surprising.</S>
			<S sid ="325" ssid = "48">As a final experiment, we compared the task performance using the X2, rather than G2, statistic in the chi-square test.</S>
			<S sid ="326" ssid = "49">The results are given in Table 7 for the complete data set.13 The figures in brackets give the average number of generalized levels.</S>
			<S sid ="327" ssid = "50">The X2 statistic is performing at least as well as G2, and the results show that the average level of generalization is slightly higher for G2 than X2.</S>
			<S sid ="328" ssid = "51">This suggests a possible explanation for the results presented here and those in Dunning (1993): that the X2 statistic provides a less conservative test when counts in the contingency table are low.</S>
			<S sid ="329" ssid = "52">(By a conservative test we mean one in which the null hypothesis is not easily rejected.)</S>
			<S sid ="330" ssid = "53">A less conservative test is better suited to the pseudo-disambiguation task, since it results in a lower level of generalization, on the whole, which is good for this task.</S>
			<S sid ="331" ssid = "54">In contrast, the task that Dunning considers, the discovery of bigrams, is better served by a more conservative test.</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "8">
			<S sid ="332" ssid = "1">We have presented a class-based estimation method that incorporates a procedure for finding a suitable level of generalization in WordNet.</S>
			<S sid ="333" ssid = "2">This method has been shown to provide superior performance on a pseudo-disambiguation task, compared with two alternative approaches.</S>
			<S sid ="334" ssid = "3">An analysis of the results has shown that the other approaches appear to be overgeneralizing, at least for this task.</S>
			<S sid ="335" ssid = "4">One of the features of the generalization procedure is the way that α, the level of significance in the chi-square test, is treated as a parameter.</S>
			<S sid ="336" ssid = "5">This allows some control over the extent of generalization, which can be tailored to particular tasks.</S>
			<S sid ="337" ssid = "6">We have also shown that the task performance is at least as good when using the Pearson chi-square statistic as when using the log-likelihood chi-square statistic.</S>
			<S sid ="338" ssid = "7">There are a number of ways in which this work could be extended.</S>
			<S sid ="339" ssid = "8">One possibility would be to use all the classes dominated by the hypernyms of a concept, rather than just one, to estimate the probability of the concept.</S>
			<S sid ="340" ssid = "9">An estimate would be obtained for each hypernym, and the estimates combined in a linear interpolation.</S>
			<S sid ="341" ssid = "10">An approach similar to this is taken by Bikel (2000), in the context of statistical parsing.</S>
			<S sid ="342" ssid = "11">There is still room for investigation of the hidden-data problem when data are used that have not been sense disambiguated.</S>
			<S sid ="343" ssid = "12">In this article, a very simple approach is taken, 13 χ2 performed slightly better than G2 using the smaller data set also.</S>
			<S sid ="344" ssid = "13">204 which is to split the count for a noun evenly among the noun’s senses.</S>
			<S sid ="345" ssid = "14">Abney and Light (1999) have tried a more motivated approach, using the expectation maximization algorithm, but with little success.</S>
			<S sid ="346" ssid = "15">The approach described in Clark and Weir (1999) is shown in Clark (2001) to have some impact on the pseudo-disambiguation task, but only with certain values of the α parameter, and ultimately does not improve on the best performance.</S>
			<S sid ="347" ssid = "16">Finally, an issue that has not been much addressed in the literature (except by Li and Abe [1996]) is how the accuracy of class-based estimation techniques compare when automatically acquired classes, as opposed to the manually created classes from WordNet, are used.</S>
			<S sid ="348" ssid = "17">The pseudo-disambiguation task described here has also been used to evaluate clustering algorithms (Pereira, Tishby, and Lee, 1993; Rooth et al., 1999), but with different data, and so it is difficult to compare the results.</S>
			<S sid ="349" ssid = "18">A related issue is how the structure of WordNet affects the accuracy of the probability estimates.</S>
			<S sid ="350" ssid = "19">We have taken the structure of the hierarchy for granted, without any analysis, but it may be that an alternative design could be more conducive to probability estimation.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="351" ssid = "20">This article is an extended and updated version of a paper that appeared in the proceedings of NAACL 2001.</S>
			<S sid ="352" ssid = "21">The work on which it is based was carried out while the first author was a D.Phil.</S>
			<S sid ="353" ssid = "22">student at the University of Sussex and was supported by an EPSRC studentship.</S>
			<S sid ="354" ssid = "23">We would like to thank Diana McCarthy for suggesting the pseudo-disambiguation task and providing the MDL software, John Carroll for supplying the data, and Ted Briscoe, Geoff Sampson, Gerald Gazdar, Bill Keller, Ted Pedersen, and the anonymous reviewers for their helpful comments.</S>
			<S sid ="355" ssid = "24">We would also like to thank Ted Briscoe for presenting an earlier version of this article on our behalf at NAACL 2001.</S>
	</SECTION>
</PAPER>
