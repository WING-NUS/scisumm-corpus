<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Extensive knowledge bases of entailment rules between predicates are crucial for applied semantic inference.</S>
		<S sid ="2" ssid = "2">In this paper we propose an algorithm that utilizes transitivity constraints to learn a globally-optimal set of entailment</S>
	</ABSTRACT>
	<SECTION title="the task" number = "1">
			<S sid ="3" ssid = "3">as a graph learning problem and suggest methods that scale the algorithm to larger graphs.</S>
			<S sid ="4" ssid = "4">We apply the algorithm over a large data set of extracted predicate instances, from which a resource of typed entailment rules has been recently released (Schoenmackers et al., 2010).</S>
			<S sid ="5" ssid = "5">Our results show that using global transitivity information substantially improves performance over this resource and several baselines, and that our scaling methods allow us to increase the scope of global learning of entailment-rule graphs.</S>
			<S sid ="6" ssid = "6">1 Introduction.</S>
			<S sid ="7" ssid = "7">Generic approaches for applied semantic inference from text gained growing attention in recent years, particularly under the Textual Entailment (TE) framework (Dagan et al., 2009).</S>
			<S sid ="8" ssid = "8">TE is a generic paradigm for semantic inference, where the objective is to recognize whether a target meaning can be inferred from a given text.</S>
			<S sid ="9" ssid = "9">A crucial component of inference systems is extensive resources of entailment rules, also known as inference rules, i.e., rules that specify a directional inference relation between fragments of text.</S>
			<S sid ="10" ssid = "10">One important type of rule is rules that specify entailment relations between predicates and their arguments.</S>
			<S sid ="11" ssid = "11">For example, the rule ‘X annex Y → X control Y’ helps recognize that the text ‘Japan annexed Okinawa’ answers the question ‘Which country controls Okinawa?’.</S>
			<S sid ="12" ssid = "12">Thus, acquisition of such knowledge received considerable attention in the last decade (Lin and Pantel, 2001; Sekine, 2005; Szpektor and Dagan, 2009; Schoenmackers et al., 2010).</S>
			<S sid ="13" ssid = "13">Most past work took a “local learning” approach, learning each entailment rule independently of others.</S>
			<S sid ="14" ssid = "14">It is clear though, that there are global interactions between predicates.</S>
			<S sid ="15" ssid = "15">Notably, entailment is a transitive relation and so the rules A → B and B → C imply A → C . Recently, Berant et al.</S>
			<S sid ="16" ssid = "16">(2010) proposed a global graph optimization procedure that uses Integer Linear Programming (ILP) to find the best set of entail- ment rules under a transitivity constraint.</S>
			<S sid ="17" ssid = "17">Imposing this constraint raised two challenges.</S>
			<S sid ="18" ssid = "18">The first of ambiguity: transitivity does not always hold when predicates are ambiguous, e.g., X buy Y → X acquire Y and X acquire Y → X learn Y, but X buy Y --- Xlearn Y since these two rules correspond to two dif ferent senses of acquire.</S>
			<S sid ="19" ssid = "19">The second challenge is scalability: ILP solvers do not scale well since ILP is an NP-complete problem.</S>
			<S sid ="20" ssid = "20">Berant et al. circumvented these issues by learning rules where one of the predicate’s arguments is instantiated (e.g., ‘X re duce nausea → X affect nausea’), which is useful forlearning small graphs on-the-fly, given a target con cept such as nausea.</S>
			<S sid ="21" ssid = "21">While rules may be effectively learned when needed, their scope is narrow and they are not useful as a generic knowledge resource.</S>
			<S sid ="22" ssid = "22">This paper aims to take global rule learning one step further.</S>
			<S sid ="23" ssid = "23">To this end, we adopt the representation suggested by Schoenmackers et al.</S>
			<S sid ="24" ssid = "24">(2010), who learned inference rules between typed predicates, i.e., predicates where the argument types (e.g., city or drug) are specified.</S>
			<S sid ="25" ssid = "25">Schoenmackers et al. uti 610 Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics, pages 610–619, Portland, Oregon, June 1924, 2011.</S>
			<S sid ="26" ssid = "26">Qc 2011 Association for Computational Linguistics lized typed predicates since they were dealing with noisy and ambiguous web text.</S>
			<S sid ="27" ssid = "27">Typing predicates helps disambiguation and filtering of noise, while still maintaining rules of wide-applicability.</S>
			<S sid ="28" ssid = "28">Their method employs a local learning approach, while the number of predicates in their data is too large to be handled directly by an ILP solver.</S>
			<S sid ="29" ssid = "29">In this paper we suggest applying global optimization learning to open domain typed entailment rules.</S>
			<S sid ="30" ssid = "30">To that end, we show how to construct a structure termed typed entailment graph, where the nodes are typed predicates and the edges represent entailment rules.</S>
			<S sid ="31" ssid = "31">We suggest scaling techniques that allow to optimally learn such graphs over a large set of typed predicates by first decomposing nodes into components and then applying incremental ILP (Riedel and Clarke, 2006).</S>
			<S sid ="32" ssid = "32">Using these techniques, the obtained algorithm is guaranteed to return an optimal solution.</S>
			<S sid ="33" ssid = "33">We ran our algorithm over the data set of Schoenmackers et al. and release a resource of 30,000 rules1 that achieves substantially higher recall without harming precision.</S>
			<S sid ="34" ssid = "34">To the best of our knowledge, this is the first resource of that scale to use global optimization for learning predicative entailment rules.</S>
			<S sid ="35" ssid = "35">Our evaluation shows that global transitivity improves the F1 score of rule learning by27% over several baselines and that our scaling tech niques allow dealing with larger graphs, resulting in improved coverage.</S>
	</SECTION>
	<SECTION title="Background. " number = "2">
			<S sid ="36" ssid = "1">Most work on learning entailment rules between predicates considered each rule independently of others, using two sources of information: lexico- graphic resources and distributional similarity.</S>
			<S sid ="37" ssid = "2">Lexicographic resources are manually-prepared knowledge bases containing semantic information on predicates.</S>
			<S sid ="38" ssid = "3">A widely-used resource is WordNet (Fellbaum, 1998), where relations such as synonymy and hyponymy can be used to generate rules.</S>
			<S sid ="39" ssid = "4">Other resources include NomLex (Macleod et al., 1998; Szpektor and Dagan, 2009) and FrameNet (Baker and Lowe, 1998; Ben Aharon et al., 2010).</S>
			<S sid ="40" ssid = "5">Lexicographic resources are accurate but have 1 The resource can be downloaded from http://www.cs.tau.ac.il/˜jonatha6/homepage files/resources /ACL2011Resource.zip low coverage.</S>
			<S sid ="41" ssid = "6">Distributional similarity algorithms use large corpora to learn broader resources by assuming that semantically similar predicates appear with similar arguments.</S>
			<S sid ="42" ssid = "7">These algorithms usually represent a predicate with one or more vectors and use some function to compute argument similarity.</S>
			<S sid ="43" ssid = "8">Distributional similarity algorithms differ in their feature representation: Some use a binary representation: each predicate is represented by one feature vector where each feature is a pair of arguments (Szpektor et al., 2004; Yates and Etzioni, 2009).</S>
			<S sid ="44" ssid = "9">This representation performs well, but suffers when data is sparse.</S>
			<S sid ="45" ssid = "10">The binary-DIRT representation deals with sparsity by representing a predicate with a pair of vectors, one for each argument (Lin and Pantel, 2001).</S>
			<S sid ="46" ssid = "11">Last, a richer form of representation, termed unary, has been suggested where a different predicate is defined for each argument (Szpektor and Dagan, 2008).</S>
			<S sid ="47" ssid = "12">Different algorithms also differ in their similarity function.</S>
			<S sid ="48" ssid = "13">Some employ symmetric functions, geared towards paraphrasing (bidirectional entailment), while others choose directional measures more suited for entailment (Bhagat et al., 2007).</S>
			<S sid ="49" ssid = "14">In this paper, We employ several such functions, such as Lin (Lin and Pantel, 2001), and BInc (Szpektor and Dagan, 2008).</S>
			<S sid ="50" ssid = "15">Schoenmackers et al.</S>
			<S sid ="51" ssid = "16">(2010) recently used dis- tributional similarity to learn rules between typed predicates, where the left-hand-side of the rule may contain more than a single predicate (horn clauses).</S>
			<S sid ="52" ssid = "17">In their work, they used Hearst-patterns (Hearst, 1992) to extract a set of 29 million (argument, type) pairs from a large web crawl.</S>
			<S sid ="53" ssid = "18">Then, they employed several filtering methods to clean this set and automatically produced a mapping of 1.1 million arguments into 156 types.</S>
			<S sid ="54" ssid = "19">Examples for (argument, type) pairs are (EXODUS, book), (CHINA, country) and (ASTHMA, disease).</S>
			<S sid ="55" ssid = "20">Schoenmackers et al. then utilized the types, the mapped arguments and tuples from TextRunner (Banko et al., 2007) to generate 10,672 typed predicates (such as conquer(country,city) and common in(disease,place)), and learn 30,000 rules between these predicates2.</S>
			<S sid ="56" ssid = "21">In this paper we will learn entailment rules over the same data set, which was generously provided by 2 The rules and the mapping of arguments into types can be downloaded from http://www.cs.washington.edu/research/ sherlockhornclauses/ Schoenmackers et al. As mentioned above, Berant et al.</S>
			<S sid ="57" ssid = "22">(2010) used global transitivity information to learn small entail- ment graphs.</S>
			<S sid ="58" ssid = "23">Transitivity was also used as an information source in other fields of NLP: Taxonomy Induction (Snow et al., 2006), Co-reference Resolution (Finkel and Manning, 2008), Temporal Information Extraction (Ling and Weld, 2010), and Unsupervised Ontology Induction (Poon and Domingos, 2010).</S>
			<S sid ="59" ssid = "24">Our proposed algorithm applies to any sparse transitive relation, and so might be applicable in these fields as well.</S>
			<S sid ="60" ssid = "25">Last, we formulate our optimization problem as an Integer Linear Program (ILP).</S>
			<S sid ="61" ssid = "26">ILP is an optimization problem where a linear objective function over a set of integer variables is maximized under a set of linear constraints.</S>
			<S sid ="62" ssid = "27">Scaling ILP is challenging since to typed entailment graphs and typed predicates as entailment graphs and predicates respectively.</S>
			<S sid ="63" ssid = "28">Edges in typed entailment graphs represent entailment rules: an edge (u, v) means that predicate u entails predicate v. If the type t1 is different from the type t2, mapping of arguments is straightforward, as in the rule ‘be find in(material,product)→ contain(product,material)’.</S>
			<S sid ="64" ssid = "29">We term this a two types entailment graph.</S>
			<S sid ="65" ssid = "30">When t1 and t2 are equal, mapping of arguments is ambiguous: we distinguish direct-mapping edges where the first argument on the left-hand-side (LHS) is mapped to the first argument on the right-hand-side (RHS), as in ‘beat(team,team) −d defeat(team,team)’, andreversed-mapping edges where the LHS first argu ment is mapped to the RHS second argument, as in ‘beat(team,team) r →− lose to(team,team)’.</S>
			<S sid ="66" ssid = "31">Weit is an NP-complete problem.</S>
			<S sid ="67" ssid = "32">ILP has been exten sively used in NLP lately (Clarke and Lapata, 2008; Martins et al., 2009; Do and Roth, 2010).</S>
	</SECTION>
	<SECTION title="Typed Entailment Graphs. " number = "3">
			<S sid ="68" ssid = "1">Given a set of typed predicates, entailment rules can only exist between predicates that share the same (unordered) pair of types (such as place and country)3.</S>
			<S sid ="69" ssid = "2">Hence, every pair of types defines a graph that describes the entailment relations between predicates sharing those types (Figure 1).</S>
			<S sid ="70" ssid = "3">Next, we show how to represent entailment rules between typed predicates in a structure termed typed entailment graph, which will be the learning goal of our algorithm.</S>
			<S sid ="71" ssid = "4">A typed entailment graph is a directed graph where the nodes are typed predicates.</S>
			<S sid ="72" ssid = "5">A typed predicate is a triple p(t1, t2) representing a predicate in natural language.</S>
			<S sid ="73" ssid = "6">p is the lexical realization of the predicate and the types t1, t2 are variables representing argument types.</S>
			<S sid ="74" ssid = "7">These are taken from a set of types T , where each type t ∈ T is a bag of natural language words or phrases.</S>
			<S sid ="75" ssid = "8">Examples for typed predicates are: conquer(country,city) and contain(product,material).</S>
			<S sid ="76" ssid = "9">An instance of a typed predicate is a triple p(a1, a2), where a1 ∈ t1 and a2 ∈ t2 are termed arguments.</S>
			<S sid ="77" ssid = "10">For example, be common in(ASTHMA,AUSTRALIA) is an instance of be common in(disease,place).</S>
			<S sid ="78" ssid = "11">For brevity, we refer 3 Otherwise, the rule would contain unbound variables..</S>
			<S sid ="79" ssid = "12">term this a single-type entailment graph.</S>
			<S sid ="80" ssid = "13">Note that in single-type entailment graphs reversed- mapping loops are possible as in ‘play(team,team) r →− play(team,team)’: if team A plays team B, then team B plays team A. Since entailment is a transitive relation, typed- entailment graphs are transitive: if the edges (u, v) and (v, w) are in the graph so is the edge (u, w).</S>
			<S sid ="81" ssid = "14">Note that in single-type entailment graphs one needs to consider whether mapping of edges is direct or reversed: if mapping of both (u, v) and (v, w) is either direct or reversed, mapping of (u, w) is direct, otherwise it is reversed.</S>
			<S sid ="82" ssid = "15">Typing plays an important role in rule transitivity: if predicates are ambiguous, transitivity does not necessarily hold.</S>
			<S sid ="83" ssid = "16">However, typing predicates helps disambiguate them and so the problem of ambiguity is greatly reduced.</S>
	</SECTION>
	<SECTION title="Learning Typed Entailment Graphs. " number = "4">
			<S sid ="84" ssid = "1">Our learning algorithm is composed of two steps: (1) Given a set of typed predicates and their instances extracted from a corpus, we train a (local) entailment classifier that estimates for every pair of predicates whether one entails the other.</S>
			<S sid ="85" ssid = "2">(2) Using the classifier scores we perform global optimization, i.e., learn the set of edges over the nodes that maximizes the global score of the graph under transitivity and background-knowledge constraints.</S>
			<S sid ="86" ssid = "3">Section 4.1 describes the local classifier training invade (country,place) be part of (place,country) p r o v i n c e o f ( p l a c e , c o u n t r y ) be derive from (drug,drug) be process from (drug,drug) a n n e x (coun try,pl ace) be relate to (drug,drug) be conve rt into (d ru g, dr ug ) Table 1: Automatically generated training set examples.</S>
			<S sid ="87" ssid = "4">similarity score estimating whether p1 entails p2.</S>
			<S sid ="88" ssid = "5">We compute 11 distributional similarity scores for each pair of predicates based on the arguments appearing in the extracted arguments.</S>
			<S sid ="89" ssid = "6">The first 6 Figure 1: Top: A fragment of a two-types entailment graph.</S>
			<S sid ="90" ssid = "7">bottom: A fragment of a single-type entailment graph.</S>
			<S sid ="91" ssid = "8">Mapping of solid edges is direct and of dashed edges is reversed.</S>
			<S sid ="92" ssid = "9">procedure.</S>
			<S sid ="93" ssid = "10">Section 4.2 gives an ILP formulation for the optimization problem.</S>
			<S sid ="94" ssid = "11">Sections 4.3 and 4.4 propose scaling techniques that exploit graph sparsity to optimally solve larger graphs.</S>
			<S sid ="95" ssid = "12">4.1 Training an entailment classifier.</S>
			<S sid ="96" ssid = "13">Similar to the work of Berant et al.</S>
			<S sid ="97" ssid = "14">(2010), we use “distant supervision”.</S>
			<S sid ="98" ssid = "15">Given a lexicographic resource (WordNet) and a set of predicates with their instances, we perform the following three steps (see Table 1): 1) Training set generation We use WordNet to generate positive and negative examples, where each example is a pair of predicates.</S>
			<S sid ="99" ssid = "16">Let P be the set of input typed predicates.</S>
			<S sid ="100" ssid = "17">For every predicate p(t1, t2) ∈ P such that p is a single word, we extract from WordNet the set S of synonyms and direct hypernyms of p. For every pt ∈ S, if pt(t1, t2) ∈ P then p(t1, t2) → pt(t1, t2) is taken as a positive ex ample.</S>
			<S sid ="101" ssid = "18">Negative examples are generated in a similar manner, with direct cohyponyms of p (sister nodes in WordNet) and hyponyms at distance 2 instead of synonyms and direct hypernyms.</S>
			<S sid ="102" ssid = "19">We also generate negative examples by randomly sampling pairs of typed predicates that share the same types.</S>
			<S sid ="103" ssid = "20">2) Feature representation Each example pair of predicates (p1, p2) is represented by a feature vector, where each feature is a specific distributional scores are computed by trying all combinations of the similarity functions Lin and BInc with the feature representations unary, binary-DIRT and binary (see Section 2).</S>
			<S sid ="104" ssid = "21">The other 5 scores were provided by Schoenmackers et al.</S>
			<S sid ="105" ssid = "22">(2010) and include SR (Schoenmackers et al., 2010), LIME (McCreath and Sharma, 1997), M-estimate (Dzeroski and Brakto, 1992), the standard G-test and a simple implementation of Cover (Weeds and Weir, 2003).</S>
			<S sid ="106" ssid = "23">Overall, the rationale behind this representation is that combining various scores will yield a better classifier than each single measure.</S>
			<S sid ="107" ssid = "24">3) Training We train over an equal number of positive and negative examples, as classifiers tend to perform poorly on the minority class when trained on imbalanced data (Van Hulse et al., 2007; Nikulin, 2008).</S>
			<S sid ="108" ssid = "25">4.2 ILP formulation.</S>
			<S sid ="109" ssid = "26">Once the classifier is trained, we would like to learn all edges (entailment rules) of each typed entailment graph.</S>
			<S sid ="110" ssid = "27">Given a set of predicates V and an entail ment score function f : V × V → R derived from the classifier, we want to find a graph G = (V, E) that respects transitivity and maximizes the sum of edge weights &apos;[;(u,v)∈E f (u, v).</S>
			<S sid ="111" ssid = "28">This problem is NP-hard by a reduction from the NP-hard Transitive Subgraph problem (Yannakakis, 1978).</S>
			<S sid ="112" ssid = "29">Thus, employing ILP is an appealing approach for obtaining an optimal solution.</S>
			<S sid ="113" ssid = "30">For two-types entailment graphs the formulation is simple: The ILP variables are indicators Xuv denoting whether an edge (u, v) is in the graph, with the following ILP: Gˆ = arg max ) f (u, v) · Xuv (1) u/=v s.t. ∀u,v,w∈V Xuv + Xvw − Xuw ≤ 1 (2) Next, we specify how to derive the function f from the trained classifier using a probabilistic for- mulation4.</S>
			<S sid ="114" ssid = "31">Following Snow et al.</S>
			<S sid ="115" ssid = "32">(2006) and Be- rant et al.</S>
			<S sid ="116" ssid = "33">(2010), we utilize a probabilistic entail- ment classifier that computes the posterior Puv = P (Xuv = 1|Fuv ).</S>
			<S sid ="117" ssid = "34">We want to use Puv to derive the ∀u,v∈Ayes Xuv = 1 (3) posterior P (G|F ), where F = ∪u/=v Fuv and Fuv is ∀u,v∈Ano Xuv = 0 (4) ∀u/=v Xuv ∈ {0, 1} (5) The objective in Eq. 1 is a sum over the weights of the eventual edges.</S>
			<S sid ="118" ssid = "35">The constraint in Eq. 2 states that edges must respect transitivity.</S>
			<S sid ="119" ssid = "36">The constraints in Eq. 3 and 4 state that for known node pairs, defined by Ayes and Ano, we have background knowledge indicating whether entailment holds or not.</S>
			<S sid ="120" ssid = "37">We elaborate on how Ayes and Ano were constructed in Section 5.</S>
			<S sid ="121" ssid = "38">For a graph with n nodes we get n(n − 1) the feature vector for a node pair (u, v).</S>
			<S sid ="122" ssid = "39">Since the classifier was trained on a balanced training set, the prior over the two entailment classes is uniform and so by Bayes rule Puv ∝ P (Fuv |Xuv = 1).</S>
			<S sid ="123" ssid = "40">Using that and the exact same three independence assumptions described by Snow et al.</S>
			<S sid ="124" ssid = "41">(2006) and Berant et al.</S>
			<S sid ="125" ssid = "42">(2010) we can show that (for brevity, we omit the full derivation): Gˆ = arg maxG log P (G|F ) = (7) variables and n(n−1)(n−2) transitivity constraints.</S>
			<S sid ="126" ssid = "43">) Puv · P (Xuv = 1) The simplest way to expand this formulation for single-type graphs is to duplicate each predicate arg max u/=v (log (1 − Puv )P (Xuv )Xuv = 0) node, with one node for each order of the types, and = arg max )(log Puv 1 − Puv )Xuv + log η · |E| then the ILP is unchanged.</S>
			<S sid ="127" ssid = "44">However, this is inefficient as it results in an ILP with 2n(2n − 1) variables and 2n(2n−1)(2n−2) transitivity constraints.</S>
			<S sid ="128" ssid = "45">Since our main goal is to scale the use of ILP, we u/=v P (Xuv =0) is the prior odds ratio for an edge in the graph.</S>
			<S sid ="129" ssid = "46">Comparing Eq. 1 and 7 we modify it a little.</S>
			<S sid ="130" ssid = "47">We denote a direct-mapping edge see that f (u, v) = log Puv ·P (Xuv =1) . Note that f.</S>
			<S sid ="131" ssid = "48">(u, v) by the indicator Xuv and a reversed-mapping edge (u, v) by Yuv . The functions fd and fr provide scores for direct and reversed mappings respectively.</S>
			<S sid ="132" ssid = "49">The objective in Eq. 1 and the constraint in Eq. 2 are replaced by (Eq. 3, 4 and 5 still exist and are carried over in a trivial manner): arg max ) fd(u, v)Xuv + ) fr (u, v)Yuv (6) (1−Puv )P (Xuv =0) is composed of a likelihood component and an edge prior expressed by P (Xuv = 1), which we assume to be some constant.</S>
			<S sid ="133" ssid = "50">This constant is a parameter that affects graph sparsity and controls the trade-off between recall and precision.</S>
			<S sid ="134" ssid = "51">Next, we show how sparsity is exploited to scale the use of ILP solvers.</S>
			<S sid ="135" ssid = "52">We discuss two-types entail- ment graphs, but generalization is simple.</S>
			<S sid ="136" ssid = "53">u/=v u,v 4.3 Graph.</S>
			<S sid ="137" ssid = "54">decompositio n s.t. ∀u,v,w∈V Xuv + Xvw − Xuw ≤ 1 ∀u,v,w∈V Xuv + Yvw − Yuw ≤ 1 ∀u,v,w∈V Yuv + Xvw − Yuw ≤ 1 ∀u,v,w∈V Yuv + Yvw − Xuw ≤ 1 The modified constraints capture the transitivity behavior of direct-mapping and reversed-mapping edges, as described in Section 3.</S>
			<S sid ="138" ssid = "55">This results in2n2 − n variables and about 4n3 transitivity con straints, cutting the ILP size in half.</S>
			<S sid ="139" ssid = "56">Though ILP solvers provide an optimal solution, they substantially restrict the size of graphs we can work with.</S>
			<S sid ="140" ssid = "57">The number of constraints is O(n3), and solving graphs of size &gt; 50 is often not feasible.</S>
			<S sid ="141" ssid = "58">To overcome this, we take advantage of graph sparsity: most predicates in language do not entail one another.</S>
			<S sid ="142" ssid = "59">Thus, it might be possible to decompose graphs into small components and solve each 4 We describe two-types graphs but extending to single-type graphs is straightforward.</S>
			<S sid ="143" ssid = "60">Algorithm 1 Decomposed-ILP Input: A set V and a function f : V × V → R Output: An optimal set of directed edges E∗ 1: Et = {(u, v) : f (u, v) &gt; 0 ∨ f (v, u) &gt; 0} 2: V1, V2, ..., Vk ← connected components of Gt = (V, Et) 3: for i = 1 to k do 4: Ei ← ApplyILPSolve(Vi,f) 5: end for Algorithm 2 Incremental-ILP Input: A set V and a function f : V × V → R Output: An optimal set of directed edges E∗ 1: ACT,VIO ← φ 2: repeat 3: E∗ ← ApplyILPSolve(V,f,ACT) 4: VIO ← violated(V, E∗) 5: ACT ← ACT ∪ VIO 6: until |VIO| = 0 6: E∗ ← k Ei component separately.</S>
			<S sid ="144" ssid = "61">This is formalized in the next proposition.</S>
			<S sid ="145" ssid = "62">Proposition 1.</S>
			<S sid ="146" ssid = "63">If we can partition a set of nodes V into disjoint sets U, W such that for any crossing edge (u, w) between them (in either direction), f (u, w) &lt; 0, then the optimal set of edges Eopt does not contain any crossing edge.</S>
			<S sid ="147" ssid = "64">Proof Assume by contradiction that Eopt contains a set of crossing edges Ecross.</S>
			<S sid ="148" ssid = "65">We can construct Enew = Eopt \ Ecross.</S>
			<S sid ="149" ssid = "66">Clearly how typed entailment graphs benefit from decomposition given different prior values.</S>
			<S sid ="150" ssid = "67">From a more general perspective, this algorithm can be applied to any problem of learning a sparse transitive binary relation.</S>
			<S sid ="151" ssid = "68">Such problems include Co-reference Resolution (Finkel and Manning, 2008) and Temporal Information Extraction (Ling and Weld, 2010).</S>
			<S sid ="152" ssid = "69">Last, the algorithm can be easily parallelized by solving each component on a different core.</S>
			<S sid ="153" ssid = "70">4.4 Incremental ILP.</S>
			<S sid ="154" ssid = "71">&apos;[; (u,v) ∈Ene w f (u, v) &gt; &apos;[; (u,v) ∈Eop t f (u, v), as An oth er sol utio n for sca ling ILP is to em plo y in f (u, v) &lt; 0 for any crossing edge.</S>
			<S sid ="155" ssid = "72">Next, we show that Enew does not violate transitivity constraints.</S>
			<S sid ="156" ssid = "73">Assume it does, then the violation is caused by omitting the edges in Ecross.</S>
			<S sid ="157" ssid = "74">Thus, there must be a node u ∈ U and w ∈ W (w.l.o.g) such that for some node v, (u, v) and (v, w) are in Enew , but (u, w) is not.</S>
			<S sid ="158" ssid = "75">However, this means either (u, v) or (v, w) is a crossing edge, which is impossible since we omitted all crossing edges.</S>
			<S sid ="159" ssid = "76">Thus, Enew is a better solution than Eopt, contradiction.</S>
			<S sid ="160" ssid = "77">This proposition suggests a simple algorithm (see Algorithm 1): Add to the graph an undirected edge for any node pair with a positive score, then find the connected components, and apply an ILP solver over the nodes in each component.</S>
			<S sid ="161" ssid = "78">The edges returned by the solver provide an optimal (not approximate) solution to the optimization problem.</S>
			<S sid ="162" ssid = "79">The algorithm’s complexity is dominated by the ILP solver, as finding connected components takes O(V 2) time.</S>
			<S sid ="163" ssid = "80">Thus, efficiency depends on whether cremental ILP, which has been used in dependency parsing (Riedel and Clarke, 2006).</S>
			<S sid ="164" ssid = "81">The idea is that even if we omit the transitivity constraints, we still expect most transitivity constraints to be satisfied, given a good local entailment classifier.</S>
			<S sid ="165" ssid = "82">Thus, it makes sense to avoid specifying the constraints ahead of time, but rather add them when they are violated.</S>
			<S sid ="166" ssid = "83">This is formalized in Algorithm 2.</S>
			<S sid ="167" ssid = "84">Line 1 initializes an active set of constraints and a violated set of constraints (ACT;VIO).</S>
			<S sid ="168" ssid = "85">Line 3 applies the ILP solver with the active constraints.</S>
			<S sid ="169" ssid = "86">Lines 4 and 5 find the violated constraints and add them to the active constraints.</S>
			<S sid ="170" ssid = "87">The algorithm halts when no constraints are violated.</S>
			<S sid ="171" ssid = "88">The solution is clearly optimal since we obtain a maximal solution for a less- constrained problem.</S>
			<S sid ="172" ssid = "89">A precondition for using incremental ILP is that computing the violated constraints (Line 4) is efficient, as it occurs in every iteration.</S>
			<S sid ="173" ssid = "90">We do that in a straightforward manner: For every node v, and the graph is sparse enough to be decomposed into edges (u, v) and (v, w), if (u, w) ∈/ E∗ we add small components.</S>
			<S sid ="174" ssid = "91">Note that the edge prior plays an important role: low values make the graph sparser and easier to solve.</S>
			<S sid ="175" ssid = "92">In Section 5 we empirically test (u, v, w) to the violated constraints.</S>
			<S sid ="176" ssid = "93">This is cubic in worst-case but assuming the degree of nodes is bounded by a constant it is linear, and performs very fast in practice.</S>
			<S sid ="177" ssid = "94">Combining Incremental-ILP and Decomposed- ILP is easy: We decompose any large graph into its components and apply Incremental ILP on each component.</S>
			<S sid ="178" ssid = "95">We applied this algorithm on our evaluation data set (Section 5) and found that it converges in at most 6 iterations and that the maximal number of active constraints in large graphs drops from ∼ 106 to ∼ 103 − 104.</S>
	</SECTION>
	<SECTION title="Experimental Evaluation. " number = "5">
			<S sid ="179" ssid = "1">In this section we empirically answer the following questions: (1) Does transitivity improve rule learning over typed predicates?</S>
			<S sid ="180" ssid = "2">(Section 5.1) (2) Do Decomposed-ILP and Incremental-ILP improve scalability?</S>
			<S sid ="181" ssid = "3">(Section 5.2) 5.1 Experiment 1.</S>
			<S sid ="182" ssid = "4">A data set of 1 million TextRunner tuples (Banko et al., 2007), mapped to 10,672 distinct typed predicates over 156 types was provided by Schoenmackers et al.</S>
			<S sid ="183" ssid = "5">(2010).</S>
			<S sid ="184" ssid = "6">Readers are referred to their paper for details on mapping of tuples to typed predicates.</S>
			<S sid ="185" ssid = "7">Since entailment only occurs between predicates that share the same types, we decomposed predicates by their types (e.g., all predicates with the types place and disease) into 2,303 typed entailment graphs.</S>
			<S sid ="186" ssid = "8">The largest graph contains 118 nodes and the total number of potential rules is 263,756.</S>
			<S sid ="187" ssid = "9">We generated a training set by applying the procedure described in Section 4.1, yielding 2,644 examples.</S>
			<S sid ="188" ssid = "10">We used SVMperf (Joachims, 2005) to train a Gaussian kernel classifier and computed Puv by projecting the classifier output score, Suv , with the sigmoid function: P = 1 . We tuned two 1+exp(−Suv ) SVM parameters using 5-fold cross validation and a development set of two typed entailment graphs.</S>
			<S sid ="189" ssid = "11">Next, we used our algorithm to learn rules.</S>
			<S sid ="190" ssid = "12">As mentioned in Section 4.2, we integrate background knowledge using the sets Ayes and Ano that contain predicate pairs for which we know whether entail- ment holds.</S>
			<S sid ="191" ssid = "13">Ayes was constructed with syntactic rules: We normalized each predicate by omitting the first word if it is a modal and turning passives to actives.</S>
			<S sid ="192" ssid = "14">If two normalized predicates are equal they are synonymous and inserted into Ayes.</S>
			<S sid ="193" ssid = "15">Ano was constructed from 3 sources (1) Predicates differing by a single pair of words that are WordNet antonyms (2) Predicates differing by a single word of negation (3) Predicates p(t1, t2) and p(t2, t1) where p is a transitive verb (e.g., beat) in VerbNet (Kipper-Schuler et al., 2000).</S>
			<S sid ="194" ssid = "16">We compared our algorithm (termed ILPscale) to the following baselines.</S>
			<S sid ="195" ssid = "17">First, to 10,000 rules released by Schoenmackers et al.</S>
			<S sid ="196" ssid = "18">(2010) (Sherlock), where the LHS contains a single predicate (Schoenmackers et al. released 30,000 rules but 20,000 of those have more than one predicate on the LHS, see Section 2), as we learn rules over the same data set.</S>
			<S sid ="197" ssid = "19">Second, to distributional similarity algorithms: (a) SR: the score used by Schoenmackers et al. as part of the Sherlock system.</S>
			<S sid ="198" ssid = "20">(b) DIRT: (Lin and Pantel, 2001) a widely-used rule learning algorithm.</S>
			<S sid ="199" ssid = "21">(c) BInc: (Szpektor and Dagan, 2008) a directional rule learning algorithm.</S>
			<S sid ="200" ssid = "22">Third, we compared to the entailment classifier with no transitivity constraints (clsf ) to see if combining distributional similarity scores improves performance over single measures.</S>
			<S sid ="201" ssid = "23">Last, we added to all baselines background knowledge with Ayes and Ano (adding the subscript Xk to their name).</S>
			<S sid ="202" ssid = "24">To evaluate performance we manually annotated all edges in 10 typed entailment graphs - 7 two- types entailment graphs containing 14, 22, 30, 53, 62, 86 and 118 nodes, and 3 single-type entailment graphs containing 7, 38 and 59 nodes.</S>
			<S sid ="203" ssid = "25">This annotation yielded 3,427 edges and 35,585 non-edges, resulting in an empirical edge density of 9%.</S>
			<S sid ="204" ssid = "26">We evaluate the algorithms by comparing the set of edges learned by the algorithms to the gold standard edges.</S>
			<S sid ="205" ssid = "27">Figure 2 presents the precision-recall curve of the algorithms.</S>
			<S sid ="206" ssid = "28">The curve is formed by varying a score threshold in the baselines and varying the edge prior in ILPscale5.</S>
			<S sid ="207" ssid = "29">For figure clarity, we omit DIRT and SR, since BInc outperforms them.</S>
			<S sid ="208" ssid = "30">Table 2 shows micro-recall, precision and F1 at the point of maximal F1, and the Area Under the Curve (AUC) for recall in the range of 00.45 for all algorithms, given background knowledge (knowledge consistently improves performance by a few points for all algorithms).</S>
			<S sid ="209" ssid = "31">The table also shows results for the rules from Sherlockk . 5 we stop raising the prior when run time over the graphs exceeds 2 hours.</S>
			<S sid ="210" ssid = "32">Often when the solver does not terminate in 2 hours, it also does not terminate after 24 hours or more.</S>
			<S sid ="211" ssid = "33">Table 3: Impact of scaling techinques (ILP− /ILPscale ).</S>
			<S sid ="212" ssid = "34">Figure 2: Precision-recall curve for the algorithms.</S>
			<S sid ="213" ssid = "35">Table 2: micro-average F1 and AUC for the algorithms.</S>
			<S sid ="214" ssid = "36">Results show that using global transitivity information substantially improves performance.</S>
			<S sid ="215" ssid = "37">ILPscale is better than all other algorithms by a large margin starting from recall .2, and improves AUC by 29% and the maximal F1 by 27%.</S>
			<S sid ="216" ssid = "38">Moreover, ILPscale doubles recall comparing to the rules from the Sherlock resource, while maintaining comparable precision.</S>
			<S sid ="217" ssid = "39">5.2 Experiment 2.</S>
			<S sid ="218" ssid = "40">We want to test whether using our scaling techniques, Decomposed-ILP and Incremental-ILP, allows us to reach the optimal solution in graphs that otherwise we could not solve, and consequently increase the number of learned rules and the overall recall.</S>
			<S sid ="219" ssid = "41">To check that, we run ILPscale, with and with out these scaling techniques (termed ILP−).</S>
			<S sid ="220" ssid = "42">We used the same data set as in Experiment 1 and learned edges for all 2,303 entailment graphs in the data set.</S>
			<S sid ="221" ssid = "43">If the ILP solver was unable to hold the ILP in memory or took more than 2 hours for some graph, we did not attempt to learn its edges.</S>
			<S sid ="222" ssid = "44">We ran ILPscale and ILP− in three den sity modes to examine the behavior of the algorithms for different graph densities: (a) log η = −0.6: the configuration that achieved the best recall/precision/F1 of 43.4/42.2/42.8.</S>
			<S sid ="223" ssid = "45">(b) log η = −1 with recall/precision/F1 of 31.8/55.3/40.4.</S>
			<S sid ="224" ssid = "46">(c) log η = −1.75: A high precision configuration with recall/precision/F1 of 0.15/0.75/0.23 6.</S>
			<S sid ="225" ssid = "47">In each run we counted the number of graphs that could not be learned and the number of rules learned by each algorithm.</S>
			<S sid ="226" ssid = "48">In addition, we looked at the 20 largest graphs in our data (49118 nodes) and measured the ratio r between the size of the largest component after applying Decomposed-ILP and the original size of the graph.</S>
			<S sid ="227" ssid = "49">We then computed the av erage 1 − r over the 20 graphs to examine how graph size drops due to decomposition.</S>
			<S sid ="228" ssid = "50">Table 3 shows the results.</S>
			<S sid ="229" ssid = "51">Column # unlearned and # rules describe the number of unlearned graphs and the number of learned rules.</S>
			<S sid ="230" ssid = "52">Column shows relative increase in the number of rules learned and column Red.</S>
			<S sid ="231" ssid = "53">shows the average 1 − r. ILPscale increases the number of graphs that we are able to learn: in our best configuration (log η = −0.6) only 3 graphs could not be handled com paring to 9 graphs when omitting our scaling tech niques.</S>
			<S sid ="232" ssid = "54">Since the unlearned graphs are among the largest in the data set, this adds 3,500 additional rules.</S>
			<S sid ="233" ssid = "55">We compared the precision of rules learned only by ILPscale with that of the rules learned by both, by randomly sampling 100 rules from each and found precision to be comparable.</S>
			<S sid ="234" ssid = "56">Thus, the additional rules learned translate into a 13% increase in relative recall without harming precision.</S>
			<S sid ="235" ssid = "57">Also note that as density increases, the number of rules learned grows and the effectiveness of decomposition decreases.</S>
			<S sid ="236" ssid = "58">This shows how Decomposed- ILP is especially useful for sparse graphs.</S>
			<S sid ="237" ssid = "59">We re lease the 29,732 rules learned by the configuration log η = −0.6 as a resource.</S>
			<S sid ="238" ssid = "60">To sum up, our scaling techniques allow us to learn rules from graphs that standard ILP can not handle and thus considerably increase recall without harming precision.</S>
	</SECTION>
	<SECTION title="Conclusions and Future  Work. " number = "6">
			<S sid ="239" ssid = "1">This paper proposes two contributions over two recent works: In the first, Berant et al.</S>
			<S sid ="240" ssid = "2">(2010) presented a global optimization procedure to learn entailment rules between predicates using transitivity, and applied this algorithm over small graphs where all predicates have one argument instantiated by a target concept.</S>
			<S sid ="241" ssid = "3">Consequently, the rules they learn are of limited applicability.</S>
			<S sid ="242" ssid = "4">In the second, Schoenmackers et al. learned rules of wider applicability by using typed predicates, but utilized a local approach.</S>
			<S sid ="243" ssid = "5">In this paper we developed an algorithm that uses global optimization to learn widely-applicable entailment rules between typed predicates (where both arguments are variables).</S>
			<S sid ="244" ssid = "6">This was achieved by appropriately defining entailment graphs for typed predicates, formulating an ILP representation for them, and introducing scaling techniques that include graph decomposition and incremental ILP.</S>
			<S sid ="245" ssid = "7">Our algorithm is guaranteed to provide an optimal solution and we have shown empirically that it substantially improves performance over Schoenmackers et al.’s recent resource and over several baselines.</S>
			<S sid ="246" ssid = "8">In future work, we aim to scale the algorithm further and learn entailment rules between untyped predicates.</S>
			<S sid ="247" ssid = "9">This would require explicit modeling of predicate ambiguity and using approximation techniques when an optimal solution cannot be attained.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="248" ssid = "10">This work was performed with financial support from the Turing Center at The University of Washington during a visit of the first author (NSF grant IIS0803481).</S>
			<S sid ="249" ssid = "11">We deeply thank Oren Etzioni and Stefan Schoenmackers for providing us with the data sets for this paper and for numerous helpful discussions.</S>
			<S sid ="250" ssid = "12">We would also like to thank the anonymous reviewers for their useful comments.</S>
			<S sid ="251" ssid = "13">This work was developed under the collaboration of FBKirst/University of Haifa and was partially supported by the Israel Science Foundation grant 1112/08.</S>
			<S sid ="252" ssid = "14">The first author is grateful to IBM for the award of an IBM Fellowship, and has carried out this research in partial fulllment of the requirements for the Ph.D. degree.</S>
	</SECTION>
</PAPER>
