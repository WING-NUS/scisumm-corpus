<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Many NLP tasks make predictions that are inherently coupled to syntactic relations, but for many languages the resources required to provide such syntactic annotations are unavailable.</S>
		<S sid ="2" ssid = "2">For others it is unclear exactly how much of the syntactic annotations can be effectively leveraged with current models, and what structures in the syntactic trees are most relevant to the current task.</S>
		<S sid ="3" ssid = "3">We propose a novel method which avoids the need for any syntactically annotated data when predicting a related NLP task.</S>
		<S sid ="4" ssid = "4">Our method couples latent syntactic representations, constrained to form valid dependency graphs or constituency parses, with the prediction task via specialized factors in a Markov random field.</S>
		<S sid ="5" ssid = "5">At both training and test time we marginalize over this hidden structure, learning the optimal latent representations for the problem.</S>
		<S sid ="6" ssid = "6">Results show that this approach provides significant gains over a syntactically uninformed baseline, outperforming models that observe syntax on an English relation extraction task, and performing comparably to them in semantic role labeling.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">Many NLP tasks are inherently tied to syntax, and state-of-the-art solutions to these tasks often rely on syntactic annotations as either a source for useful features (Zhang et al., 2006, path features in relation extraction) or as a scaffolding upon which a more narrow, specialized classification can occur (as often done in semantic role labeling).</S>
			<S sid ="8" ssid = "8">This decou pling of the end task from its intermediate representation is sometimes known as the two-stage approach (Chang et al., 2010) and comes with several drawbacks.</S>
			<S sid ="9" ssid = "9">Most notably this decomposition prohibits the learning method from utilizing the labels from the end task when predicting the intermediate representation, a structure which must have some correlation to the end task to provide any benefit.</S>
			<S sid ="10" ssid = "10">Relying on intermediate representations that are specifically syntactic in nature introduces its own unique set of problems.</S>
			<S sid ="11" ssid = "11">Large amounts of syntactically annotated data is difficult to obtain, costly to produce, and often tied to a particular domain that may vary greatly from that of the desired end task.</S>
			<S sid ="12" ssid = "12">Additionally, current systems often utilize only a small amount of the annotation for any particular task.</S>
			<S sid ="13" ssid = "13">For instance, performing named entity recognition (NER) jointly with constituent parsing has been shown to improve performance on both tasks, but the only aspect of the syntax which is leveraged by the NER component is the location of noun phrases (Finkel and Manning, 2009).</S>
			<S sid ="14" ssid = "14">By instead discovering a latent representation jointly with the end task we address all of these concerns, alleviating the need for any syntactic annotations, while simultaneously attempting to learn a latent syntax relevant to both the particular domain and structure of the end task.</S>
			<S sid ="15" ssid = "15">We phrase the joint model as factor graph and marginalize over the hidden structure of the intermediate representation at both training and test time, to optimize performance on the end task.</S>
			<S sid ="16" ssid = "16">Inference is done via loopy belief propagation, making this framework trivially extensible to most graph structures.</S>
			<S sid ="17" ssid = "17">Computation over latent syntactic rep 810 Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 810–820, Jeju Island, Korea, 12–14 July 2012.</S>
			<S sid ="18" ssid = "18">Qc 2012 Association for Computational Linguistics resentations is made tractable with the use of special combinatorial factors which implement unlabeled variants of common dynamic-programming parsing algorithms, constraining the hidden representation to realize valid dependency graphs or constituency trees.</S>
			<S sid ="19" ssid = "19">We apply this strategy to two common NLP tasks, coupling a model for the end task prediction with latent and general syntactic representations via specialized logical factors which learn associations between latent and observed structure.</S>
			<S sid ="20" ssid = "20">In comparisons with identical models which observe “gold” syntactic annotations, derived from off-the-shelf parsers or provided with the corpora, we find that our hidden marginalization method is comparable in both tasks and almost every language tested, sometimes significantly outperforming models which observe the true syntax.</S>
			<S sid ="21" ssid = "21">The following sections serves as a preliminary, introducing an inventory of factors and variables for constructing factor graph representations of syntactically-coupled NLP tasks.</S>
			<S sid ="22" ssid = "22">Section 3 explores the benefits of this method on relation extraction (RE), where we compare the use dependency and constituency structure as latent representations.</S>
			<S sid ="23" ssid = "23">We then turn to a more established semantic role label ing (SRL) task (§4) where we evaluate across a wide range of languages.</S>
	</SECTION>
	<SECTION title="Latent Pseudo-Syntactic Structure. " number = "2">
			<S sid ="24" ssid = "1">The models presented in this paper are phrased in terms of variables in an undirected graphical model, Markov random field.</S>
			<S sid ="25" ssid = "2">More specifically, we implement the model as a factor graph, a bipartite graph composed of factors and variables in which we can efficiently compute the marginal beliefs of any variable set with the sum-product algorithm for cyclic graphs, loopy belief propagation,.</S>
			<S sid ="26" ssid = "3">We now introduce the basic variable and factor components used throughout the paper.</S>
			<S sid ="27" ssid = "4">2.1 Latent Dependency Structure.</S>
			<S sid ="28" ssid = "5">Dependency grammar is a lexically-oriented syntactic formalism in which syntactic relationships are expressed as dependencies between individual words.</S>
			<S sid ="29" ssid = "6">Each non-root word specifies another as its head, provided that the resulting structure forms a valid directed graph, ie.</S>
			<S sid ="30" ssid = "7">there are no cycles in the graph.</S>
			<S sid ="31" ssid = "8">Due to the flexibility of this representation it is often used to describe free-word-order languages, and increasingly preferred in NLP for more language-in-use scenarios.</S>
			<S sid ="32" ssid = "9">A dependency graph can be modeled with the following nodes, as first proposed by Smith and Eisner (2008): • Let {Link(i, j) : 0 ≤ i ≤ j ≤ n, n 1= j} be O(n2) boolean variables corresponding to the possible links in a dependency parse.</S>
			<S sid ="33" ssid = "10">Li,j = true implies that there is a dependency from parent i to child j. • Let {LI N K (i, j) : 0 ≤ i ≤ j ≤ n, n 1= j} be O(n2) unary factors, each paired with a corresponding Link(i, j) variable and expressing the independent belief that Link(i, j) = true.</S>
			<S sid ="34" ssid = "11">2.2 Latent Constituency Structure.</S>
			<S sid ="35" ssid = "12">Alternatively we can describe the more structured constituency formalism by setting up a representation over span variables: • Let {Span(i, j) : 0 ≤ i &lt; j ≤ n} be O(n2) boolean variables such that Span(i, j) = true iff there is a bracket spanning i to j 1.</S>
			<S sid ="36" ssid = "13">• Let {SPAN(i, j) : 0 ≤ i &lt; j ≤ n} be O(n2) unary factors, each attached to the corresponding Span(i, j) variable.</S>
			<S sid ="37" ssid = "14">These factors score the independent suitability of each span to appear in an unlabeled constituency tree.</S>
			<S sid ="38" ssid = "15">All boolean variables presented in this paper will be paired to unary factors in this manner, which we will omit in future descriptions.</S>
			<S sid ="39" ssid = "16">This encompasses the necessary representational structure for both syntactic formalisms, but nothing introduced up to this point guarantees that either of these representations will form a valid tree or DAG.</S>
			<S sid ="40" ssid = "17">2.3 Combinatorial Factors.</S>
			<S sid ="41" ssid = "18">Naively constraining these latent representations through the introduction of many interconnected ternary factors is possible, but would likely be computationally intractable.</S>
			<S sid ="42" ssid = "19">However, as observed in 1 In practice, we do not need to include variables for spans of width 1 or n, since they will always be true.</S>
			<S sid ="43" ssid = "20">Smith and Eisner (2008), we can encapsulating common dynamic programming algorithms within special-purpose factors to efficiently globally constrain variable configurations . Since the outgoing messages from such factors to a variable can be computed from the factor’s posterior beliefs about that variable, there is no difficulty in exchanging beliefs between these special-purpose factors and the rest of the graph, and inference can proceed using the standard sum-product or max-product belief propagation.</S>
			<S sid ="44" ssid = "21">Here we present two combinatorial factors that provide efficient ways of constraining the model to fit common syntactic frameworks.</S>
			<S sid ="45" ssid = "22">• Let CKYTREE be a global combinatorial factor, as used in previous work in efficient parsing (Naradowsky and Smith, 2012), attached to all the Span(i, j) variables.</S>
			<S sid ="46" ssid = "23">This factor con tributes a factor of 1 to the model’s score iff the span variables collectively form a legal, binary bracketing and a factor of 0 otherwise.</S>
			<S sid ="47" ssid = "24">It enforces, therefore, a hard constraint on the variables, computing beliefs via an unlabeled variant of the inside-outside algorithm.</S>
			<S sid ="48" ssid = "25">• Let DEP-TREE be a global combinatorial factor, as presented in Smith and Eisner (2008), which attaches to all Link(i, j) variables and similarly contributes a factor of 1 iff the config uration of Link variables forms a valid projective dependency graph.</S>
			<S sid ="49" ssid = "26">A graph is projective if its edges do not cross.</S>
			<S sid ="50" ssid = "27">2.4 Marginal MAP Inference.</S>
			<S sid ="51" ssid = "28">It is straightforward to train these latent variable models to maximize the marginal probability of their outputs, conditioning on their inputs, and marginal- izing out the latent syntactic variables.</S>
			<S sid ="52" ssid = "29">To compute feature expectations, we can use marginal inference techniques such as sampling and sum-product belief propagation to compute marginal probabilities.</S>
			<S sid ="53" ssid = "30">A knottier problem arises when we want to find the best assignment to the variables of interest while marginalizing out “nuisance” latent variables.</S>
			<S sid ="54" ssid = "31">This is the problem of marginal MAP inference— sometimes known as consensus decoding—which has been shown to be NP-hard and without a polynomial time approximation scheme (Sima’an, 1996; Casacuberta and Higuera, 2000).</S>
			<S sid ="55" ssid = "32">In the NLP community, these inference problems often arise when dealing with spurious ambiguity where multiple derivations can lead to the same derived structure.</S>
			<S sid ="56" ssid = "33">In tree substitution grammars, for instance, there may be many ways of combining elementary trees to produce the same output tree; in machine translation, many different elementary phrases or elementary tree pairs might produce the same output string.</S>
			<S sid ="57" ssid = "34">For syntactic parsing, Goodman (1996) proposed a variational method for summing out spurious ambiguity that was equivalent to minimum Bayes risk decoding (Goel and Byrne, 2000; Kumar and Byrne, 2004) with a constituent-recall loss function.</S>
			<S sid ="58" ssid = "35">For MT, May and Knight (2006) proposed methods for determinizing tree automata to reduce ambiguity, and Li et al.</S>
			<S sid ="59" ssid = "36">(2009) proposed a variational method based on n-gram loss functions.</S>
			<S sid ="60" ssid = "37">More recently, Liu and Ihler (2011) analyzed message-passing algorithms for marginal MAP.</S>
			<S sid ="61" ssid = "38">In this paper, we adopt a simple minimum Bayes risk decoding scheme.</S>
			<S sid ="62" ssid = "39">First, we perform sum- product belief propagation on the full factor graph.</S>
			<S sid ="63" ssid = "40">Then, we maximize the expected accuracy of the variables of interest, subject to any hard constraints on them (such as mutual exclusion among labels).</S>
			<S sid ="64" ssid = "41">In some cases with complex combinatorial constraints, this simple MBR scheme has proved more effective than exact decoding over all variables (Auli and Lopez, 2011).</S>
	</SECTION>
	<SECTION title="Relation Extraction. " number = "3">
			<S sid ="65" ssid = "1">Performing a syntax-based NLP task in most real- world scenarios requires that the incoming data first be parsed using a pre-trained parsing model.</S>
			<S sid ="66" ssid = "2">For some tasks, like relation extraction, many data sets lack syntactic annotation and these circumstances persist even into the training phase.</S>
			<S sid ="67" ssid = "3">In this section we explore such scenarios and contrast the use of parser-provided syntactic annotation to marginal- izing over latent representations of constituency or dependency syntax.</S>
			<S sid ="68" ssid = "4">We show the hidden syntactic models are not just competitive with these “oracle” models, but in some configurations can actually outperform them.</S>
			<S sid ="69" ssid = "5">Relation extraction is the task of identifying semantic relations between sets of entities in text (as illustrated in Fig.</S>
			<S sid ="70" ssid = "6">1b), and a good proving ground for latent syntactic methods for two reasons.</S>
			<S sid ="71" ssid = "7">First, because entities share a semantic relationship, under most linguistic analyses these entities will also share some syntactic relation.</S>
			<S sid ="72" ssid = "8">Indeed, syntactic features have long been an extremely useful source of information for relation extraction systems (Culotta and Sorensen, 2004; Mintz et al., 2009).</S>
			<S sid ="73" ssid = "9">Secondly, relation extraction has been a common task for pioneering efforts in processing data mined from the internet, and otherwise noisy or out-of-domain data.</S>
			<S sid ="74" ssid = "10">In particular, large noisily-annotated data sets have been generated by leveraging freely available knowledge bases such as Freebase (Bollacker et al., 2008; Mintz et al., 2009).</S>
			<S sid ="75" ssid = "11">Such data sets have been utilized successfully for relation extraction from the web (Bunescu and Mooney, 2007).</S>
			<S sid ="76" ssid = "12">3.1 Model.</S>
			<S sid ="77" ssid = "13">We present a simple model for representing relational structure, with the only variables present being a set of boolean-valued variables representing an undirected dependency between two entities, and an additional set of boolean label variables representing the type label of the relation.</S>
			<S sid ="78" ssid = "14">• Let {Rel(i, j : 0 ≤ i &lt; j ≤ n} be O(n2) boolean variables such that Rel(i, j) = true iff there is a relation spanning i to j. • Let {Rel-Label(i, j, λ) : λ ∈ L, and 0 ≤ i &lt; j ≤ n} be O(|L|n2) boolean variables suchthat Rel-Label(i, j, λ) = true iff there is a re lation spanning i to j with relation type λ.</S>
			<S sid ="79" ssid = "15">• Let {ATMOST1(i, j) : 0 ≤ i &lt; j ≤ n} be O(n2) factors, each coordinating the set L of possible nonterminal variables to the Rel vari able at each i, j tuple, allowing a Rel-Label variable to be true iff all other label variables are false and Rel(i, j) = true.</S>
			<S sid ="80" ssid = "16">Here the Rel(i, j) and Rel-Label(i, j) variables simply express the representation of the problem, while the ATMOST1 factors are logical constraints ensuring that only one label will apply to a particular relation.</S>
			<S sid ="81" ssid = "17">3.2 Coordination Factors.</S>
			<S sid ="82" ssid = "18">An important contribution of this work is the introduction of a flexible, general framework for connecting the latent and observable partitions of the model.</S>
			<S sid ="83" ssid = "19">We accomplish this through the use of two additional factors, each expressing the same basic logic, which learn when to coordinate and when to ignore correlations between the latent syntax and the end task.</S>
			<S sid ="84" ssid = "20">While here we specify binary and ternary versions of these factors, they also generalize to higher dimensions.</S>
			<S sid ="85" ssid = "21">• Let {D-CONNECT(i, j, k) : 0 ≤ i &lt; j ≤ n; 0 ≤ k ≤ n} be O(n3) factors coordinating any number of dependency syntax Link(i, j) variables with representational variables on the end task, multiplying in 1 to the model score unless all variables are on, in which case it multiplies a connective potential φ derived from its features.</S>
			<S sid ="86" ssid = "22">Thus it functions logically as a soft NAND factor.</S>
			<S sid ="87" ssid = "23">In this ternary formulation k represents a hidden dependency head or pivot which is shared between two syntactic dependencies anchored at the indices of the entities in the relation (as illustrated in Fig.</S>
			<S sid ="88" ssid = "24">1).</S>
			<S sid ="89" ssid = "25">• Let {C-CONNECT(i, j) : 0 ≤ i &lt; j ≤ n} be O(n2) factors coordinating syntacticSpan(i, j) and relation arc Rel(i, j), identi cally to D-CONNECT but with a 1-to-1 mapping.</S>
			<S sid ="90" ssid = "26">Intuitively the joint model might learn φ &gt; 1, i.e., constituency spans and task prediction relations are more likely to be coterminous.</S>
			<S sid ="91" ssid = "27">The difficulty in working with latent dependency syntax is that we posit that the RE variables do not share a 1-to-1 mapping with variables in the hidden representation.</S>
			<S sid ="92" ssid = "28">We expect instead, according to linguistic intuition, that a relation between entities at position i and j in the sentence should have corresponding syntactic dependencies but that they are likely to realize this by sharing the same head word (as depicted in Fig.1), a word whose identity should help label the relation.</S>
			<S sid ="93" ssid = "29">Therefore we introduce a special coordination factor, D-CONNECT as a ternary factor to capture the relationship between pairs of latent syntactic variables and a single relation variable, pivoting on the same unknown head word.</S>
			<S sid ="94" ssid = "30">Figure 1: Latent Dependency coupling for the RE task.</S>
			<S sid ="95" ssid = "31">The D-CONNECT factor expresses ternary connection relations because the shared head word of the proposed relation is unknown.</S>
			<S sid ="96" ssid = "32">As is convention, variables are represented by circles, factors by rectangles.</S>
			<S sid ="97" ssid = "33">We introduce six model scenarios.</S>
			<S sid ="98" ssid = "34">• Baseline, simply the arc-factored model consisting only of Rel and corresponding Label variables for each entity.</S>
			<S sid ="99" ssid = "35">Features on the relation factors, which are common to all model configurations, are combinations of lexical information (i.e., the words that form the entity, the pos-tags of the entities, etc.) as well as the distance between the relation.</S>
			<S sid ="100" ssid = "36">This is a lightweight model and generally does not attempt to exhaustively leverage all possible proven sources of useful features (Zhou et al., 2005) towards a higher absolute score, but rather to serve as a point of comparison to the models which rely on syntactic information.</S>
			<S sid ="101" ssid = "37">• Baseline-Ent, a variant of Baseline with additional features which include combinations of • Oracle D-Parse, in which we also instantiate a full set of latent dependency syntax variables, and connect them to the baseline model using D-CONNECT factors.</S>
			<S sid ="102" ssid = "38">Syntax variables are clamped to their true values.</S>
			<S sid ="103" ssid = "39">• Oracle C-Parse, the constituency syntax analogue of Oracle D-Parse.</S>
			<S sid ="104" ssid = "40">• Hidden D-Parse, which is an extension of Oracle D-Parse in which we connect all syntax variables to a DEP-TREE factor, syntax variables are unobserved, and are learned jointly with the end task.</S>
			<S sid ="105" ssid = "41">The features for latent syntax are a subset of those used in dependency parsing (McDonald et al., 2005).</S>
			<S sid ="106" ssid = "42">• Hidden C-Parse, the constituency syntax analogue of Hidden D-Parse.</S>
			<S sid ="107" ssid = "43">The feature set is similar but bigrams are taken over the words defining the constituent span, rather than the words defining the head/modifier relation.</S>
			<S sid ="108" ssid = "44">Coordination factor features for the syntactically- informed models are particularly important.</S>
			<S sid ="109" ssid = "45">This became evident in initial experiments where the baseline was often able to outperform the hidden syntactic model.</S>
			<S sid ="110" ssid = "46">However, inclusion of entity and mention label features into the connection factors provides the model with greater reasoning over when to coordinate or ignore the relation predictions with the underlying syntax.</S>
			<S sid ="111" ssid = "47">These are a proper subset of the Baseline-Ent features.</S>
			<S sid ="112" ssid = "48">3.3 Data.</S>
			<S sid ="113" ssid = "49">We evaluate these models using the 2005 Automatic Content Extraction (ACE) data set (Walker, 2006), using the English (dual-annotated) and Chinese (solely annotator #1 data set) sections.</S>
			<S sid ="114" ssid = "50">Each corpus is annotated with entity mentions—tagged as PER, ORG, LOC, or MISC—and, where applicable, what type of relation exists between them (e.g., coarse: PHYS; fine: Located).</S>
			<S sid ="115" ssid = "51">But like most corpora available for the task, the burden of acquiring corresponding syntactic annotation is left to the researcher.</S>
			<S sid ="116" ssid = "52">In this situation it is common to turn to existing pre-trained parsing models.</S>
			<S sid ="117" ssid = "53">We generate our data by first splitting the raw A C E R e s u l t s M od el E n g l i s h Unlabeled Labeled C h i n e s e Unlabeled Labeled P R F 1 P R F 1 P R F 1 P R F 1 Ba se lin e Ba se line En t 85 .4 87 .2 57 .0 65 .4 68 .4 74 .8 83 .0 85 .8 55 .3 64 .4 66 .4 73 .6 42 .9 55 .2 26 .8 31 .1 33 .0 39 .8 42 .6 51 .2 21 .3 29 .4 28 .4 37 .4 Or acl e D Pa rse Hi dd en D Pa rse 89 .3 87 .8 67 .4 69 .8 76 .8 77 .7 89 .3 85 .3 66 .2 67 .8 75 .4 75 .6 60 .0 48 .0 32 .6 32 .0 42 .2 38 .4 58 .1 47 .2 31 .3 30 .0 40 .7 36 .7 Or acl e C Pa rse Hi dd en C Pa rse 89 .1 90 .5 68 .7 69 .9 77 .6 78 .9 87 .5 88 .8 67 .5 68 .6 76 .2 77 .4 66 .8 56 .3 37 .8 32 .3 48 .3 41 .0 63 .8 53 .4 37 .0 31 .6 46 .8 39 .7 Table 1: Relation Extraction Results.</S>
			<S sid ="118" ssid = "54">Models using hidden constituency syntax provide significant gains over the syntactically-uniformed baseline model in both languages, but the advantages of the latent syntax were mitigated on the smaller Chinese data set.</S>
			<S sid ="119" ssid = "55">are also tokenized according to Penn Chinese Tree- bank standards (Xue et al., 2005).</S>
			<S sid ="120" ssid = "56">The sentences are then tagged and parsed using the Stanford CoreNLP tools, using the standard pre-trained models for tagging (Toutanvoa and Manning, 2000), and the factored parsing model of Klein and Manning (2002).</S>
			<S sid ="121" ssid = "57">The distributed grammar is trained on a variety of sources, including the standard Wallstreet Journal corpus, but also biomedical, translation, and questions.</S>
			<S sid ="122" ssid = "58">We then apply entity and relation annotations noisily to the data, collapsing multi-word entities into one term.</S>
			<S sid ="123" ssid = "59">We filter out sentences with fewer than two entities (and are thus incapable of containing relations) and sentences with more than 40 words (to keep the parses more reliable).</S>
			<S sid ="124" ssid = "60">This yields 6966 sentences for English data, but unfortunately only 747 sentences for the Chinese.</S>
			<S sid ="125" ssid = "61">Nine of every ten sentences comprise the training set, with every tenth sentence reserved for test.</S>
			<S sid ="126" ssid = "62">3.4 Results.</S>
			<S sid ="127" ssid = "63">We train all models using 20 iterations of stochastic gradient descent, each with a maximum of 10 BP iterations (though in practice we find convergence to often occur much earlier).</S>
			<S sid ="128" ssid = "64">The results are presented in Table 1, showing precision, recall, and F-measure for both labeled and unlabeled prediction.</S>
			<S sid ="129" ssid = "65">For English, not only is the hidden marginalization method a suitable replacement for the syntactic trees provided by pre-trained, state-of-the-art models, but in both configurations we find that inducing an optimal hidden structure is preferable to the parser-produced annotations.</S>
			<S sid ="130" ssid = "66">On Chinese, where the data set is atyp over the baseline in the constituency-based model though it is not able to match the observed syntax model.</S>
			<S sid ="131" ssid = "67">Despite the intuition that both entities occupy roles as modifiers of the same verb, we find that the Hidden D-Parse model often fails to recover the correct latent structure, and that even when successful dependency parses are observed, the head word is often not uniquely indicative of the relation type (as known is not strongly correlated with the relation type EMPLOYS in the phrase: Shigeru Miyamoto, best known for his work at the video game company Nintendo).</S>
			<S sid ="132" ssid = "68">Hence when it comes to relation extraction, at least on our relatively small data sets, we find the simplest approach to latent syntactic structure is the best.</S>
			<S sid ="133" ssid = "69">We now turn to the task of semantic role labeling to evaluate this method on a more established hand-annotated data set, and a more varied set of languages.</S>
	</SECTION>
	<SECTION title="Semantic Role Labeling. " number = "4">
			<S sid ="134" ssid = "1">The task of semantic role labeling (SRL) aims to detect and label the semantic relationships between particular words, most commonly verbs (referred to in the domain as predicates), and their arguments (MezaRuiz and Riedel, 2009).</S>
			<S sid ="135" ssid = "2">In a manner similar to RE, there is a strong correlation between the presence of an SRL relation and there existing an underlying syntactic dependency, though this is not always expressed as directly as a 1-to-1 correspondence.</S>
			<S sid ="136" ssid = "3">This has historically motivated a reliance on syntactic annotation, and some a.)</S>
			<S sid ="137" ssid = "4">Syntactic Combinatorial Constraint DEP-Tree b.)</S>
			<S sid ="138" ssid = "5">Syntactic Layer Link 5, 1 Link 5, 2 Link 5, 3 . . .</S>
			<S sid ="139" ssid = "6">Link 5, n D-Connect 5, 1 D-Connect 5, 2 D-Connect 5, 3 D C o n n e c t 5 , n c.)</S>
			<S sid ="140" ssid = "7">Argument Prediction Arg 5, 1 Arg 5, 2 At Most 1 Arg 5, 3 d.)</S>
			<S sid ="141" ssid = "8">Sense Prediction At Most 1 Pred sense.</S>
			<S sid ="142" ssid = "9">01 sense.</S>
			<S sid ="143" ssid = "10">02 . . .</S>
			<S sid ="144" ssid = "11">role A0 role A1 role A2 . . .</S>
			<S sid ="145" ssid = "12">role A-TM 5 sense.</S>
			<S sid ="146" ssid = "13">| S | Figure 2: A tiered graphic representing the three different SRL model configurations.</S>
			<S sid ="147" ssid = "14">The baseline system is described in the bottom (c &amp; d), the separate panels highlighting the independent predictions of this model: sense labels are assigned in an entirely separate process from argument prediction.</S>
			<S sid ="148" ssid = "15">Pruning in the model takes place primarily in this tier, since we observe true predicates we only instantiate over these indices.</S>
			<S sid ="149" ssid = "16">The middle tier (b.) illustrates the syntactic representation layer, and the connective factors between syntax and SRL.</S>
			<S sid ="150" ssid = "17">In the observed syntax model the Link variables are clamped to their correct values, with no need for a factor to coordinate them to form a valid tree.</S>
			<S sid ="151" ssid = "18">Finally, the hidden model comprises all layers, including a combinatorial syntactic constraint (a.) over syntactic variables.</S>
			<S sid ="152" ssid = "19">In this scenario all labels in (b.) are hidden at both training and test time.</S>
			<S sid ="153" ssid = "20">feature-rich classifiers to the parsed trees.</S>
			<S sid ="154" ssid = "21">Related work has recognized the large annotation burden the task demands, but aimed to keep the syntactic annotations and induce semantic roles (Lang and Lapata, 2010).</S>
			<S sid ="155" ssid = "22">In this section we will take the opposite approach, disregarding the syntactic annotations which we argue are more costly to acquire, as they require more formal linguistic training to produce.</S>
			<S sid ="156" ssid = "23">4.1 Model.</S>
			<S sid ="157" ssid = "24">We present a simple, flexible model for SRL in which sense predictions are made independently of the rest of the model, and argument predictions are made independently of each other.</S>
			<S sid ="158" ssid = "25">The model structure is composed as depicted in Fig.</S>
			<S sid ="159" ssid = "26">2.</S>
			<S sid ="160" ssid = "27">• Let {Arg(i, j) : 0 ≤ i &lt; j ≤ n} be O(n2) iff predicate i takes token j as an argument.</S>
			<S sid ="161" ssid = "28">• Let {Role(i, j, λ) : λ ∈ L, and 0 ≤ i &lt; j ≤ n} be O(|L|n2) boolean variables such that Role(i, j, λ) = true iff Arg(i, j) is true and takes the role label λ.</S>
			<S sid ="162" ssid = "29">• Let {Sense(i, σ) : σ ∈ S, and 0 ≤ i ≤ n} be O(|S|n) boolean variables such that Sense(i, σ) = true iff predicate i has sense σ.</S>
			<S sid ="163" ssid = "30">4.1.1 Features At the coarsest level both the SRL and RE models are specifying binary predictions between a pair of indices in the sentence, and a set of labels for each dependency that happens to be true.</S>
			<S sid ="164" ssid = "31">Similarly we Figure 3: Examining the learned hidden representation for SRL.</S>
			<S sid ="165" ssid = "32">In this example the syntactic dependency arcs derived from gold standard syntactic annotations (left) are entirely disjoint from the correct predicate/arguments pairs (shown in the heatmaps by the squares outlined in black), and the observed syntax model fails to recover any of the correct predictions.</S>
			<S sid ="166" ssid = "33">In contrast, the hidden model structure (right) learns a representation that closely parallels the desired end task predictions, helping it recover three of the four correct SRL predictions (shaded arcs: red corresponds to a correct prediction, with true labels GA, KARA, etc.), and providing some evidence towards the fourth.</S>
			<S sid ="167" ssid = "34">The dependency tree corresponding to the hidden structure is derived by edge-factored decoding: dependency variables whose beliefs &gt; 0.5 are classified as true (though some arcs not relevant to the SRL predictions are omitted for clarity).</S>
			<S sid ="168" ssid = "35">RE, with the sole exception that we incorporate the observable lemma and morphological features into bigrams on predicate/argument pairs.</S>
			<S sid ="169" ssid = "36">For sense prediction we rely only on unigram features taken in a close (w = 2) window of the target predicate.</S>
			<S sid ="170" ssid = "37">For the coordinating factors we use subsets of combinations of word, part-of-speech, and capitalization features taken between head and argument, and concatenate these with the distance and direction between the predicate and argument.</S>
			<S sid ="171" ssid = "38">We do not find the performance of the system to be as sensitive to which features are present in the coordinating factors as we did in the RE task.</S>
			<S sid ="172" ssid = "39">4.2 Data.</S>
			<S sid ="173" ssid = "40">We evaluate our SRL model using the data set developed for the CoNLL 2009 shared task competition (Hajicˇ et al., 2009), which features seven languages and provides an ideal opportunity to measure the ability of the hidden structure to generalize across languages of disparate origin and varied characteristics.</S>
			<S sid ="174" ssid = "41">It also provides the opportunity to observe a variety of different annotation styles and biases, some of which our model was able to uncover as ill- suited to common models for the task.</S>
			<S sid ="175" ssid = "42">The data itself provides word, lemma, part-of-speech, and morphological feature information, along with gold dependency parses.</S>
			<S sid ="176" ssid = "43">Words which denote predicates are identified, and their (train time) arguments are provided.</S>
			<S sid ="177" ssid = "44">They are also annotated with a sense label for each predicate, which is scored as an additional SRL dependency.</S>
			<S sid ="178" ssid = "45">Thus the task involves predicting for each predicate a set of argument dependencies and the sense label associated with that predicate.</S>
			<S sid ="179" ssid = "46">D a t a M o d e l Unla bele d L a b e l e d CoNL L 2009 F1 P R F 1 P R F 1 M A X. M EA N M ED . C at al a n B a s e l i n e O r a cl e S y n . H id d e n S y n . 92 .2 0 98 .4 8 95 .2 1 62 .4 3 96 .1 7 92 .8 4 74 .4 8 97 .3 1 94 .0 1 73 .8 0 70 .4 2 68 .8 6 58 .7 6 68 .7 8 67 .1 5 65 .4 3 69 .5 9 67 .9 9 8 0 . 3 7 1 . 0 7 4.</S>
			<S sid ="180" ssid = "47">1 C hi n es e B a s e l i n e O r a cl e S y n . H id d e n S y n . 72 .4 8 98 .5 7 90 .7 9 64 .8 2 78 .9 8 79 .0 9 68 .4 4 87 .6 9 84 .5 3 65 .9 7 87 .6 4 81 .9 7 59 .0 0 70 .2 2 71 .4 0 62 .2 9 77 .9 7 76 .3 2 7 8 . 6 7 2 . 2 7 0.</S>
			<S sid ="181" ssid = "48">4 C z e c h B a s e l i n e O r a cl e S y n . H id d e n S y n . 97 .7 3 98 .6 2 92 .3 9 56 .5 0 81 .2 5 89 .3 5 71 .6 1 89 .0 9 90 .8 5 84 .8 0 92 .9 4 74 .4 1 48 .8 0 68 .2 5 71 .9 6 61 .8 4 74 .8 4 73 .1 6 8 5 . 4 7 2 . 4 7 1.</S>
			<S sid ="182" ssid = "49">7 E n gli s h B a s e l i n e O r a cl e S y n . H id d e n S y n . 92 .4 6 96 .7 5 95 .0 6 71 .5 6 82 .2 5 79 .0 6 80 .6 8 88 .9 1 86 .3 2 84 .5 6 85 .4 8 83 .8 2 65 .4 5 72 .6 7 69 .7 2 73 .7 8 78 .5 5 76 .1 2 8 5 . 6 7 5 . 6 7 2.</S>
			<S sid ="183" ssid = "50">1 G er m a n B a s e l i n e O r a cl e S y n . H id d e n S y n . 93 .4 9 95 .1 8 91 .9 2 44 .2 4 79 .1 1 86 .2 6 60 .0 6 86 .4 1 89 .0 0 75 .0 0 73 .2 4 69 .4 7 35 .4 9 60 .8 7 65 .1 9 48 .1 8 66 .4 9 67 .2 6 7 9 . 7 6 8 . 1 6 7.</S>
			<S sid ="184" ssid = "51">8 Ja pa ne se B a s e l i n e O r a cl e S y n . H id d e n S y n . 91 .6 4 93 .8 4 90 .8 8 43 .3 6 48 .1 5 73 .4 7 58 .8 7 63 .6 4 81 .2 5 80 .4 1 90 .0 6 73 .4 2 38 .0 5 46 .2 1 59 .3 6 51 .6 6 61 .0 8 65 .6 5 7 8 . 2 6 2 . 7 7 2.</S>
			<S sid ="185" ssid = "52">0 S p a ni sh B a s e l i n e O r a cl e S y n . H id d e n S y n . 82 .9 0 98 .9 6 96 .1 5 39 .4 7 94 .1 9 90 .5 3 53 .4 8 96 .5 2 93 .2 5 67 .6 4 70 .6 8 68 .8 1 32 .2 1 67 .2 7 64 .7 9 43 .6 4 68 .9 3 66 .7 4 8 0 . 5 7 0 . 4 7 3.</S>
			<S sid ="186" ssid = "53">4 Table 2: SRL Results.</S>
			<S sid ="187" ssid = "54">The hidden model excels on the unlabeled prediction results, often besting the scores obtained using the parses distributed with the CoNLL data sets.</S>
			<S sid ="188" ssid = "55">These gains did not always translate to the labeled task where poor sense prediction hindered absolute performance.</S>
			<S sid ="189" ssid = "56">4.3 Results.</S>
			<S sid ="190" ssid = "57">We evaluate across a set of model configurations analogous to before.</S>
			<S sid ="191" ssid = "58">All experiments used 30 iterations of SGD with a Gaussian prior, and a max 10 iterations of BP to compute the marginals for each example.</S>
			<S sid ="192" ssid = "59">In comparison to the CoNLL competition entries (Table 2, rightmost columns) our syntactically- informed models generally fall in the middle of the rankings.</S>
			<S sid ="193" ssid = "60">This is not surprising given the independent predictions of the model and the very general, language universal assumptions we have made in the model structure and feature sets.</S>
			<S sid ="194" ssid = "61">However, in terms of gauging the usefulness of the hidden syntactic marginalization method the results are extremely compelling, with only marginal differences between the performance of the observed-syntax model, especially relative to the baseline.</S>
			<S sid ="195" ssid = "62">And despite the simplicity of the model, we still manage to perform at state-of-the-art levels in a few instances, sometimes outperforming most of the competition entries without observing any syntax.</S>
			<S sid ="196" ssid = "63">The performance on Chinese is an example of this, with our system outperforming all but the best system, and the hidden syntactic model only slightly behind.</S>
			<S sid ="197" ssid = "64">Abstracting away from the performance comparisons against other systems, the unlabeled results are the more revealing evidence for the use of hidden syntactic structure.</S>
			<S sid ="198" ssid = "65">Here the average hidden model score (88.89) almost outperforms the observed syntax model (90.22, and vs. 66.80 baseline), mostly due to the large margins on the unlabeled Japanese scores.</S>
			<S sid ="199" ssid = "66">The strong independence between sense prediction and argument prediction hinders performance on the labeled task, but on all languages we find an extremely significant improvement exploiting hidden syntactic structure in comparison to the baseline system—the hidden model recovers more than 92% of the gap between the baseline and the observed syntax model.</S>
			<S sid ="200" ssid = "67">It is also interesting to note that in the shared task competition the two languages which systems lost the most performance between their parsing F1 and their SRL F1 were Japanese and German.</S>
			<S sid ="201" ssid = "68">As illustrated in Fig.</S>
			<S sid ="202" ssid = "69">3, the corre spondence between syntax and SRL are extremely, and systematically, poor.</S>
			<S sid ="203" ssid = "70">In this example our hidden structure model was able to assign strong beliefs to the latent syntactic variables which correspond to the correct predicate/argument pairs, allowing it to correctly identify three of the four SRL arguments when the joint model failed to recover one.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "5">
			<S sid ="204" ssid = "1">This work is perhaps mostly closely related to the Learning over Constrained Latent Representations (LCLR) framework of Chang et al.</S>
			<S sid ="205" ssid = "2">(2010).</S>
			<S sid ="206" ssid = "3">Their abstract problem formulation is identical: both paradigms seek to couple the end task to an intermediate representation which is not accessible to the learning algorithm.</S>
			<S sid ="207" ssid = "4">However much of the intent, scale, and methodology is different.</S>
			<S sid ="208" ssid = "5">LCLR aims to provide a flexible latent structure for increasing the representational power of the model in a useful way, and is demonstrated on tasks and domains where data availability is not a key concern.</S>
			<S sid ="209" ssid = "6">In contrast, while our hidden structure models may outperform their observed syntax counterparts, our focus is as much on alleviating the burden of procuring large amounts of syntactic annotation as it is about increasing the expressiveness of the model.</S>
			<S sid ="210" ssid = "7">To that end we constrain a more sophisticated latent representation and couple it to highly structured output predictions, opposed to binary classification problems.</S>
			<S sid ="211" ssid = "8">In methodology, we perform the more computationally intensive marginalization operation instead of maximizing.</S>
			<S sid ="212" ssid = "9">Marginalization of hidden structure is also fundamental to other work, and featured most prominently in generative Bayesian latent variable models (Teh et al., 2006).</S>
			<S sid ="213" ssid = "10">Our approach is trained discriminatively, affording the use of very rich feature sets and the prediction of partial structures without needing to specify a full derivation.</S>
			<S sid ="214" ssid = "11">Similar approaches have been used in more linear latent variable CRF-based models (McCallum et al., 2005), but these must only marginalize only over hidden states of a much more compact representation.</S>
			<S sid ="215" ssid = "12">Naively extending this to tree-based constraints would often be computationally inefficient, and we avoid intractability through the encapsulation of much of the dynamic programming machinery into specialized factors.</S>
			<S sid ="216" ssid = "13">Moreover, using loopy belief propagation means that the inference method is not closely coupled to the task structure, and need not change when applying this method to other types of graphs.</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "6">
			<S sid ="217" ssid = "1">We have presented a novel method of coupling syntactically-oriented NLP tasks to combinatorially- constrained hidden syntactic representations, and have shown that marginalizing over this latent representation not only provides significant improvements over syntactically-uninformed baselines, but occasionally improves performance when compared to systems which observe syntax.</S>
			<S sid ="218" ssid = "2">On the task of relation extraction we find that a constituency representation provides the most improvement over the baseline, while in the SRL domain our model is extremely competitive with the best reported results on Chinese, and outperforms the model using the provided parses on German and Japanese.</S>
			<S sid ="219" ssid = "3">We believe this method delivers very promising results in our presented tasks, opening the door to new lines of research examining what types of constraints and what configurations of hidden structure are most beneficial for particular tasks and languages.</S>
			<S sid ="220" ssid = "4">Moreover, we present one type of coordinating factor, as both D-CONNECT and C-CONNECT logically express a soft NAND function, but more sophisticated coupling schemes are another natural direction to pursue.</S>
			<S sid ="221" ssid = "5">Finally, we use sum-product variant of belief propagation inference, but more specialized inference schemes may show additional benefits.</S>
	</SECTION>
	<SECTION title="Acknowledgements">
			<S sid ="222" ssid = "6">We would like to thank Andrea Gesmundo for help in procuring sections of the CoNLL 2009 shared task data.</S>
			<S sid ="223" ssid = "7">This work was supported in part by the Center for Intelligent Information Retrieval and in part by Army prime contract number W911NF07-10216 and University of Pennsylvania subaward number 103548106.</S>
			<S sid ="224" ssid = "8">The University of Massachusetts also gratefully acknowledges the support of Defense Advanced Research Projects Agency (DARPA) Machine Reading Program under Air Force Research Laboratory (AFRL) prime contract no.</S>
			<S sid ="225" ssid = "9">FA875009-C-0181.</S>
			<S sid ="226" ssid = "10">Any opinions, findings, and conclusion or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of the DARPA, AFRL, or the US government.</S>
	</SECTION>
</PAPER>
