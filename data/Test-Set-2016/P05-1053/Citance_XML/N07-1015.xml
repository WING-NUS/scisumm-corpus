<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Relation extraction is the task of finding semantic relations between entities from text.</S>
		<S sid ="2" ssid = "2">The state-of-the-art methods for relation extraction are mostly based on statistical learning, and thus all have to deal with feature selection, which can significantly affect the classification performance.</S>
		<S sid ="3" ssid = "3">In this paper, we systematically explore a large space of features for relation extraction and evaluate the effectiveness of different feature subspaces.</S>
		<S sid ="4" ssid = "4">We present a general definition of feature spaces based on a graphic representation of relation instances, and explore three different representations of relation instances and features of different complexities within this framework.</S>
		<S sid ="5" ssid = "5">Our experiments show that using only basic unit features is generally sufficient to achieve state-of-the-art performance, while over- inclusion of complex features may hurt the performance.</S>
		<S sid ="6" ssid = "6">A combination of features of different levels of complexity and from different sentence representations, coupled with task-oriented feature pruning, gives the best performance.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">An important information extraction task is relation extraction, whose goal is to detect and characterize semantic relations between entities in text.</S>
			<S sid ="8" ssid = "8">For example, the text fragment “hundreds of Palestinians converged on the square” contains the located relation between the Person entity “hundreds of Palestinians” and the Bounded-Area entity “the square”.</S>
			<S sid ="9" ssid = "9">Relation extraction has applications in many domains, including finding affiliation relations from web pages and finding protein-protein interactions from biomedical literature.</S>
			<S sid ="10" ssid = "10">Recent studies on relation extraction have shown the advantages of discriminative model-based statistical machine learning approach to this problem.</S>
			<S sid ="11" ssid = "11">There are generally two lines of work following this approach.</S>
			<S sid ="12" ssid = "12">The first utilizes a set of carefully selected features obtained from different levels of text analysis, from part-of-speech (POS) tagging to full parsing and dependency parsing (Kambhatla, 2004; Zhao and Grishman, 2005; Zhou et al., 2005)1.</S>
			<S sid ="13" ssid = "13">The second line of work designs kernel functions on some structured representation (sequences or trees) of the relation instances to capture the similarity between two relation instances (Zelenko et al., 2003; Culotta and Sorensen, 2004; Bunescu and Mooney, 2005a; Bunescu and Mooney, 2005b; Zhang et al., 2006a; Zhang et al., 2006b).</S>
			<S sid ="14" ssid = "14">Of particular interest among the various kernels proposed are the convolution kernels (Bunescu and Mooney, 2005b; Zhang et al., 2006a), because they can efficiently compute the similarity between two instances in a huge feature space due to their recursive nature.</S>
			<S sid ="15" ssid = "15">Apart from their computational efficiency, convolution kernels also implicitly correspond to some feature space.</S>
			<S sid ="16" ssid = "16">Therefore, both lines of work rely on an appropriately de 1 Although Zhao and Grishman (2005) defined a number of kernels for relation extraction, the method is essentially similar to feature-based methods.</S>
			<S sid ="17" ssid = "17">113 Proceedings of NAACL HLT 2007, pages 113–120, Rochester, NY, April 2007.</S>
			<S sid ="18" ssid = "18">Qc 2007 Association for Computational Linguistics fined set of features.</S>
			<S sid ="19" ssid = "19">As in any learning problem, the choice of features can affect the performance significantly.</S>
			<S sid ="20" ssid = "20">Despite the importance of feature selection, there has not been any systematic exploration of the feature space for relation extraction, and the choices of features in existing work are somewhat arbitrary.</S>
			<S sid ="21" ssid = "21">In this paper, we conduct a systematic study of the feature space for relation extraction, and evaluate the effectiveness of different feature subspaces.</S>
			<S sid ="22" ssid = "22">Our motivations are twofold.</S>
			<S sid ="23" ssid = "23">First, based on previous studies, we want to identify and characterize the types of features that are potentially useful for relation extraction, and define a relatively complete and structured feature space that can be systematically explored.</S>
			<S sid ="24" ssid = "24">Second, we want to compare the effectiveness of different features.</S>
			<S sid ="25" ssid = "25">Such a study can guide us to choose the most effective feature set for relation extraction, or to design convolution kernels in the most effective way.</S>
			<S sid ="26" ssid = "26">We propose and define a unified graphic representation of the feature space, and experiment with three feature subspaces, corresponding to sequences, syntactic parse trees and dependency parse trees.</S>
			<S sid ="27" ssid = "27">Experiment results show that each subspace is effective by itself, with the syntactic parse tree subspace being the most effective.</S>
			<S sid ="28" ssid = "28">Combining the three subspaces does not generate much improvement.</S>
			<S sid ="29" ssid = "29">Within each feature subspace, using only the basic unit features can already give reasonably good performance.</S>
			<S sid ="30" ssid = "30">Adding more complex features may not improve the performance much or may even hurt the performance.</S>
			<S sid ="31" ssid = "31">Task-oriented heuristics can be used to prune the feature space, and when appropriately done, can improve the performance.</S>
			<S sid ="32" ssid = "32">A combination of features of different levels of complexity and from different sentence representations, coupled with task-oriented feature pruning, gives the best performance.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "2">
			<S sid ="33" ssid = "1">Zhao and Grishman (2005) and Zhou et al.</S>
			<S sid ="34" ssid = "2">(2005) explored a large set of features that are potentially useful for relation extraction.</S>
			<S sid ="35" ssid = "3">However, the feature space was defined and explored in a somewhat ad hoc manner.</S>
			<S sid ="36" ssid = "4">We study a broader scope of features and perform a more systematic study of different feature subspaces.</S>
			<S sid ="37" ssid = "5">Zelenko et al.</S>
			<S sid ="38" ssid = "6">(2003) and Culotta and Sorensen (2004) used tree kernels for relation extraction.</S>
			<S sid ="39" ssid = "7">These kernels can achieve high precision but low recall because of the relatively strict matching criteria.</S>
			<S sid ="40" ssid = "8">Bunescu and Mooney (2005a) proposed a dependency path kernel for relation extraction.</S>
			<S sid ="41" ssid = "9">This kernel also suffers from low recall for the same reason.</S>
			<S sid ="42" ssid = "10">Bunescu and Mooney (2005b) and Zhang et.</S>
			<S sid ="43" ssid = "11">al.</S>
			<S sid ="44" ssid = "12">(2006a; 2006b) applied convolution string kernels and tree kernels, respectively, to relation extraction.</S>
			<S sid ="45" ssid = "13">The convolution tree kernels achieved state- of-the-art performance.</S>
			<S sid ="46" ssid = "14">Since convolution kernels correspond to some explicit large feature spaces, the feature selection problem still remains.</S>
			<S sid ="47" ssid = "15">General structural representations of natural language data have been studied in (Suzuki et al., 2003; Cumby and Roth, 2003), but these models were not designed specifically for relation extraction.</S>
			<S sid ="48" ssid = "16">Our feature definition is similar to these models, but more specifically designed for relation extraction and systematic exploration of the feature space.</S>
			<S sid ="49" ssid = "17">Compared with (Cumby and Roth, 2003), our feature space is more compact and provides more guidance on selecting meaningful subspaces.</S>
	</SECTION>
	<SECTION title="Task Definition. " number = "3">
			<S sid ="50" ssid = "1">Given a small piece of text that contains two entity mentions, the task of relation extraction is to decide whether the text states some semantic relation between the two entities, and if so, classify the relation into one of a set of predefined semantic relation types.</S>
			<S sid ="51" ssid = "2">Formally, let r = (s, arg 1, arg 2) denote a relation instance, where s is a sentence, arg 1 and arg 2 are two entity mentions contained in s, and arg 1 precedes arg 2 in the text.</S>
			<S sid ="52" ssid = "3">Given a set of rela tion instances {ri}, each labeled with a type ti ∈ T , where T is the set of predefined relation types plus the type nil, our goal is to learn a function that maps a relation instance r to a type t ∈ T . Note that we do not specify the representation of s here.</S>
			<S sid ="53" ssid = "4">Indeed, s can contain more structured information in addition to merely the sequence of tokens in the sentence.</S>
	</SECTION>
	<SECTION title="Feature Space for Relation Extraction. " number = "4">
			<S sid ="54" ssid = "1">Ideally, we would like to define a feature space with at least two properties: (1) It should be complete in the sense that all features potentially useful for the classification problem are included.</S>
			<S sid ="55" ssid = "2">(2) It should have a good structure so that a systematic search in the space is possible.</S>
			<S sid ="56" ssid = "3">Below we show how a unified graph-based feature space can be defined to satisfy these two properties.</S>
			<S sid ="57" ssid = "4">4.1 A Unified View of Features for Relation Extraction Before we introduce our definition of the feature space, let us first look at some typical features used for relation extraction.</S>
			<S sid ="58" ssid = "5">Consider the relation instance “hundreds of Palestinians converged on the square” with arg 1 = “hundreds of Palestinians” and arg 2 = “the square”.</S>
			<S sid ="59" ssid = "6">Various types of information can be useful for classifying this relation instance.</S>
			<S sid ="60" ssid = "7">For example, knowing that arg 1 is an entity of type Person can be useful.</S>
			<S sid ="61" ssid = "8">This feature involves the single token “Palestinians”.</S>
			<S sid ="62" ssid = "9">Another feature, “the head word of arg 1 (Palestinians) is followed by a verb (converged)”, can also be useful.</S>
			<S sid ="63" ssid = "10">This feature involves two tokens, “Palestinians” and “converged”, with a sequence relation.</S>
			<S sid ="64" ssid = "11">It also involves the knowledge that “Palestinians” is part of arg 1 and “converged” is a verb.</S>
			<S sid ="65" ssid = "12">If we have the syntactic parse tree of the sentence, we can obtain even more complex and discriminative features.</S>
			<S sid ="66" ssid = "13">For example, the syntactic parse tree of the same relation instance con tains the following subtree: [VP → VBD [PP → [IN → on] NP] ].</S>
			<S sid ="67" ssid = "14">If we know that arg 2 is contained in the NP in this subtree, then this subtree states that arg 2 is in a PP that is attached to a VP, and the proposition is “on”.</S>
			<S sid ="68" ssid = "15">This subtree therefore may also a useful feature.</S>
			<S sid ="69" ssid = "16">Similarly, if we have the dependency parse tree of the relation instance, then the dependency link “square &quot;V&apos; on” states that the token “square” is dependent on the token “on”, which may also be a useful feature.</S>
			<S sid ="70" ssid = "17">Given that useful features are of various forms, in order to systematically search the feature space, we need to first have a unified view of features.</S>
			<S sid ="71" ssid = "18">This problem is not trivial because it is not immediately clear how different types of features can be unified.</S>
			<S sid ="72" ssid = "19">We observe, however, that in general features fall into two categories: (1) properties of a single token, and (2) relations between tokens.</S>
			<S sid ="73" ssid = "20">Features that involve attributes of a single token, such as bag-of- word features and entity attribute features, belong to the first category, while features that involve se quence, syntactic or dependency relations between tokens belong to the second category.</S>
			<S sid ="74" ssid = "21">Motivated by this observation, we can represent relation instances as graphs, with nodes denoting single tokens or syntactic categories such as NPs and VPs, and edges denoting various types of relations between the nodes.</S>
			<S sid ="75" ssid = "22">4.2 Relation Instance Graphs.</S>
			<S sid ="76" ssid = "23">We represent a relation instance as a labeled, directed graph G = (V, E, A, B), where V is the set of nodes in the graph, E is the set of directed edges in the graph, and A, B are functions that assign labels to the nodes.</S>
			<S sid ="77" ssid = "24">First, for each node v ∈ V , A(v) = {a1, a2, . . .</S>
			<S sid ="78" ssid = "25">, a|A(v)|} is a set of attributes associated with node v, where ai ∈ Σ, and Σ is an alphabet that contains all possible attribute values.</S>
			<S sid ="79" ssid = "26">The attributes are introduced to help generalize the node.</S>
			<S sid ="80" ssid = "27">For example, if node v represents a token, then A(v) can include the token itself, its morphological base form, its POS, its semantic class (e.g. WordNet synset), etc. If v also happens to be the head word of arg 1 or arg 2, then A(v) can also include the entity type and other entity attributes.</S>
			<S sid ="81" ssid = "28">If node v represents a syntactic category such as an NP or VP, A(v) can simply contain only the syntactic tag.</S>
			<S sid ="82" ssid = "29">Next, function B : V → {0, 1, 2, 3} is introduced to distinguish argument nodes from non-argument nodes.</S>
			<S sid ="83" ssid = "30">For each node v ∈ V , B(v) indicates how node v is related to arg 1 and arg 2.</S>
			<S sid ="84" ssid = "31">0 indicates that v does not cover any argument, 1 or 2 indicates that v covers arg 1 or arg 2, respectively, and 3 indicates that v covers both arguments.</S>
			<S sid ="85" ssid = "32">We will see shortly that only nodes that represent syntactic categories in a syntactic parse tree can possibly be assigned 3.</S>
			<S sid ="86" ssid = "33">We refer to B(v) as the argument tag of v. We now consider three special instantiations of this general definition of relation instance graphs.</S>
			<S sid ="87" ssid = "34">See Figures 1, 2 and 3 for examples of each of the three representations.</S>
			<S sid ="88" ssid = "35">Sequence: Without introducing any additional structured information, a sequence representation preserves the order of the tokens as they occur in the original sentence.</S>
			<S sid ="89" ssid = "36">Each node in this graph is a token augmented with its relevant attributes.</S>
			<S sid ="90" ssid = "37">For example, head words of arg 1 and arg 2 are augmented with the corresponding entity types.</S>
			<S sid ="91" ssid = "38">A token is assigned the argument tag 1 or 2 if it is the head word of arg 1 or 1 0 2 0 1 Person VBD Bounded-Area of Palestinians 0 0 1 0 0 0 2 NNS hundreds IN NNP of Palestinians VBD IN converged on DT the NN square 0 0 1 0 0 0 2 Person Bounded-Area NNS hundreds IN NNP of Palestinians Person VBD IN converged on DT the NN square Bounded-Area Figure 1: An example sequence representation.</S>
			<S sid ="92" ssid = "39">The subgraph on the left represents a bigram feature.</S>
			<S sid ="93" ssid = "40">The subgraph on the right represents a unigram feature that states the entity type of arg 2.</S>
			<S sid ="94" ssid = "41">Figure 3: An example dependency parse tree representation.</S>
			<S sid ="95" ssid = "42">The subgraph represents a dependency relation feature between arg 1 “Palestinians” and “of ”.</S>
			<S sid ="96" ssid = "43">2 PP.</S>
			<S sid ="97" ssid = "44">3 2 NPB the dependency relation types.</S>
			<S sid ="98" ssid = "45">S 2 1 VP.</S>
			<S sid ="99" ssid = "46">NP 1 PP 0 1 NPB NPB 0 0 2 on DT Bounded-Area 2 PP 2 NPB 4 . 3 F e a t u r e s Given the above definition of relation instance graphs, we are now ready to define features.</S>
			<S sid ="100" ssid = "47">Intuitively, a feature of a relation instance captures part of the attributive and/or structural properties of the 0 0 1 0 0 0 2 NNS hundreds IN NN P of Palestini ans Pers on VBD I N converged on DT the NN square Bounded-Area relation instanc e graph.</S>
			<S sid ="101" ssid = "48">Theref ore, it is natural to de fine a feature as a subgra ph of the relatio n instan ce graph.</S>
			<S sid ="102" ssid = "49">Forma lly, given a graph G = (V, E, A, B), Figure 2: An example syntactic parse tree representation.</S>
			<S sid ="103" ssid = "50">The subgraph represents a subtree feature (grammar production feature).</S>
			<S sid ="104" ssid = "51">arg 2.</S>
			<S sid ="105" ssid = "52">Otherwise, it is assigned the argument tag 0.</S>
			<S sid ="106" ssid = "53">There is a directed edge from u to v if and only if the token represented by v immediately follows that represented by u in the sentence.</S>
			<S sid ="107" ssid = "54">Syntactic Parse Tree: The syntactic parse tree of the relation instance sentence can be augmented to represent the relation instance.</S>
			<S sid ="108" ssid = "55">First, we modify the tree slightly by conflating each leaf node in the original parse tree with its parent, which is a preterminal node labeled with a POS tag.</S>
			<S sid ="109" ssid = "56">Then, each node is augmented with relevant attributes if necessary.</S>
			<S sid ="110" ssid = "57">Argument tags are assigned to the leaf nodes in the same way as in the sequence representation.</S>
			<S sid ="111" ssid = "58">For an internal node v, argument tag 1 or 2 is assigned if either arg 1 or arg 2 is inside the subtree rooted at v, and 3 is assigned if both arguments are inside the subtree.</S>
			<S sid ="112" ssid = "59">Otherwise, 0 is assigned to v. Dependency Parse Tree: Similarly, the dependency parse tree can also be modified to represent the relation instance.</S>
			<S sid ="113" ssid = "60">Assignment of attributes and argument tags is the same as for the sequence representation.</S>
			<S sid ="114" ssid = "61">To simplify the representation, we ignore which represents a single relation instance, a feature that exists in this relation instance is a sub- graph Gt = (V t, Et, At, Bt) that satisfies the fol lowing conditions: V t ⊆ V , Et ⊆ E, and ∀v ∈ V t, At(v) ⊆ A(v), Bt(v) = B(v).</S>
			<S sid ="115" ssid = "62">We now show that many features that have been explored in previous work on relation extraction can be transformed into this graphic representation.</S>
			<S sid ="116" ssid = "63">See Figures 1, 2 and 3 for some examples.</S>
			<S sid ="117" ssid = "64">Entity Attributes: Previous studies have shown that entity types and entity mention types of arg 1 and arg 2 are very useful (Zhao and Grishman, 2005; Zhou et al., 2005; Zhang et al., 2006b).</S>
			<S sid ="118" ssid = "65">To represent a single entity attribute, we can take a subgraph that contains only the node representing the head word of the argument, labeled with the entity type or entity mention type.</S>
			<S sid ="119" ssid = "66">A particularly useful type of features are conjunctive entity features, which are conjunctions of two entity attributes, one for each argument.</S>
			<S sid ="120" ssid = "67">To represent a conjunctive feature such as “arg 1 is a Person entity and arg 2 is a Bounded-Area entity”, we can take a subgraph that contains two nodes, one for each argument, and each labeled with an entity attribute.</S>
			<S sid ="121" ssid = "68">Note that in this case, the subgraph contains two disconnected components, which is al lowed by our definition.</S>
			<S sid ="122" ssid = "69">Bag-of-Words: These features have also been explore by Zhao and Grishman (2005) and Zhou et.</S>
			<S sid ="123" ssid = "70">al.</S>
			<S sid ="124" ssid = "71">(2005).</S>
			<S sid ="125" ssid = "72">To represent a bag-of-word feature, we can simply take a subgraph that contains a single node labeled with the token.</S>
			<S sid ="126" ssid = "73">Because the node also has an argument tag, we can distinguish between argument word and non-argument word.</S>
			<S sid ="127" ssid = "74">Bigrams: A bigram feature (Zhao and Grishman, 2005) can be represented by a subgraph consisting of two connected nodes from the sequence representation, where each node is labeled with the token.</S>
			<S sid ="128" ssid = "75">Grammar Productions: The features in convolution tree kernels for relation extraction (Zhang et al., 2006a; Zhang et al., 2006b) are sequences of grammar productions, that is, complete subtrees of the syntactic parse tree.</S>
			<S sid ="129" ssid = "76">Therefore, these features can naturally be represented by subgraphs of the relation instance graphs.</S>
			<S sid ="130" ssid = "77">Dependency Relations and Dependency Paths: These features have been explored by Bunescu and Mooney (2005a), Zhao and Grishman (2005), and Zhou et.</S>
			<S sid ="131" ssid = "78">al.</S>
			<S sid ="132" ssid = "79">(2005).</S>
			<S sid ="133" ssid = "80">A dependency relation can be represented as an edge connecting two nodes from the dependency tree.</S>
			<S sid ="134" ssid = "81">The dependency path between the two arguments can also be easily represented as a path in the dependency tree connecting the two nodes that represent the two arguments.</S>
			<S sid ="135" ssid = "82">There are some features that are not covered by our current definition, but can be included if we modify our relation instance graphs.</S>
			<S sid ="136" ssid = "83">For example, gapped subsequence features in subsequence kernels (Bunescu and Mooney, 2005b) can be represented as subgraphs of the sequence representation if we add more edges to connect any pair of nodes u and v provided that the token represented by u occurs somewhere before that represented by v in the sentence.</S>
			<S sid ="137" ssid = "84">Since our feature definition is very general, our feature space also includes many features that have not been explored before.</S>
			<S sid ="138" ssid = "85">4.4 Searching the Feature Space.</S>
			<S sid ="139" ssid = "86">Although the feature space we have defined is relatively complete and has a clear structure, it is still too expensive to exhaustively search the space because the number of features is exponential in terms of the size of the relation instance graph.</S>
			<S sid ="140" ssid = "87">We thus propose to search the feature space in the following bottom-up manner: We start with the conjunctive entity features (defined in Section 4.3), which have been found effective in previous studies and are intuitively necessary for relation extraction.</S>
			<S sid ="141" ssid = "88">We then systematically add unit features with different granularities.</S>
			<S sid ="142" ssid = "89">We first consider the minimum (i.e. most basic) unit features.</S>
			<S sid ="143" ssid = "90">We then gradually include more complex features.</S>
			<S sid ="144" ssid = "91">The motivations for this strategy are the following: (1) Using the smallest features to represent a relation instance graph presumably covers all unit characteristics of the graph.</S>
			<S sid ="145" ssid = "92">(2) Using small subgraphs allows fuzzy matching, which is good for our task because relation instances of the same type may vary in their relation instance graphs, especially with the noise introduced by adjectives, adverbs, or irrelevant propositional phrases.</S>
			<S sid ="146" ssid = "93">(3) The number of features of a fixed small size is polynomial in terms of the size of the relation instance graph.</S>
			<S sid ="147" ssid = "94">It is therefore feasible to generate all the small unit features and use any classifier such as a maximum entropy classifier or an SVM.</S>
			<S sid ="148" ssid = "95">In our experiments, we consider three levels of small unit features in increasing order of their complexity.</S>
			<S sid ="149" ssid = "96">First, we consider unigram features Guni = ({u}, ∅, Auni , B), where Auni (u) = {ai} ⊆ A(u).In another word, unigram features consist of a sin gle node labeled with a single attribute.</S>
			<S sid ="150" ssid = "97">Examples of unigram features include bag-of-word features and non-conjunctive entity attribute features.</S>
			<S sid ="151" ssid = "98">At the second level, we consider bigram features Gbi = ({u, v}, {(u, v)}, Auni , B).</S>
			<S sid ="152" ssid = "99">Bigram features are therefore single edges connecting two nodes, where each node is labeled with a single attribute.</S>
			<S sid ="153" ssid = "100">The third level of attributes we consider are trigram fea tures Gtri = ({u, v, w}, {(u, v), (u, w)}, Auni , B) or Gtri = ({u, v, w}, {(u, v), (v, w)}, Auni , B).</S>
			<S sid ="154" ssid = "101">Thus trigram features consist of two connected edges and three nodes, where each node is also labeled with a single attribute.</S>
			<S sid ="155" ssid = "102">We treat the three relation instance graphs (sequences, syntactic parse trees, and dependency parse trees) as three feature subspaces, and search in each subspace.</S>
			<S sid ="156" ssid = "103">For each feature subspace, we incremen- tally add the unigram, bigram and trigram features to the working feature set.</S>
			<S sid ="157" ssid = "104">For the syntactic parse tree representation, we also consider a fourth level of small unit features, which are single grammar pro ductions such as [VP → VBD PP], because these are the smallest features in convolution tree kernels.</S>
			<S sid ="158" ssid = "105">After we explore each feature subspace, we try to combine the features from the three subspaces to see whether the performance can be improved, that is, we test whether the sequence, syntactic and dependency relations can complement each other.</S>
	</SECTION>
	<SECTION title="Experiments. " number = "5">
			<S sid ="159" ssid = "1">5.1 Data Set and Experiment Setup.</S>
			<S sid ="160" ssid = "2">We used the data set from ACE (Automatic Content Extraction) 2004 evaluation to conduct our experiments.</S>
			<S sid ="161" ssid = "3">This corpus defines 7 types of relations: Physical, Personal / Social, Empolyment / Memeber- ship / Subsidiary, Agent-Artifact, PER / ORG Affiliation, GPE Affiliation and Discourse.</S>
			<S sid ="162" ssid = "4">We used Collins parser to parse the sentences in the corpus because Collins parser gives us the head of each syntactic category, which allows us to transform the syntactic parse trees into dependency trees.</S>
			<S sid ="163" ssid = "5">We discarded sentences that could not be parsed by Collins parser.</S>
			<S sid ="164" ssid = "6">The candidate relation instances were generated by considering all pairs of entities that occur in the same sentence.</S>
			<S sid ="165" ssid = "7">We obtained 48625 candidate relation instances in total, among which 4296 instances were positive.</S>
			<S sid ="166" ssid = "8">As in most existing work, instead of using the entire sentence, we used only the sequence of tokens that are inside the minimum complete subtree covering the two arguments.</S>
			<S sid ="167" ssid = "9">Presumably, tokens outside of this subtree are not so relevant to the task.</S>
			<S sid ="168" ssid = "10">In our graphic representation of relation instances, the attribute set for a token node includes the token itself, its POS tag, and entity type, entity subtype and entity mention type when applicable.</S>
			<S sid ="169" ssid = "11">The attribute set for a syntactic category node includes only the syntactic tag.</S>
			<S sid ="170" ssid = "12">We used both maximum entropy classifier and SVM for all experiments.</S>
			<S sid ="171" ssid = "13">We adopted one vs. others strategy for the multi-class classification problem.</S>
			<S sid ="172" ssid = "14">In all experiments, the performance shown was based on 5-fold cross validation.</S>
			<S sid ="173" ssid = "15">5.2 General Search in the Feature Subspaces.</S>
			<S sid ="174" ssid = "16">Following the general search strategy, we conducted the following experiments.</S>
			<S sid ="175" ssid = "17">For each feature subspace, we started with the conjunctive entity features plus the unigram features.</S>
			<S sid ="176" ssid = "18">We then incrementally added bigram and trigram features.</S>
			<S sid ="177" ssid = "19">For the syntactic parse tree feature space, we conducted an additional experiment: We added basic grammar produc tion features on top of the unigram, bigram and tri- gram features.</S>
			<S sid ="178" ssid = "20">Adding production features allows us to study the effect of adding more complex and presumably more specific and discriminative features.</S>
			<S sid ="179" ssid = "21">Table 1 shows the precision (P), recall (R) and F1 measure (F) from the experiments with the maximum entropy classifier (ME) and the SVM classifier (SVM).</S>
			<S sid ="180" ssid = "22">We can compare the results in two dimensions.</S>
			<S sid ="181" ssid = "23">First, within each feature subspace, while bigram features improved the performance significantly over unigrams, trigrams did not improve the performance very much.</S>
			<S sid ="182" ssid = "24">This trend is observed for both classifiers.</S>
			<S sid ="183" ssid = "25">In the case of the syntactic parse tree subspace, adding production features even hurt the performance.</S>
			<S sid ="184" ssid = "26">This suggests that inclusion of complex features is not guaranteed to improve the performance.</S>
			<S sid ="185" ssid = "27">Second, if we compare the best performance achieved in each feature subspace, we can see that for both classifiers, syntactic parse tree is the most effective feature space, while sequence and dependency tree are similar.</S>
			<S sid ="186" ssid = "28">However, the difference in performance between the syntactic parse tree subspace and the other two subspaces is not very large.</S>
			<S sid ="187" ssid = "29">This suggests that each feature subspace alone already captures most of the useful structural information between tokens for relation extraction.</S>
			<S sid ="188" ssid = "30">The reason why the sequence feature subspace gave good performance although it contained the least structural information is probably that many relations defined in the ACE corpus are short-range relations, some within single noun phrases.</S>
			<S sid ="189" ssid = "31">For such kind of relations, sequence information may be even more reliable than syntactic or dependency information, which may not be accurate due to parsing errors.</S>
			<S sid ="190" ssid = "32">Next, we conducted experiments to combine the features from the three subspaces to see whether this could further improve the performance.</S>
			<S sid ="191" ssid = "33">For sequence subspace and dependency tree subspace, we used up to bigram features, and for syntactic parse tree subspace, we used up to trigram features.</S>
			<S sid ="192" ssid = "34">In Table 2, we show the experiment results.</S>
			<S sid ="193" ssid = "35">We can see that for both classifiers, adding features from the sequence subspace or from the dependency tree subspace to the syntactic parse tree subspace can improve the performance slightly.</S>
			<S sid ="194" ssid = "36">But combining sequence subspace and dependency tree subspace does not generate any performance improvement.</S>
			<S sid ="195" ssid = "37">Again, U ni + Bi +T ri +P rod M E Se q P R F 0.6 47 0.6 14 0.6 30 0.6 62 0.7 01 0.6 81 0.7 17 0.6 53 0.6 83 N/ A Sy n P R F 0.6 51 0.6 45 0.6 48 0.6 95 0.6 98 0.6 97 0.7 26 0.6 88 0.7 07 0.7 02 0.6 91 0.6 96 De p P R F 0.6 47 0.6 14 0.6 30 0.6 73 0.6 76 0.6 74 0.7 18 0.6 52 0.6 83 N/ A SV M Se q P R F 0.5 83 0.5 86 0.5 85 0.6 66 0.6 50 0.6 58 0.6 84 0.6 48 0.6 65 N/ A Sy n P R F 0.5 98 0.6 11 0.6 04 0.6 45 0.6 63 0.6 54 0.6 79 0.6 81 0.6 80 0.6 74 0.6 72 0.6 73 De p P R F 0.5 83 0.5 86 0.5 85 0.6 44 0.6 38 0.6 41 0.6 82 0.6 45 0.6 63 N/ A Table 1: Comparison among the three feature subspaces and the effect of including larger features.</S>
			<S sid ="196" ssid = "38">Se q+ Sy n Se q+ De p Sy n+ De p A ll M E P R F 0.</S>
			<S sid ="197" ssid = "39">7 3 7 0.</S>
			<S sid ="198" ssid = "40">6 9 4 0.</S>
			<S sid ="199" ssid = "41">7 1 5 0 . 6 8 7 0 . 6 8 2 0 . 6 8 4 0 . 6 9 5 0 . 7 3 1 0 . 7 1 2 0.7 24 0.7 02 0.7 13 SV M P R F 0.</S>
			<S sid ="200" ssid = "42">6 8 9 0.</S>
			<S sid ="201" ssid = "43">6 8 6 0.</S>
			<S sid ="202" ssid = "44">6 8 8 0 . 6 6 9 0 . 6 5 3 0 . 6 6 1 0 . 6 8 7 0 . 6 8 2 0 . 6 8 4 0.6 91 0.6 86 0.6 88 Table 2: The effect of combining the three feature subspaces.</S>
			<S sid ="203" ssid = "45">this suggests that since many of the ACE relations are local, there is likely much overlap between sequence information and dependency information.</S>
			<S sid ="204" ssid = "46">We also tried the convolution tree kernel method (Zhang et al., 2006a), using an SVM tree kernel package2.</S>
			<S sid ="205" ssid = "47">The performance we obtained was P = 0.705, R = 0.685, and F = 0.6953.</S>
			<S sid ="206" ssid = "48">This F measure is higher than the best SVM performance in Table 1.</S>
			<S sid ="207" ssid = "49">The convolution tree kernel uses large subtree features, but such features are deemphasized with an exponentially decaying weight.</S>
			<S sid ="208" ssid = "50">We found that the performance was sensitive to this decaying factor, suggesting that complex features can be useful if they are weighted appropriately, and further study of how to optimize the weights of such complex features is needed.</S>
			<S sid ="209" ssid = "51">2 http://ainlp.info.uniroma2.it/moschitti/Tree-Kernel.htm 3 The performance we achieved is lower than that reported in (Zhang et al., 2006b), due to different data preprocessing, data partition, and parameter setting.</S>
			<S sid ="210" ssid = "52">5.3 Task-Oriented Feature Pruning.</S>
			<S sid ="211" ssid = "53">Apart from the general bottom-up search strategy we have proposed, we can also introduce some task- oriented heuristics based on intuition or domain knowledge to prune the feature space.</S>
			<S sid ="212" ssid = "54">In our experiments, we tried the following heuristics.</S>
			<S sid ="213" ssid = "55">H1: Zhang et al.</S>
			<S sid ="214" ssid = "56">(2006a) found that using path- enclosed tree performed better than using minimum complete tree, when convolution tree kernels were applied.</S>
			<S sid ="215" ssid = "57">In path-enclosed trees, tokens before arg 1 and after arg 2 as well as their links with other nodes in the tree are removed.</S>
			<S sid ="216" ssid = "58">Based on this previous finding, our first heuristic was to change the syntactic parse tree representation of the relation instances into path-enclosed trees.</S>
			<S sid ="217" ssid = "59">H2: We hypothesize that words such as articles, adjectives and adverbs are not very useful for relation extraction.</S>
			<S sid ="218" ssid = "60">We thus removed sequence unigram features and bigram features that contain an article, adjective or adverb.</S>
			<S sid ="219" ssid = "61">H3: Similar to H2, we can remove bigrams in the syntactic parse tree subspace if the bigram contains an article, adjective or adverb.</S>
			<S sid ="220" ssid = "62">H4: Similar to H1, we can also remove the tokens before arg 1 and after arg 2 from the sequence representation of a relation instance.</S>
			<S sid ="221" ssid = "63">In Table 3, we show the performance after applying these heuristics.</S>
			<S sid ="222" ssid = "64">We started with the best configuration from our previous experiments, that is, combing up to bigram features in the sequence subspace and up to trigram features in the syntactic tree subspace.</S>
			<S sid ="223" ssid = "65">We then applied heuristics H1 to H4 in- crementally unless we saw that a heuristic was not effective.</S>
			<S sid ="224" ssid = "66">We found that H1, H2 and H4 slightly improved the performance, but H3 hurt the performance.</S>
			<S sid ="225" ssid = "67">On the one hand, the improvement suggests that our original feature configuration included some irrelevant features, and in turn confirmed that over- inclusion of features could hurt the performance.</S>
			<S sid ="226" ssid = "68">On the other hand, since the improvement brought by H1, H2 and H4 was rather small, and H3 even hurt the performance, we could see that it is in general very hard to find good feature pruning heuristics.</S>
	</SECTION>
	<SECTION title="Conclusions and Future Work. " number = "6">
			<S sid ="227" ssid = "1">In this paper, we conducted a systematic study of the feature space for relation extraction.</S>
			<S sid ="228" ssid = "2">We pro Table 3: The effect of various heuristic feature pruning methods.</S>
			<S sid ="229" ssid = "3">posed and defined a unified graphic representation of features for relation extraction, which serves as a general framework for systematically exploring features defined on natural language sentences.</S>
			<S sid ="230" ssid = "4">With this framework, we explored three different representations of sentences—sequences, syntactic parse trees, and dependency trees—which lead to three feature subspaces.</S>
			<S sid ="231" ssid = "5">In each subspace, starting with the basic unit features, we systematically explored features of different levels of complexity.</S>
			<S sid ="232" ssid = "6">The studied feature space includes not only most of the effective features explored in previous work, but also some features that have not been considered before.</S>
			<S sid ="233" ssid = "7">Our experiment results showed that using a set of basic unit features from each feature subspace, we can achieve reasonably good performance.</S>
			<S sid ="234" ssid = "8">When the three subspaces are combined, the performance can improve only slightly, which suggests that the sequence, syntactic and dependency relations have much overlap for the task of relation extraction.</S>
			<S sid ="235" ssid = "9">We also found that adding more complex features may not improve the performance much, and may even hurt the performance.</S>
			<S sid ="236" ssid = "10">A combination of features of different levels of complexity and from different sentence representations, coupled with task-oriented feature pruning, gives the best performance.</S>
			<S sid ="237" ssid = "11">In our future work, we will study how to automatically conduct task-oriented feature search, feature pruning and feature weighting using statistical methods instead of heuristics.</S>
			<S sid ="238" ssid = "12">In this study, we only considered features from the local context, i.e. the sentence that contains the two arguments.</S>
			<S sid ="239" ssid = "13">Some existing studies use corpus-based statistics for relation extraction (Hasegawa et al., 2004).</S>
			<S sid ="240" ssid = "14">In the future, we will study the effectiveness of these global features.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="241" ssid = "15">This work was in part supported by the National Science Foundation under award numbers 0425852 and 0428472.</S>
			<S sid ="242" ssid = "16">We thank Alessandro Moschitti for providing the SVM tree kernel package.</S>
			<S sid ="243" ssid = "17">We also thank Min Zhang for providing the implementation details of the convolution tree kernel for relation extraction.</S>
	</SECTION>
</PAPER>
