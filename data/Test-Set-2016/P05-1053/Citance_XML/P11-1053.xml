<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We present a simple semi-supervised relation extraction system with large-scale word clustering.</S>
		<S sid ="2" ssid = "2">We focus on systematically exploring the effectiveness of different cluster-based features.</S>
		<S sid ="3" ssid = "3">We also propose several statistical methods for selecting clusters at an appropriate level of granularity.</S>
		<S sid ="4" ssid = "4">When training on different sizes of data, our semi-supervised approach consistently outperformed a state-of-the-art supervised baseline system.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="5" ssid = "5">Relation extraction is an important information extraction task in natural language processing (NLP), with many practical applications.</S>
			<S sid ="6" ssid = "6">The goal of relation extraction is to detect and characterize semantic relations between pairs of entities in text.</S>
			<S sid ="7" ssid = "7">For example, a relation extraction system needs to be able to extract an Employment relation between the entities US soldier and US in the phrase US soldier.</S>
			<S sid ="8" ssid = "8">Current supervised approaches for tackling this problem, in general, fall into two categories: feature based and kernel based.</S>
			<S sid ="9" ssid = "9">Given an entity pair and a sentence containing the pair, both approaches usually start with multiple level analyses of the sentence such as tokenization, partial or full syntactic parsing, and dependency parsing.</S>
			<S sid ="10" ssid = "10">Then the feature based method explicitly extracts a variety of lexical, syntactic and semantic features for statistical learning, either generative or discriminative (Miller et al., 2000; Kambhatla, 2004; Boschee et al., 2005; Grishman et al., 2005; Zhou et al., 2005; Jiang and Zhai, 2007).</S>
			<S sid ="11" ssid = "11">In contrast, the kernel based method does not explicitly extract features; it designs kernel functions over the structured sentence representations (sequence, dependency or parse tree) to capture the similarities between different relation instances (Zelenko et al., 2003; Bunescu and Mooney, 2005a; Bunescu and Mooney, 2005b; Zhao and Grishman, 2005; Zhang et al., 2006; Zhou et al., 2007; Qian et al., 2008).</S>
			<S sid ="12" ssid = "12">Both lines of work depend on effective features, either explicitly or implicitly.</S>
			<S sid ="13" ssid = "13">The performance of a supervised relation extraction system is usually degraded by the sparsity of lexical features.</S>
			<S sid ="14" ssid = "14">For example, unless the example US soldier has previously been seen in the training data, it would be difficult for both the feature based and the kernel based systems to detect whether there is an Employment relation or not.</S>
			<S sid ="15" ssid = "15">Because the syntactic feature of the phrase US soldier is simply a noun-noun compound which is quite general, the words in it are crucial for extracting the relation.</S>
			<S sid ="16" ssid = "16">This motivates our work to use word clusters as additional features for relation extraction.</S>
			<S sid ="17" ssid = "17">The assumption is that even if the word soldier may never have been seen in the annotated Employment relation instances, other words which share the same cluster membership with soldier such as president and ambassador may have been observed in the Employment instances.</S>
			<S sid ="18" ssid = "18">The absence of lexical features can be compensated by 521 Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics, pages 521–529, Portland, Oregon, June 1924, 2011.</S>
			<S sid ="19" ssid = "19">Qc 2011 Association for Computational Linguistics the cluster features.</S>
			<S sid ="20" ssid = "20">Moreover, word clusters may implicitly correspond to different relation classes.</S>
			<S sid ="21" ssid = "21">For example, the cluster of president may be related to the Employment relation as in US president while the cluster of businessman may be related to the Affiliation relation as in US businessman.</S>
			<S sid ="22" ssid = "22">The main contributions of this paper are: we explore the cluster-based features in a systematic way and propose several statistical methods for selecting effective clusters.</S>
			<S sid ="23" ssid = "23">We study the impact of the size of training data on cluster features and analyze the performance improvements through an extensive experimental study.</S>
			<S sid ="24" ssid = "24">The rest of this paper is organized as follows: Section 2 presents related work and Section 3 provides the background of the relation extraction task and the word clustering algorithm.</S>
			<S sid ="25" ssid = "25">Section 4 describes in detail a state-of-the-art supervised baseline system.</S>
			<S sid ="26" ssid = "26">Section 5 describes the cluster- based features and the cluster selection methods.</S>
			<S sid ="27" ssid = "27">Though Boschee et al.</S>
			<S sid ="28" ssid = "28">(2005) and Chan and Roth (2010) used word clusters in relation extraction, they shared the same limitation as the above approaches in choosing clusters.</S>
			<S sid ="29" ssid = "29">For example, Boschee et al.</S>
			<S sid ="30" ssid = "30">(2005) chose clusters of different granularities and Chan and Roth (2010) simply used a single threshold for cutting the word hierarchy.</S>
			<S sid ="31" ssid = "31">Moreover, Boschee et al.</S>
			<S sid ="32" ssid = "32">(2005) only augmented the predicate (typically a verb or a noun of the most importance in a relation in their definition) with word clusters while Chan and Roth (2010) performed this for any lexical feature consisting of a single word.</S>
			<S sid ="33" ssid = "33">In this paper, we systematically explore the effectiveness of adding word clusters to different lexical features.</S>
			<S sid ="34" ssid = "34">3 Background.</S>
			<S sid ="35" ssid = "35">3.1 Relation Extraction.</S>
			<S sid ="36" ssid = "36">One of the well defined relation extraction tasks is 1 We present experimental results in Section 6 and the Automatic Content Extraction (ACE) program conclude in Section 7.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "2">
			<S sid ="37" ssid = "1">The idea of using word clusters as features in discriminative learning was pioneered by Miller et al.</S>
			<S sid ="38" ssid = "2">(2004), who augmented name tagging training data with hierarchical word clusters generated by the Brown clustering algorithm (Brown et al., 1992) from a large unlabeled corpus.</S>
			<S sid ="39" ssid = "3">They used different thresholds to cut the word hierarchy to obtain clusters of various granularities for feature decoding.</S>
			<S sid ="40" ssid = "4">Ratinov and Roth (2009) and Turian et al.</S>
			<S sid ="41" ssid = "5">(2010) also explored this approach for name sponsored by the U.S. government.</S>
			<S sid ="42" ssid = "6">ACE 2004 defined 7 major entity types: PER (Person), ORG (Organization), FAC (Facility), GPE (GeoPolitical Entity: countries, cities, etc.), LOC (Location), WEA (Weapon) and VEH (Vehicle).</S>
			<S sid ="43" ssid = "7">An entity has three types of mention: NAM (proper name), NOM (nominal) or PRO (pronoun).</S>
			<S sid ="44" ssid = "8">A relation was defined over a pair of entity mentions within a single sentence.</S>
			<S sid ="45" ssid = "9">The 7 major relation types with examples are shown in Table 1.</S>
			<S sid ="46" ssid = "10">ACE 2004 also defined 23 relation subtypes.</S>
			<S sid ="47" ssid = "11">Following most of the previous work, this paper only focuses on relation extraction of major types.</S>
			<S sid ="48" ssid = "12">Given a relation instance x  (s, mi , m j ) , where tagging.</S>
			<S sid ="49" ssid = "13">Though all of them used the same mi and m j are a pair of mentions and s is the hierarchical word clustering algorithm for the task of name tagging and reported improvements, we noticed that the clusters used by Miller et al.</S>
			<S sid ="50" ssid = "14">(2004) were quite different from that of Ratinov and Roth (2009) and Turian et al.</S>
			<S sid ="51" ssid = "15">(2010).</S>
			<S sid ="52" ssid = "16">To our knowledge, there has not been work on selecting clusters in a principled way.</S>
			<S sid ="53" ssid = "17">We move a step further to explore several methods in choosing effective clusters.</S>
			<S sid ="54" ssid = "18">A second difference between this work and the above ones is that we utilize word clusters in the task of relation extraction which is very different from sequence labeling tasks such as name tagging and chunking.</S>
			<S sid ="55" ssid = "19">sentence containing the pair, the goal is to learn a function which maps the instance x to a type c, where c is one of the 7 defined relation types or the type Nil (no relation exists).</S>
			<S sid ="56" ssid = "20">There are two commonly used learning paradigms for relation extraction: Flat: This strategy performs relation detection and classification at the same time.</S>
			<S sid ="57" ssid = "21">One multi-class classifier is trained to discriminate among the 7 relation types plus the Nil type.</S>
			<S sid ="58" ssid = "22">Hierarchical: This one separates relation detection from relation classification.</S>
			<S sid ="59" ssid = "23">One binary 1 Task definition: http://www.itl.nist.gov/iad/894.01/tests/ace/.</S>
			<S sid ="60" ssid = "24">ACE guidelines: http://projects.ldc.upenn.edu/ace/ classifier is trained first to distinguish between relation instances and non-relation instances.</S>
			<S sid ="61" ssid = "25">This can be done by grouping all the instances of the 7 relation types into a positive class and the instances of Nil into a negative class.</S>
			<S sid ="62" ssid = "26">Then the thresholded output of this binary classifier is used as training data for learning a multi-class classifier for the 7 relation types (Bunescu and Mooney, 2005b).</S>
			<S sid ="63" ssid = "27">Table 1: ACE relation types and examples from the annotation guideline 2 . The heads of the two entity mentions are marked.</S>
			<S sid ="64" ssid = "28">Types are listed in decreasing order of frequency of occurrence in the ACE corpus.</S>
			<SUBSECTION>3.2 Brown Word Clustering.</SUBSECTION>
			<S sid ="65" ssid = "29">The Brown algorithm is a hierarchical clustering algorithm which initially assigns each word to its own cluster and then repeatedly merges the two clusters which cause the least loss in average mutual information between adjacent clusters based on bigram statistics.</S>
			<S sid ="66" ssid = "30">By tracing the pairwise merging steps, one can obtain a word hierarchy which can be represented as a binary tree.</S>
			<S sid ="67" ssid = "31">A word can be compactly represented as a bit string by following the path from the root to itself in the tree, assigning a 0 for each left branch, and a 1 for each right branch.</S>
			<S sid ="68" ssid = "32">A cluster is just a branch of that tree.</S>
			<S sid ="69" ssid = "33">A high branch may correspond to more general concepts while the lower branches it includes might correspond to more specific ones.</S>
			<S sid ="70" ssid = "34">Brown et al.</S>
			<S sid ="71" ssid = "35">(1992) described an efficient implementation based on a greedy algorithm which initially assigned only the most frequent words into distinct clusters.</S>
			<S sid ="72" ssid = "36">It is worth pointing out that in this implementation each word occupies a leaf in the hierarchy, but each leaf might contain more than one word as can be seen from Table 2.</S>
			<S sid ="73" ssid = "37">The lengths of the bit strings also vary among different words.2 http://projects.ldc.upenn.edu/ace/docs/EnglishRDCV43 2.PDF Table 2: An example of words and their bit string representations obtained in this paper.</S>
			<S sid ="74" ssid = "38">Words in bold are head words that appeared in Table 1.</S>
			<S sid ="75" ssid = "39">4 Feature Based Relation Extraction.</S>
			<S sid ="76" ssid = "40">Given a pair of entity mentions  mi , m j  and the sentence containing the pair, a feature based system extracts a feature vector v which contains diverse lexical, syntactic and semantic features.</S>
			<S sid ="77" ssid = "41">The goal is to learn a function which can estimate the conditional probability p(c | v) , the probability of a relation type c given the feature vector v . The type with the highest probability will be output as the class label for the mention pair.</S>
			<S sid ="78" ssid = "42">We now describe a supervised baseline system with a very large set of features and its learning strategy.</S>
			<S sid ="79" ssid = "43">4.1 Baseline Feature Set.</S>
			<S sid ="80" ssid = "44">We first adopted the full feature set from Zhou et al.</S>
			<S sid ="81" ssid = "45">(2005), a state-of-the-art feature based relation extraction system.</S>
			<S sid ="82" ssid = "46">For space reasons, we only show the lexical features as in Table 3 and refer the reader to the paper for the rest of the features.</S>
			<S sid ="83" ssid = "47">At the lexical level, a relation instance can be seen as a sequence of tokens which form a five tuple &lt;Before, M1, Between, M2, After&gt;.</S>
			<S sid ="84" ssid = "48">Tokens of the five members and the interaction between the heads of the two mentions can be extracted as features as shown in Table 3.</S>
			<S sid ="85" ssid = "49">In addition, we cherry-picked the following features which were not included in Zhou et al.</S>
			<S sid ="86" ssid = "50">(2005) but were shown to be quite effective for relation extraction.</S>
			<S sid ="87" ssid = "51">Bigram of the words between the two mentions: This was extracted by both Zhao and Grishman (2005) and Jiang and Zhai (2007), aiming to provide more order information of the tokens between the two mentions.</S>
			<S sid ="88" ssid = "52">Patterns: There are three types of patterns: 1) the sequence of the tokens between the two mentions as used in Boschee et al.</S>
			<S sid ="89" ssid = "53">(2005); 2) the sequence of the heads of the constituents between the two mentions as used by Grishman et al.</S>
			<S sid ="90" ssid = "54">(2005); 3) the shortest dependency path between the two mentions in a dependency tree as adopted by Bunescu and Mooney (2005a).</S>
			<S sid ="91" ssid = "55">These patterns can provide more structured information of how the two mentions are connected.</S>
			<S sid ="92" ssid = "56">Title list: This is tailored for the EMPORG type of relations as the head of one of the mentions is usually a title.</S>
			<S sid ="93" ssid = "57">The features are decoded in a way similar to that of Sun (2009).</S>
			<S sid ="94" ssid = "58">given a test instance x , we first apply the binary classifier to it for relation detection; if it is detected as a relation instance we then apply the multi-class relation classifier to classify it4.</S>
			<S sid ="95" ssid = "59">5 Cluster Feature Selection.</S>
			<S sid ="96" ssid = "60">The selection of cluster features aims to answer the following two questions: which lexical features should be augmented with word clusters to improve generalization accuracy?</S>
			<S sid ="97" ssid = "61">How to select clusters at an appropriate level of granularity?</S>
			<S sid ="98" ssid = "62">We will describe our solutions in Section 5.1 and 5.2.</S>
			<S sid ="99" ssid = "63">5.1 Cluster Feature Decoding.</S>
			<S sid ="100" ssid = "64">While each one of the lexical features in Table 3 used by the baseline can potentially be augmented with word clusters, we believe the effectiveness of a lexical feature with augmentation of word clusters should be tested either individually or incrementally according to a rank of its importance as shown in Table 4.</S>
			<S sid ="101" ssid = "65">We will show the effectiveness of each cluster feature in the experiment section.</S>
			<S sid ="102" ssid = "66">Impor tan ce Le xic al Fea tur e D e s c r i p t i o n o f l e x i c a l f e a t u r e Cl us ter Fe at ur e 1 H M H M 1 , H M 2 a n d H M 1 2 H M 1 _ W C , H M 2 _ W C , H M 1 2 _ W C 2 Bag WM W M 1 a n d W M 2 B a g W M _ W C 3 H C a he ad 5 of a ch un k i n c o n t e x t H C _ W C 4 Bag WC w o r d o f c o n te xt B a g W C _ W C Table 4: Cluster features ordered by importance.</S>
			<S sid ="103" ssid = "67">Table 3: Lexical features for relation extraction.</S>
			<S sid ="104" ssid = "68">4.2 Baseline Learning Strategy.</S>
			<S sid ="105" ssid = "69">We employ a simple learning framework that is similar to the hierarchical learning strategy as described in Section 3.1.</S>
			<S sid ="106" ssid = "70">Specifically, we first train a binary classifier to distinguish between relation instances and non-relation instances.</S>
			<S sid ="107" ssid = "71">Then rather than using the thresholded output of this binary classifier as training data, we use only the annotated relation instances to train a multi-class classifier for the 7 relation types.</S>
			<S sid ="108" ssid = "72">In the test phase, of the mention as in Zhou et al.</S>
			<S sid ="109" ssid = "73">(2005).</S>
			<S sid ="110" ssid = "74">The importance is based on linguistic intuitions and observations of the contributions of different lexical features from various feature based systems.</S>
			<S sid ="111" ssid = "75">Table 4 simplifies a relation instance as a three tuple &lt;Context, M1, M2&gt; where the Context includes the Before, Between and After from the 4 Both the binary and multi-class classifiers output normalized.</S>
			<S sid ="112" ssid = "76">probabilities in the range [0,1].</S>
			<S sid ="113" ssid = "77">When the binary classifier’s prediction probability is greater than 0.5, we take the prediction with the highest probability of the multi-class classifier as the final class label.</S>
			<S sid ="114" ssid = "78">When it is in the range [0.3,0.5], we only consider as the final class label the prediction of the multi-class classifier with a probability which is greater than 0.9.</S>
			<S sid ="115" ssid = "79">All other cases are taken as non-relation instances.</S>
			<S sid ="116" ssid = "80">5 The head of a chunk is defined as the last word in the chunk..</S>
			<S sid ="117" ssid = "81">five tuple representation.</S>
			<S sid ="118" ssid = "82">As a relation in ACE is usually short, the words of the two entity mentions can provide more critical indications for relation classification than the words from the context.</S>
			<S sid ="119" ssid = "83">Within the two entity mentions, the head word of each mention is usually more important than other words of the mention; the conjunction of the two heads can provide an additional clue.</S>
			<S sid ="120" ssid = "84">And in general words other than the chunk head in the context do not contribute to establishing a relationship between the two entity mentions.</S>
			<S sid ="121" ssid = "85">The cluster based semi-supervised system works by adding an additional layer of lexical features that incorporate word clusters as shown in column 4 of Table 4.</S>
			<S sid ="122" ssid = "86">Take the US soldier as an example, if we decide to use a length of 10 as a threshold to cut the Brown word hierarchy to generate word clusters, we will extract a cluster feature HM1_WC10=1101111101 in addition to the lexical feature HM1=soldier given that the full bit string of soldier is 1101111101100 in Table 2.</S>
			<S sid ="123" ssid = "87">(Note that the cluster feature is a nominal feature, not to be confused with an integer feature.)</S>
			<S sid ="124" ssid = "88">usually 20 when inducing 1,000 clusters using the Brown algorithm.</S>
			<S sid ="125" ssid = "89">One way to achieve better efficiency is to consider only a subset of l instead of the full set.</S>
			<S sid ="126" ssid = "90">In addition, we limit ourselves to use sizes 3 and 4 for m for matching prior work.</S>
			<S sid ="127" ssid = "91">This keeps the cluster features to a manageable size considering that every word in your vocabulary could contribute to a lexical feature.</S>
			<S sid ="128" ssid = "92">For picking a subset of l , we propose below two statistical measures for computing the importance of a certain prefix length.</S>
			<S sid ="129" ssid = "93">Information Gain (IG): IG measures the quality or importance of a feature f by computing the difference between the prior entropy of classes C and the posterior entropy, given values V of the feature f (Hunt et al., 1966; Quinlan, 1986).</S>
			<S sid ="130" ssid = "94">For our purpose, C is the set of relation types, f is a cluster-based feature with a certain prefix length such as HM1_WC* where * means the prefix length and a value v is the prefix of the bit string representation of HM1.</S>
			<S sid ="131" ssid = "95">More formally, the IG of f is computed as follows: IG( f )   p(c) log p(c)  5.2 Selection of Clusters.</S>
			<S sid ="132" ssid = "96">Given the bit string representations of all the words in a vocabulary, researchers usually use prefixes of cC  ( p(v)   p(c | v) log p(c | v)) vV cC (1) different lengths of the bit strings to produce word clusters of various granularities.</S>
			<S sid ="133" ssid = "97">However, how to choose the set of prefix lengths in a principled way?</S>
			<S sid ="134" ssid = "98">This has not been answered by prior work.</S>
			<S sid ="135" ssid = "99">Our main idea is to learn the best set of prefix lengths, perhaps through the validation of their effectiveness on a development set of data.</S>
			<S sid ="136" ssid = "100">To our knowledge, previous research simply uses ad-hoc prefix lengths and lacks this training procedure.</S>
			<S sid ="137" ssid = "101">The training procedure can be extremely slow for reasons to be explained below.</S>
			<S sid ="138" ssid = "102">Formally, let l be the set of available prefix lengths ranging from 1 bit to the length of the longest bit string in the Brown word hierarchy and let m be the set of prefix lengths we want to use in decoding cluster features, then the problem of selecting effective clusters transforms to finding a | m | -combination of the set l which maximizes system performance.</S>
			<S sid ="139" ssid = "103">The training procedure can be extremely time consuming if we enumerate every possible | m | -combination of l , given that | m | can range from 1 to the size of l and the size of l equals the length of the longest bit string which is where the first and second terms refer to the prior and posterior entropies respectively.</S>
			<S sid ="140" ssid = "104">For each prefix length in the set l , we can compute its IG for a type of cluster feature and then rank the prefix lengths based on their IGs for that cluster feature.</S>
			<S sid ="141" ssid = "105">For simplicity, we rank the prefix lengths for a group of cluster features (a group is a row from column 4 in Table 4) by collapsing the individual cluster features into a single cluster feature.</S>
			<S sid ="142" ssid = "106">For example, we collapse the 3 types: HM1_WC, HM2_WC and HM12_WC into a single type HM_WC for computing the IG.</S>
			<S sid ="143" ssid = "107">Prefix Coverage (PC): If we use a short prefix then the clusters produced correspond to the high branches in the word hierarchy and would be very general.</S>
			<S sid ="144" ssid = "108">The cluster features may not provide more informative information than the words themselves.</S>
			<S sid ="145" ssid = "109">Similarly, if we use a long prefix such as the length of the longest bit string, then maybe only a few of the lexical features can be covered by clusters.</S>
			<S sid ="146" ssid = "110">To capture this intuition, we define the PC of a prefix length i as below: PC(i)  count( f ) i (2) previous research, we used in experiments the nwire (newswire) and bnews (broadcast news) where c o u n t ( f l ) f l stands for a lexical feature such as HM1 genres of the data contain ing 348 docum ents and 4374 relatio n instanc es.</S>
			<S sid ="147" ssid = "111">We extract ed an instanc e and f a cluster feature with prefix length i such as i for every pair of mentions in the same sentence HM1_WCi, count (*) is the number of which were separated by no more than two other occurrences of that feature in training data.</S>
			<S sid ="148" ssid = "112">Similar to IG, we compute PC for a group of cluster features, not for each individual feature.</S>
			<S sid ="149" ssid = "113">In our experiments, the top 10 ranked prefix lengths based on IG and prefix lengths with PC values in the range [0.4, 0.9] were used.</S>
			<S sid ="150" ssid = "114">In addition to the above two statistical measures, for comparison, we introduce another two simple but extreme measures for the selection of clusters.</S>
			<S sid ="151" ssid = "115">Use All Prefixes (UA): UA produces a cluster feature at every available bit length with the hope that the underlying supervised system can learn proper weights of different cluster features during training.</S>
			<S sid ="152" ssid = "116">For example, if the full bit representation of “Apple” is “000”, UA would produce three cluster features: prefix1=0, prefix2=00 and prefix3=000.</S>
			<S sid ="153" ssid = "117">Because this method does not need validation on the development set, it is the laziest but the fastest method for selecting clusters.</S>
			<S sid ="154" ssid = "118">Exhaustive Search (ES): ES works by trying every possible combination of the set l and picking the one that works the best for the development set.</S>
			<S sid ="155" ssid = "119">This is the most cautious and the slowest method for selecting clusters.</S>
			<S sid ="156" ssid = "120">6 Experiments.</S>
			<S sid ="157" ssid = "121">In this section, we first present details of our unsupervised word clusters, the relation extraction data set and its preprocessing.</S>
			<S sid ="158" ssid = "122">We then present a series of experiments coupled with result analyses.</S>
			<S sid ="159" ssid = "123">We used the English portion of the TDT5 corpora (LDC2006T18) as our unlabeled data for inducing word clusters.</S>
			<S sid ="160" ssid = "124">It contains roughly 83 million words in 3.4 million sentences with a mentions.</S>
			<S sid ="161" ssid = "125">The non-relation instances generated were about 8 times more than the relation instances.</S>
			<S sid ="162" ssid = "126">Preprocessing of the ACE documents: We used the Stanford parser6 for syntactic and dependency parsing.</S>
			<S sid ="163" ssid = "127">We used chunklink 7 to derive chunking information from the Stanford parsing.</S>
			<S sid ="164" ssid = "128">Because some bnews documents are in lower case, we recover the case for the head of a mention if its type is NAM by making the first character into its upper case.</S>
			<S sid ="165" ssid = "129">This is for better matching between the words in ACE and the words in the unsupervised word clusters.</S>
			<S sid ="166" ssid = "130">We used the OpenNLP 8 maximum entropy (maxent) package as our machine learning tool.</S>
			<S sid ="167" ssid = "131">We choose to work with maxent because the training is fast and it has a good support for multi- class classification.</S>
			<S sid ="168" ssid = "132">6.1 Baseline Performance.</S>
			<S sid ="169" ssid = "133">Following previous work, we did 5-fold cross- validation on the 348 documents with hand- annotated entity mentions.</S>
			<S sid ="170" ssid = "134">Our results are shown in Table 5 which also lists the results of another three state-of-the-art feature based systems.</S>
			<S sid ="171" ssid = "135">For this and the following experiments, all the results were computed at the relation mention level.</S>
			<S sid ="172" ssid = "136">Syst em P( %) R( %) F(% ) Zho u et al.</S>
			<S sid ="173" ssid = "137">(20 07)9 78.</S>
			<S sid ="174" ssid = "138">2 63.</S>
			<S sid ="175" ssid = "139">4 70.</S>
			<S sid ="176" ssid = "140">1 Zha o and Gris hma n (20 05)1 0 69.</S>
			<S sid ="177" ssid = "141">2 71.</S>
			<S sid ="178" ssid = "142">5 70.</S>
			<S sid ="179" ssid = "143">4 Our Bas elin e 73.</S>
			<S sid ="180" ssid = "144">4 67.</S>
			<S sid ="181" ssid = "145">7 70.</S>
			<S sid ="182" ssid = "146">4 Jian g and Zha i (20 07) 11 72.</S>
			<S sid ="183" ssid = "147">4 70.</S>
			<S sid ="184" ssid = "148">2 71.</S>
			<S sid ="185" ssid = "149">3 Table 5: Performance comparison on the ACE 2004 data over the 7 relation types.</S>
			<S sid ="186" ssid = "150">vocabulary size of 450K.</S>
			<S sid ="187" ssid = "151">We left case intact in the corpora.</S>
			<S sid ="188" ssid = "152">Following previous work, we used Liang’s implementation of the Brown clustering algorithm (Liang, 2005).</S>
			<S sid ="189" ssid = "153">We induced 1,000 word clusters for words that appeared at least twice in the corpora.</S>
			<S sid ="190" ssid = "154">The reduced vocabulary contains 255K unique words.</S>
			<S sid ="191" ssid = "155">The clusters are available at http://www.cs.nyu.edu/~asun/data/TDT5_BrownW C.tar.gz.</S>
			<S sid ="192" ssid = "156">For relation extraction, we used the benchmark ACE 2004 training data.</S>
			<S sid ="193" ssid = "157">Following most of the 6 http://nlp.stanford.edu/software/lex-parser.shtml 7 http://ilk.uvt.nl/team/sabine/chunklink/README.html 8 http://opennlp.sourceforge.net/ 9 Zhou et al.</S>
			<S sid ="194" ssid = "158">(2005) tested their system on the ACE 2003 data;.</S>
			<S sid ="195" ssid = "159">Zhou et al.</S>
			<S sid ="196" ssid = "160">(2007) tested their system on the ACE 2004 data.</S>
			<S sid ="197" ssid = "161">10 The paper gives a recall value of 70.5, which is not.</S>
			<S sid ="198" ssid = "162">consistent with the given values of P and F. An examination of the correspondence in preparing this paper indicates that the correct recall value is 71.5.</S>
			<S sid ="199" ssid = "163">11 The result is from using the All features in Jiang and Zhai.</S>
			<S sid ="200" ssid = "164">(2007).</S>
			<S sid ="201" ssid = "165">It is not quite clear from the paper that whether they used the 348 documents or the whole 2004 training data.</S>
			<S sid ="202" ssid = "166">Note that although all the 4 systems did 5-fold cross-validation on the ACE 2004 data, the detailed data partition might be different.</S>
			<S sid ="203" ssid = "167">Also, we were doing cross-validation at the document level which we believe was more natural than the instance level.</S>
			<S sid ="204" ssid = "168">Nonetheless, we believe our baseline system has achieved very competitive performance.</S>
			<S sid ="205" ssid = "169">6.2 The Effectiveness of Cluster Selection.</S>
			<S sid ="206" ssid = "170">Methods We investigated the tradeoff between performance and training time of each proposed method in selecting clusters.</S>
			<S sid ="207" ssid = "171">In this experiment, we randomly selected 70 documents from the 348 documents as test data which roughly equaled the size of 1 fold in the baseline in Section 6.1.</S>
			<S sid ="208" ssid = "172">For the baseline in this section, all the rest of the documents were used as training data.</S>
			<S sid ="209" ssid = "173">For the semi-supervised system, 70 percent of the rest of the documents were randomly selected as training data and 30 percent as development data.</S>
			<S sid ="210" ssid = "174">The set of prefix lengths that worked the best for the development set was chosen to select clusters.</S>
			<S sid ="211" ssid = "175">We only used the cluster For the rest of this paper, we will only use PC4 as our method in selecting clusters.</S>
			<S sid ="212" ssid = "176">6.3 The Effectiveness of Cluster Features.</S>
			<S sid ="213" ssid = "177">The baseline here is the same one used in Section 6.1.</S>
			<S sid ="214" ssid = "178">For the semi-supervised system, each test fold.</S>
			<S sid ="215" ssid = "179">was the same one used in the baseline and the other 4 folds were further split into a training set and a development set in a ratio of 7:3 for selecting clusters.</S>
			<S sid ="216" ssid = "180">We first added the cluster features individually into the baseline and then added them incrementally according to the order specified in Table 4.</S>
			<S sid ="217" ssid = "181">System F △ 1 Bas elin e 70.</S>
			<S sid ="218" ssid = "182">4 2 1 + HM _W C 71.</S>
			<S sid ="219" ssid = "183">5 + 1.1 3 1 + Bag W M_ WC 71.</S>
			<S sid ="220" ssid = "184">0 + 0.6 4 1 + HC _W C 69.</S>
			<S sid ="221" ssid = "185">60.8 5 1 + Bag WC _W C 46.</S>
			<S sid ="222" ssid = "186">124.3 6 2 + Bag W M_ WC 71.</S>
			<S sid ="223" ssid = "187">0 + 0.6 7 6 + HC _W C 70.</S>
			<S sid ="224" ssid = "188">6 + 0.2 8 7+ Bag WC _W C 50.</S>
			<S sid ="225" ssid = "189">320.1 12 feature HM_WC in this experiment.</S>
			<S sid ="226" ssid = "190">Table 7: Performance of the baseline and using Syst em F △ Trai nin g Tim e (in min ute) Bas elin e 70.</S>
			<S sid ="227" ssid = "191">70 1 UA 71.</S>
			<S sid ="228" ssid = "192">19 +0.</S>
			<S sid ="229" ssid = "193">49 1.5 PC3 71.</S>
			<S sid ="230" ssid = "194">65 +0.</S>
			<S sid ="231" ssid = "195">95 30 PC4 71.</S>
			<S sid ="232" ssid = "196">72 +1.</S>
			<S sid ="233" ssid = "197">02 46 IG3 71.</S>
			<S sid ="234" ssid = "198">65 +0.</S>
			<S sid ="235" ssid = "199">95 45 IG4 71.</S>
			<S sid ="236" ssid = "200">68 +0.</S>
			<S sid ="237" ssid = "201">98 78 ES3 71.</S>
			<S sid ="238" ssid = "202">66 +0.</S>
			<S sid ="239" ssid = "203">96 465 ES4 71.</S>
			<S sid ="240" ssid = "204">60 +0.</S>
			<S sid ="241" ssid = "205">90 167 8 Table 6: The tradeoff between performance and training time of each method in selecting clusters.</S>
			<S sid ="242" ssid = "206">PC3 means using 3 prefixes with the PC method.</S>
			<S sid ="243" ssid = "207">△ in this paper means the difference between a system and the baseline.</S>
			<S sid ="244" ssid = "208">Table 6 shows that all the 4 proposed methods improved baseline performance, with UA as the fastest and ES as the slowest.</S>
			<S sid ="245" ssid = "209">It was interesting that ES did not always outperform the two statistical methods which might be because of its overfitting to the development set.</S>
			<S sid ="246" ssid = "210">In general, both PC and IG had good balances between performance and training time.</S>
			<S sid ="247" ssid = "211">There was no dramatic difference in performance between using 3 and 4 prefix lengths.</S>
			<S sid ="248" ssid = "212">different cluster features with PC4 over the 7 types.</S>
			<S sid ="249" ssid = "213">We found that adding clusters to the heads of the two mentions was the most effective way of introducing cluster features.</S>
			<S sid ="250" ssid = "214">Adding clusters to the words of the mentions can also help, though not as good as the heads.</S>
			<S sid ="251" ssid = "215">We were surprised that the heads of chunks in context did not help.</S>
			<S sid ="252" ssid = "216">This might be because ACE relations are usually short and the limited number of long relations is not sufficient in generalizing cluster features.</S>
			<S sid ="253" ssid = "217">Adding clusters to every word in context hurt the performance a lot.</S>
			<S sid ="254" ssid = "218">Because of the behavior of each individual feature, it was not surprising that adding them incrementally did not give more performance gain.</S>
			<S sid ="255" ssid = "219">For the rest of this paper, we will only use HM_WC as cluster features.</S>
			<S sid ="256" ssid = "220">6.4 The Impact of Training Size.</S>
			<S sid ="257" ssid = "221">We studied the impact of training data size on cluster features as shown in Table 8.</S>
			<S sid ="258" ssid = "222">The test data was always the same as the 5-fold used in the baseline in Section 6.1.</S>
			<S sid ="259" ssid = "223">no matter the size of the training data.</S>
			<S sid ="260" ssid = "224">The training docu ments for the 12 All the improvements of F in Table 7, 8 and 9 were.</S>
			<S sid ="261" ssid = "225">significant at confidence levels &gt;= 95%.</S>
			<S sid ="262" ssid = "226"># doc s F o f R e l a t i o n C l a s s i f i c a t i o n F o f R e l a t i o n D e t e c t i o n Bas elin e PC4 (△) Pref ix1 0( △) Bas elin e PC4 (△) Pref ix1 0( △) 50 62.</S>
			<S sid ="263" ssid = "227">9 63.</S>
			<S sid ="264" ssid = "228">8(+ 0.9) 63.</S>
			<S sid ="265" ssid = "229">7(+ 0.8) 71.</S>
			<S sid ="266" ssid = "230">4 71.</S>
			<S sid ="267" ssid = "231">9(+ 0.5) 71.</S>
			<S sid ="268" ssid = "232">6(+ 0.2) 75 62.</S>
			<S sid ="269" ssid = "233">8 64.</S>
			<S sid ="270" ssid = "234">6(+ 1.8) 63.</S>
			<S sid ="271" ssid = "235">9(+ 1.1) 71.</S>
			<S sid ="272" ssid = "236">5 72.</S>
			<S sid ="273" ssid = "237">3(+ 0.8) 72.</S>
			<S sid ="274" ssid = "238">5(+ 1.0) 125 66.</S>
			<S sid ="275" ssid = "239">1 68.</S>
			<S sid ="276" ssid = "240">1(+ 2.0) 67.</S>
			<S sid ="277" ssid = "241">5(+ 1.4) 74.</S>
			<S sid ="278" ssid = "242">5 74.</S>
			<S sid ="279" ssid = "243">8(+ 0.3) 74.3( 0.2) 175 67.</S>
			<S sid ="280" ssid = "244">8 69.</S>
			<S sid ="281" ssid = "245">7(+ 1.9) 69.</S>
			<S sid ="282" ssid = "246">5(+ 1.7) 75.</S>
			<S sid ="283" ssid = "247">2 75.</S>
			<S sid ="284" ssid = "248">5(+ 0.3) 75.</S>
			<S sid ="285" ssid = "249">2(0.</S>
			<S sid ="286" ssid = "250">0) 225 68.</S>
			<S sid ="287" ssid = "251">9 70.</S>
			<S sid ="288" ssid = "252">1(+ 1.2) 69.</S>
			<S sid ="289" ssid = "253">6(+ 0.7) 75.</S>
			<S sid ="290" ssid = "254">6 75.</S>
			<S sid ="291" ssid = "255">9(+ 0.3) 75.3( 0.3) ≈28 0 70.</S>
			<S sid ="292" ssid = "256">4 71.</S>
			<S sid ="293" ssid = "257">5(+ 1.1) 70.</S>
			<S sid ="294" ssid = "258">7(+ 0.3) 76.</S>
			<S sid ="295" ssid = "259">4 76.</S>
			<S sid ="296" ssid = "260">9(+ 0.5) 76.3( 0.1) Table 8: Performance over the 7 relation types with different sizes of training data.</S>
			<S sid ="297" ssid = "261">Prefix10 uses the single prefix length 10 to generate word clusters as used by Chan and Roth (2010).</S>
			<S sid ="298" ssid = "262">Typ e P R F Bas elin e PC4 (△) Bas elin e PC4 (△) Bas elin e PC4 (△) EMP OR G 75.</S>
			<S sid ="299" ssid = "263">4 77.</S>
			<S sid ="300" ssid = "264">2(+ 1.8) 79.</S>
			<S sid ="301" ssid = "265">8 81.</S>
			<S sid ="302" ssid = "266">5(+ 1.7) 77.</S>
			<S sid ="303" ssid = "267">6 79.</S>
			<S sid ="304" ssid = "268">3(+ 1.7) PH YS 73.</S>
			<S sid ="305" ssid = "269">2 71.2( 2.0) 61.</S>
			<S sid ="306" ssid = "270">6 60.2( 1.4) 66.</S>
			<S sid ="307" ssid = "271">9 65.3( 1.7) GPE AF F 67.</S>
			<S sid ="308" ssid = "272">1 69.</S>
			<S sid ="309" ssid = "273">0(+ 1.9) 60.</S>
			<S sid ="310" ssid = "274">0 63.</S>
			<S sid ="311" ssid = "275">2(+ 3.2) 63.</S>
			<S sid ="312" ssid = "276">3 65.</S>
			<S sid ="313" ssid = "277">9(+ 2.6) PER SO C 88.</S>
			<S sid ="314" ssid = "278">2 83.9( 4.3) 58.</S>
			<S sid ="315" ssid = "279">4 61.</S>
			<S sid ="316" ssid = "280">0(+ 2.6) 70.</S>
			<S sid ="317" ssid = "281">3 70.</S>
			<S sid ="318" ssid = "282">7(+ 0.4) DIS C 79.</S>
			<S sid ="319" ssid = "283">4 80.</S>
			<S sid ="320" ssid = "284">6(+ 1.2) 42.</S>
			<S sid ="321" ssid = "285">9 46.</S>
			<S sid ="322" ssid = "286">0(+ 3.2) 55.</S>
			<S sid ="323" ssid = "287">7 58.</S>
			<S sid ="324" ssid = "288">6(+ 2.9) AR T 87.</S>
			<S sid ="325" ssid = "289">9 96.</S>
			<S sid ="326" ssid = "290">9(+ 9.0) 63.</S>
			<S sid ="327" ssid = "291">0 67.</S>
			<S sid ="328" ssid = "292">4(+ 4.4) 73.</S>
			<S sid ="329" ssid = "293">4 79.</S>
			<S sid ="330" ssid = "294">3(+ 5.9) OT HER AF F 70.</S>
			<S sid ="331" ssid = "295">6 80.</S>
			<S sid ="332" ssid = "296">0(+ 9.4) 41.</S>
			<S sid ="333" ssid = "297">4 41.</S>
			<S sid ="334" ssid = "298">4(0.</S>
			<S sid ="335" ssid = "299">0) 52.</S>
			<S sid ="336" ssid = "300">2 54.</S>
			<S sid ="337" ssid = "301">6(+ 2.4) Table 9: Performance of each individual relation type based on 5-fold cross-validation.</S>
			<S sid ="338" ssid = "302">current size setup were randomly selected and added to the previous size setup (if applicable).</S>
			<S sid ="339" ssid = "303">For example, we randomly selected another 25 documents and added them to the previous 50 documents to get 75 documents.</S>
			<S sid ="340" ssid = "304">We made sure that every document participated in this experiment.</S>
			<S sid ="341" ssid = "305">The training documents for each size setup were split into a real training set and a development set in a ratio of 7:3 for selecting clusters.</S>
			<S sid ="342" ssid = "306">There are some clear trends in Table 8.</S>
			<S sid ="343" ssid = "307">Under each training size, PC4 consistently outperformed the baseline and the system Prefix10 for relation classification.</S>
			<S sid ="344" ssid = "308">For PC4, the gain for classification was more pronounced than detection.</S>
			<S sid ="345" ssid = "309">The mixed detection results of Prefix10 indicated that only using a single prefix may not be stable.</S>
			<S sid ="346" ssid = "310">We did not observe the same trend in the reduction of annotation need with cluster-based features as in Koo et al.</S>
			<S sid ="347" ssid = "311">(2008) for dependency parsing.</S>
			<S sid ="348" ssid = "312">PC4 with sizes 50, 125, 175 outperformed the baseline with sizes 75, 175, 225 respectively.</S>
			<S sid ="349" ssid = "313">But this was not the case when PC4 was tested with sizes 75 and 225.</S>
			<S sid ="350" ssid = "314">This might due to the complexity of the relation extraction task.</S>
			<S sid ="351" ssid = "315">6.5 Analysis.</S>
			<S sid ="352" ssid = "316">There were on average 69 cross-type errors in the baseline in Section 6.1 which were reduced to 56 by using PC4.</S>
			<S sid ="353" ssid = "317">Table 9 showed that most of the improvements involved EMPORG, GPEAFF, DISC, ART and OTHER-AFF.</S>
			<S sid ="354" ssid = "318">The performance gain for PER-SOC was not as pronounced as the other five types.</S>
			<S sid ="355" ssid = "319">The five types of relations are ambiguous as they share the same entity type GPE while the PER-SOC relation only holds between PER and PER.</S>
			<S sid ="356" ssid = "320">This reflects that word clusters can help to distinguish between ambiguous relation types.</S>
			<S sid ="357" ssid = "321">As mentioned earlier the gain of relation detection was not as pronounced as classification as shown in Table 8.</S>
			<S sid ="358" ssid = "322">The unbalanced distribution of relation instances and non-relation instances remains as an obstacle for pushing the performance of relation extraction to the next level.</S>
			<S sid ="359" ssid = "323">7 Conclusion and Future Work.</S>
			<S sid ="360" ssid = "324">We have described a semi-supervised relation extraction system with large-scale word clustering.</S>
			<S sid ="361" ssid = "325">We have systematically explored the effectiveness of different cluster-based features.</S>
			<S sid ="362" ssid = "326">We have also demonstrated that the two proposed statistical methods are both effective and efficient in selecting clusters at an appropriate level of granularity through an extensive experimental study.</S>
			<S sid ="363" ssid = "327">Based on the experimental results, we plan to investigate additional ways to improve the performance of relation detection.</S>
			<S sid ="364" ssid = "328">Moreover, extending word clustering to phrase clustering (Lin and Wu, 2009) and pattern clustering (Sun and Grishman, 2010) is worth future investigation for relation extraction.</S>
	</SECTION>
</PAPER>
