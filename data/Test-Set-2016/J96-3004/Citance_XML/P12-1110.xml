<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We propose the first joint model for word segmentation, POS tagging, and dependency parsing for Chinese.</S>
		<S sid ="2" ssid = "2">Based on an extension of the incremental joint model for POS tagging and dependency parsing (Hatori et al., 2011), we propose an efficient character-based decoding method that can combine features from state-of-the-art segmentation, POS tagging, and dependency parsing models.</S>
		<S sid ="3" ssid = "3">We also describe our method to align comparable states in the beam, and how we can combine features of different characteristics in our incremental framework.</S>
		<S sid ="4" ssid = "4">In experiments using the Chinese Treebank (CTB), we show that the accuracies of the three tasks can be improved significantly over the baseline models, particularly by 0.6% for POS tagging and 2.4% for dependency parsing.</S>
		<S sid ="5" ssid = "5">We also perform comparison experiments with the partially joint models.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="6" ssid = "6">In processing natural languages that do not include delimiters (e.g. spaces) between words, word segmentation is the crucial first step that is necessary to perform virtually all NLP tasks.</S>
			<S sid ="7" ssid = "7">Furthermore, the word-level information is often augmented with the POS tags, which, along with segmentation, form the basic foundation of statistical NLP.</S>
			<S sid ="8" ssid = "8">Because the tasks of word segmentation and POS tagging have strong interactions, many studies have been devoted to the task of joint word segmentation and POS tagging for languages such as Chinese (e.g. Kruengkrai et al.</S>
			<S sid ="9" ssid = "9">(2009)).</S>
			<S sid ="10" ssid = "10">This is because some of the segmentation ambiguities cannot be resolved without considering the surrounding grammatical constructions encoded in a sequence of POS tags.</S>
			<S sid ="11" ssid = "11">The joint approach to word segmentation and POS tagging has been reported to improve word segmentation and POS tagging accuracies by more than 1% in Chinese (Zhang and Clark, 2008).</S>
			<S sid ="12" ssid = "12">In addition, some researchers recently proposed a joint approach to Chinese POS tagging and dependency parsing (Li et al., 2011; Hatori et al., 2011); particularly, Ha- tori et al.</S>
			<S sid ="13" ssid = "13">(2011) proposed an incremental approach to this joint task, and showed that the joint approach improves the accuracies of these two tasks.</S>
			<S sid ="14" ssid = "14">In this context, it is natural to consider further a question regarding the joint framework: how strongly do the tasks of word segmentation and dependency parsing interact?</S>
			<S sid ="15" ssid = "15">In the following Chinese sentences: ❙✃ ➀ ❱ ✍ ➀ ❿✚ current peace-prize and peace operation related The current peace prize and peace operations are related.</S>
			<S sid ="16" ssid = "16">❙✃ ➀ ❱✍ ➀ ❿✚ ❙ current peace award peace operation related group The current peace is awarded to peace-operation-related groups.</S>
			<S sid ="17" ssid = "17">the only difference is the existence of the last word ❙; however, whether or not this word existschanges the whole syntactic structure and segmen tation of the sentence.</S>
			<S sid ="18" ssid = "18">This is an example in which word segmentation cannot be handled properly without considering long-range syntactic information.</S>
			<S sid ="19" ssid = "19">Syntactic information is also considered beneficial to improve the segmentation of out of- vocabulary (OOV) words.</S>
			<S sid ="20" ssid = "20">Unlike languages such as Japanese that use a distinct character set (i.e. katakana) for foreign words, the transliterated words in Chinese, many of which are OOV words, frequently include characters that are also used as common or function words.</S>
			<S sid ="21" ssid = "21">In the current systems, the existence of these characters causes numerous over- segmentation errors for OOV words.</S>
			<S sid ="22" ssid = "22">Based on these observations, we aim at building a joint model that simultaneously processes word segmentation, POS tagging, and dependency parsing, trying to capture global interaction among 1045 Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 1045–1053, Jeju, Republic of Korea, 814 July 2012.</S>
			<S sid ="23" ssid = "23">Qc 2012 Association for Computational Linguistics these three tasks.</S>
			<S sid ="24" ssid = "24">To handle the increased computational complexity, we adopt the incremental parsing framework with dynamic programming (Huang and Sagae, 2010), and propose an efficient method of character-based decoding over candidate structures.</S>
			<S sid ="25" ssid = "25">Two major challenges exist in formalizing the joint segmentation and dependency parsing task in the character-based incremental framework.</S>
			<S sid ="26" ssid = "26">First, we must address the problem of how to align comparable states effectively in the beam.</S>
			<S sid ="27" ssid = "27">Because the number of dependency arcs varies depending on how words are segmented, we devise a step alignment scheme using the number of character-based arcs, which enables effective joint decoding for the three tasks.</S>
			<S sid ="28" ssid = "28">Second, although the feature set is fundamentally a combination of those used in previous works (Zhang and Clark, 2010; Huang and Sagae, 2010), to integrate them in a single incremental framework is not straightforward.</S>
			<S sid ="29" ssid = "29">Because we must perform decisions of three kinds (segmentation, tagging, and parsing) in an incremental framework, we must adjust which features are to be activated when, and how they are combined with which action labels.</S>
			<S sid ="30" ssid = "30">We have also found that we must balance the learning rate between features for segmentation and tagging decisions, and those for dependency parsing.</S>
			<S sid ="31" ssid = "31">We perform experiments using the Chinese Tree- bank (CTB) corpora, demonstrating that the accuracies of the three tasks can be improved significantly over the pipeline combination of the state-of-the-art joint segmentation and POS tagging model, and the dependency parser.</S>
			<S sid ="32" ssid = "32">We also perform comparison experiments with partially joint models, and investigate the tradeoff between the running speed and the model performance.</S>
	</SECTION>
	<SECTION title="Related Works. " number = "2">
			<S sid ="33" ssid = "1">In Chinese, Luo (2003) proposed a joint constituency parser that performs segmentation, POS tagging, and parsing within a single character-based framework.</S>
			<S sid ="34" ssid = "2">They reported that the POS tags contribute to segmentation accuracies by more than 1%, but the syntactic information has no substantial effect on the segmentation accuracies.</S>
			<S sid ="35" ssid = "3">In contrast, we built a joint model based on a dependency-based framework, with a rich set of structural features.</S>
			<S sid ="36" ssid = "4">Using it, we show the first positive result in Chinese that the segmentation accuracies can be improved using the syntactic information.</S>
			<S sid ="37" ssid = "5">Another line of work exists on lattice-based parsing for Semitic languages (Cohen and Smith, 2007; Goldberg and Tsarfaty, 2008).</S>
			<S sid ="38" ssid = "6">These methods first convert an input sentence into a lattice encoding the morphological ambiguities, and then conduct joint morphological segmentation and PCFG parsing.</S>
			<S sid ="39" ssid = "7">However, the segmentation possibilities considered in those studies are limited to those output by an existing morphological analyzer.</S>
			<S sid ="40" ssid = "8">In addition, the lattice does not include word segmentation ambiguities crossing boundaries of space-delimited tokens.</S>
			<S sid ="41" ssid = "9">In contrast, because the Chinese language does not have spaces between words, we fundamentally need to consider the lattice structure of the whole sentence.</S>
			<S sid ="42" ssid = "10">Therefore, we place no restriction on the segmentation possibilities to consider, and we assess the full potential of the joint segmentation and dependency parsing model.</S>
			<S sid ="43" ssid = "11">Among the many recent works on joint segmentation and POS tagging for Chinese, the linear-time incremental models by Zhang and Clark (2008) and Zhang and Clark (2010) largely inspired our model.</S>
			<S sid ="44" ssid = "12">Zhang and Clark (2008) proposed an incremental joint segmentation and POS tagging model, with an effective feature set for Chinese.</S>
			<S sid ="45" ssid = "13">However, it requires to computationally expensive multiple beams to compare words of different lengths using beam search.</S>
			<S sid ="46" ssid = "14">More recently, Zhang and Clark (2010) proposed an efficient character-based decoder for their word-based model.</S>
			<S sid ="47" ssid = "15">In their new model, a single beam suffices for decoding; hence, they reported that their model is practically ten times as fast as their original model.</S>
			<S sid ="48" ssid = "16">To incorporate the word-level features into the character-based decoder, the features are decomposed into substring-level features, which are effective for incomplete words to have comparable scores to complete words in the beam.</S>
			<S sid ="49" ssid = "17">Because we found that even an incremental approach with beam search is intractable if we perform the word- based decoding, we take a character-based approach to produce our joint model.</S>
			<S sid ="50" ssid = "18">The incremental framework of our model is based on the joint POS tagging and dependency parsing model for Chinese (Hatori et al., 2011), which is an extension of the shift-reduce dependency parser with dynamic programming (Huang and Sagae, 2010).</S>
			<S sid ="51" ssid = "19">They specifically modified the shift action so that it assigns the POS tag when a word is shifted onto the stack.</S>
			<S sid ="52" ssid = "20">However, because they regarded word segmentation as given, their model did not consider the interaction between segmentation and POS tagging.</S>
	</SECTION>
	<SECTION title="Model. " number = "3">
			<S sid ="53" ssid = "1">3.1 Incremental Joint Segmentation, POS.</S>
			<S sid ="54" ssid = "2">Tagging, and Dependency Parsing Based on the joint POS tagging and dependency parsing model by Hatori et al.</S>
			<S sid ="55" ssid = "3">(2011), we build our joint model to solve word segmentation, POS tagging, and dependency parsing within a single framework.</S>
			<S sid ="56" ssid = "4">Particularly, we change the role of the shift action and additionally use the append action, inspired by the character-based actions used in the joint segmentation and POS tagging model by Zhang and Clark (2010).</S>
			<S sid ="57" ssid = "5">The list of actions used is the following: • A: append the first character in the queue to the word on top of the stack.</S>
			<S sid ="58" ssid = "6">• SH(t): shift the first character in the input queue as a new word onto the stack, with POS tag t. • RL/RR: reduce the top two trees on the stack, (s0, s1), into a subtree s0s1 / s s1, respectively.</S>
			<S sid ="59" ssid = "7">We can first think of using the number of shifted characters as the step index, as Zhang and Clark (2010) does.</S>
			<S sid ="60" ssid = "8">However, because RL/RR actions can be performed without incrementing the step index, the decoder tends to prefer states with more dependency arcs, resulting more likely in premature choice of ‘reduce’ actions or oversegmentation of words.</S>
			<S sid ="61" ssid = "9">Alternatively, we can consider using the number of actions that have been applied as the step index, as Hatori et al.</S>
			<S sid ="62" ssid = "10">(2011) does.</S>
			<S sid ="63" ssid = "11">However, this results in inconsistent numbers of actions to reach the terminal states: some states that segment words into larger chunks reach a terminal state earlier than other states with smaller chunks.</S>
			<S sid ="64" ssid = "12">For these reasons, we have found that both approaches yield poor models that are not at all competitive with the baseline (pipeline) models1.</S>
			<S sid ="65" ssid = "13">To address this issue, we propose an indexing scheme using the number of character-based arcs.</S>
			<S sid ="66" ssid = "14">We presume that in addition to the word-to-word dependency arcs, each word (of length M ) implicitly has M − 1 inter-character arcs, as in: A B C , 0 0 Although SH(t) is similar to the one used in Hatori A B C , and A BC (each rectangle de et al.</S>
			<S sid ="67" ssid = "15">(2011), now it shifts the first character in the queue as a new word, instead of shifting a word.</S>
			<S sid ="68" ssid = "16">Following Zhang and Clark (2010), the POS tag is assigned to the word when its first character is shifted, and the word–tag pairs observed in the training data and the closed-set tags (Xia, 2000) are used to prune unlikely derivations.</S>
			<S sid ="69" ssid = "17">Because 33 tags are defined in the CTB tag set (Xia, 2000), our model exploits a total of 36 actions.</S>
			<S sid ="70" ssid = "18">To train the model, we use the averaged perceptron with the early update (Collins and Roark, 2004).</S>
			<S sid ="71" ssid = "19">In our joint model, the early update is invoked by mistakes in any of word segmentation, POS tagging, or dependency parsing.</S>
			<S sid ="72" ssid = "20">3.2 Alignment of States.</S>
			<S sid ="73" ssid = "21">When dependency parsing is integrated into the task of joint word segmentation and POS tagging, it is not straightforward to define a scheme to align (synchronize) the states in the beam.</S>
			<S sid ="74" ssid = "22">In beam search, we use the step index that is associated with each state: the parser states in process are aligned according to the index, and the beam search pruning is applied to those states with the same index.</S>
			<S sid ="75" ssid = "23">Consequently, for the beam search to function effectively, all states with the same index must be comparable, and all terminal states should have the same step index.</S>
			<S sid ="76" ssid = "24">notes a word).</S>
			<S sid ="77" ssid = "25">Then we can define the step index as the sum of the number of shifted characters and the total number of (inter-word and intra-word) dependency arcs, which thereby meets all the following conditions: (1) All subtrees spanning M consecutive characters have the same index 2M − 1.</S>
			<S sid ="78" ssid = "26">(2) All terminal states have the same step index 2N (including the root arc), where N is the number of characters in the sentence.</S>
			<S sid ="79" ssid = "27">(3) Every action increases the index.</S>
			<S sid ="80" ssid = "28">Note that the number of shifted characters is also necessary to meet condition (3).</S>
			<S sid ="81" ssid = "29">Otherwise, it allows an unlimited number of SH(t) actions without incrementing the step index.</S>
			<S sid ="82" ssid = "30">Figure 1 portrays how the states are aligned using the proposed scheme, where a subtree is denoted as a rectangle with its partial index shown inside it.</S>
			<S sid ="83" ssid = "31">In our framework, because an action increases the step index by 1 (for SH(t) or RL/RR) or 2 (for A), we need to use two beams to store new states at each step.</S>
			<S sid ="84" ssid = "32">The computational complexity of the entire process is O(B(T + 3) · 2N ), where B is the beam 1 For example, in our preliminary experiment on CTB5, the step indexing according to the number of actions underperforms the baseline model by 0.2–0.3% in segmentation accuracy.</S>
			<S sid ="85" ssid = "33">step 1 step 2 1 1 1 step 3 1 1 1 3 step 5 denote the ‘reduce’ actions that determine the word boundary2, whereas RL1/RR1 denote those ‘reduce’ actions that are applied when the word boundary has already been fixed.</S>
			<S sid ="86" ssid = "34">In addition, to capture the shared step 6 step 7 step 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 nature of boundary determination actions (SH(t), 3 1 1 1 3 1 1 1 1 3 1 1 1 1 1 RL0/RR0), we use a generalized action label SH’ to 3 3 3 3 1 5 1 5 1 1 7 3 3 1 1 5 1 1 1 5 3 7 1 represent any of them when combined with W01– W21.</S>
			<S sid ="87" ssid = "35">We also propose to use the features U01–U03, which we found are effective to adjust the character Figure 1: Illustration of the alignment of steps.</S>
			<S sid ="88" ssid = "36">size, T is the number of POS tags (= 33), and N is the number of characters in the sentence.</S>
			<S sid ="89" ssid = "37">Theoretically, the computational time is greater than that with the character-based joint segmentation and tagging model by Zhang and Clark (2010) by a factor of T +3 2N T +1 · N ,..</S>
			<S sid ="90" ssid = "38">2.1, when the same beam size is used.</S>
			<S sid ="91" ssid = "39">3.3 Features.</S>
			<S sid ="92" ssid = "40">The feature set of our model is fundamentally a combination of the features used in the state-of-the-art joint segmentation and POS tagging model (Zhang and Clark, 2010) and dependency parser (Huang and Sagae, 2010), both of which are used as baseline models in our experiment.</S>
			<S sid ="93" ssid = "41">However, we must carefully adjust which features are to be activated and when, and how they are combined with which action labels, depending on the type of the features because we intend to perform three tasks in a single incremental framework.</S>
			<S sid ="94" ssid = "42">The list of the features used in our joint model is presented in Table 1, where S01–S05, W01– W21, and T01–05 are taken from Zhang and Clark (2010), and P01–P28 are taken from Huang and Sagae (2010).</S>
			<S sid ="95" ssid = "43">Note that not all features are always considered: each feature is only considered if the action to be performed is included in the list of actions in the “When to apply” column.</S>
			<S sid ="96" ssid = "44">Because S01– S05 are used to represent the likelihood score of substring sequences, they are only used for A and SH(t) without being combined with any action label.</S>
			<S sid ="97" ssid = "45">Because T01–T05 are used to determine the POS tag of the word being shifted, they are only applied for SH(t).</S>
			<S sid ="98" ssid = "46">Because W01–W21 are used to determine whether to segment at the current position or not, they are only used for those actions involved in boundary determination decisions (A, SH(t), RL0, and RR0).</S>
			<S sid ="99" ssid = "47">The action labels RL0/RR0 are used to level and substring-level scores.</S>
			<S sid ="100" ssid = "48">Regarding the parsing features P01–P28, because we found that P01–P17 are also useful for segmentation decisions, these features are applied to all actions including A, with an explicit distinction of action labels RL0/RR0 from RL1/RR1.</S>
			<S sid ="101" ssid = "49">On the other hand, P18–P28 are only used when one of the parser actions (SH(t), RL, or RR) is applied.</S>
			<S sid ="102" ssid = "50">Note that P07– P09 and P18–P21 (look-ahead features) require the look-ahead information of the next word form and POS tags, which cannot be incorporated straightforwardly in an incremental framework.</S>
			<S sid ="103" ssid = "51">Although we have found that these features can be incorporated using the delayed features proposed by Hatori et al.</S>
			<S sid ="104" ssid = "52">(2011), we did not use them in our current model because it results in the significant increase of computational time.</S>
			<S sid ="105" ssid = "53">3.3.1 Dictionary features Because segmentation using a dictionary alone can serve as a strong baseline in Chinese word segmentation (Sproat et al., 1996), the use of dictionaries is expected to make our joint model more robust and enables us to investigate the contribution of the syntactic dependency in a more realistic setting.</S>
			<S sid ="106" ssid = "54">Therefore, we optionally use four features D01–D04 associated with external dictionaries.</S>
			<S sid ="107" ssid = "55">These features distinguish each dictionary source, reflecting the fact that different dictionaries have different characteristics.</S>
			<S sid ="108" ssid = "56">These features will also be used in our reimplementation of the model by Zhang and Clark (2010).</S>
			<S sid ="109" ssid = "57">3.4 Adjusting the Learning Rate of Features.</S>
			<S sid ="110" ssid = "58">In formulating the three tasks in the incremental framework, we found that adjusting the update rate depending on the type of the features (segmentation/tagging vs. parsing) crucially impacts the final performance of the model.</S>
			<S sid ="111" ssid = "59">To investigate this point, we define the feature vector φ� and score Φ of the 2 A reduce action has an additional effect of fixing the boundary of the top word on the stack if the last action was A or SH(t).</S>
			<S sid ="112" ssid = "60">Id Feature template Label When to apply U01 q−1 .e ◦ q−1 .t φ A, SH(t) Training Development Test #snt #wrd #snt #wrd #oov #snt #wrd #oov U02,03 q−1 .e q−1 .e ◦ q−1 .t as-is any S01 q−1 .e ◦ c0 φ A S02 q−1 .t ◦ c0 φ A, SH(t) S03 q−1 .t ◦ q−1 .b ◦ c0 φ A S04 q−1 .t ◦ c0 ◦ C(q−1 .b) φ A S05 q−1 .t ◦ c0 ◦ c1 φ A D01 len(q−1 .w) ◦ i A,SH’ A, SH(t), RR/RL0 D02 len(q−1 .w) ◦ q−1 .t ◦ i A,SH’ A, SH(t), RR/RL0 D03 len(q−1 .w) ◦ i A,SH’ A, SH(t), RR/RL0 D04 len(q−1 .w) ◦ q−1 .t ◦ i A,SH’ A, SH(t), RR/RL0 (D01,02: if q−1 .w ∈ Di ; D03,04: if q−1 .w ∈/ Di ) W01,02 q−1 .w q−2 .w ◦ q−1 .w A,SH’ A, SH(t), RR/RL0 W03 q−1 .w (for single-char word) A,SH’ A, SH(t), RR/RL0 W04 q−1 .b ◦ len(q−1 .w) A,SH’ A, SH(t), RR/RL0 CTB5d 16k 438k 804 21k 1.2k 1.9k 50k 3.1k CTB5j 18k 494k 352 6.8k 553 348 8.0k 278 CTB5c 15k 423k - - - - - - CTB6 23k 641k 2.1k 60k 3.3k 2.8k 82k 4.6k CTB7 31k 718k 10k 237k 13k 10k 245k 13k Table 2: Statistics of datasets.</S>
			<S sid ="113" ssid = "61">action a being applied to the state ψ as W05 q−1 .e ◦ len(q−1 .w) A,SH’ A, SH(t), RR/RL0 � � W06,07 q−1 .e ◦ c0 q−1 .b ◦ q−1 .e A,SH’ A, SH(t), RR/RL0 W08,09 q−1 .w ◦ c0 q−2 .e ◦ q−1 .w A,SH’ A, SH(t), RR/RL0 Φ(ψ, a) = �λ · φ�(ψ, a) = �λ · φst(ψ, a) + σpφp(ψ, a) , W10,11 q−1 .b ◦ c0 q−2 .e ◦ q−1 .e A,SH’ A, SH(t), RR/RL0 W12 q−2 .w ◦ len(q−1 .w) A,SH’ A, SH(t), RR/RL0 W13 len(q−2 .w) ◦ q−1 .w A,SH’ A, SH(t), RR/RL0 W14 q−1 .w ◦ q−1 .t A,SH’ A, SH(t), RR/RL0 W15 q−2 .t ◦ q−1 .w A,SH’ A, SH(t), RR/RL0 W16 q−1 .t ◦ q−1 .w ◦ q−2 .e A,SH’ A, SH(t), RR/RL0 W17 q−1 .t ◦ q−1 .w ◦ c0 A,SH’ A, SH(t), RR/RL0 W18 q−2 .e ◦ q−1 .w ◦ c0 ◦ q1 .t A,SH’ A, SH(t), RR/RL0 W19 q−1 .t ◦ q−1 .e A,SH’ A, SH(t), RR/RL0 W20 q−1 .t ◦ q−1 .e ◦ c A,SH’ A, SH(t), RR/RL0where φ�st corresponds to the segmentation and tag ging features (those starting with ‘U’, ‘S’, ‘T’, or‘D’), and φ�p is the set of the parsing features (start ing with ‘P’).</S>
			<S sid ="114" ssid = "62">Then, if we set σp to a number smaller than 1, perceptron updates for the parsing features will be kept small at the early stage of training because the update is proportional to the values of the W21 q−1 .t ◦ c ◦ cat(q−1 .e) A,SH’ A, SH(t), RR/RL0 (W20, W21: c ∈ q−1 .w\e) feature vector.</S>
			<S sid ="115" ssid = "63">However, even if σp is initially small, T01,02 q−1 .t q−2 .t ◦ q−1 .t SH(t) SH(t) T03,04 q−1 .w c0 SH(t) SH(t) T05 c0 ◦ q−1 .t ◦ q−1 .e SH(t) SH(t) P01,02 s0 .w s0 .t A, SH(t), RR/RL0/1 any P03,04 s0 .w ◦ s0 .t s1 .w A, SH(t), RR/RL0/1 any P05,06 s1 .t s1 .w ◦ s1 .t A, SH(t), RR/RL0/1 any P07,08 q0 .w q0 .t A, SH(t), RR/RL0/1 any P09,10 q0 .w ◦ q0 .t s0 .w ◦ s1 .w A, SH(t), RR/RL0/1 any P11,12 s0 .t ◦ s1 .t s0 .t ◦ q0 .t A, SH(t), RR/RL0/1 any P13 s0 .w ◦ s0 .t ◦ s1 .t A, SH(t), RR/RL0/1 any P14 s0 .t ◦ s1 .w ◦ s1 .t A, SH(t), RR/RL0/1 any P15 s0 .w ◦ s1 .w ◦ s1 .t A, SH(t), RR/RL0/1 any P16 s0 .w ◦ s0 .t ◦ s1 .w A, SH(t), RR/RL0/1 any P17 s0 .w ◦ s0 .t ◦ s1 .w ◦ s1 .t A, SH(t), RR/RL0/1 any P18 s0 .t ◦ q0 .t ◦ q1 .t as-is SH(t), RR, RL P19 s1 .t ◦ s0 .t ◦ q0 .t as-is SH(t), RR, RL P20 s0 .w ◦ q0 .t ◦ q1 .t as-is SH(t), RR, RL P21 s1 .t ◦ s0 .w ◦ q0 .t as-is SH(t), RR, RL P22 s1 .t ◦ s1 .rc.t ◦ s0 .t as-is SH(t), RR, RL P23 s1 .t ◦ s1 .lc.t ◦ s0 .t as-is SH(t), RR, RL P24 s1 .t ◦ s1 .rc.t ◦ s0 .w as-is SH(t), RR, RL P25 s1 .t ◦ s1 .lc.t ◦ s0 .w as-is SH(t), RR, RL P26 s1 .t ◦ s0 .t ◦ s0 .rc.t as-is SH(t), RR, RL P27 s1 .t ◦ s0 .w ◦ s0 .lc.t as-is SH(t), RR, RL P28 s2 .t ◦ s1 .t ◦ s0 .t as-is SH(t), RR, RL * q−1 and q−2 respectively denote the last-shifted word and the word shifted before q−1 . q.w and q.t respectively denote the (root) word form and POS tag of a subtree (word) q, and q.b and q.e the beginning and ending characters of q.w. c0 and c1 are the first and second characters in the queue.</S>
			<S sid ="116" ssid = "64">q.w\e denotes the set of characters excluding the ending character of q.w. len(·)denotes the length of the word, capped at 16 if longer.</S>
			<S sid ="117" ssid = "65">cat(·) de notes the category of the character, which is the set of POS tags observed in the training data.</S>
			<S sid ="118" ssid = "66">Di is a dictionary, a set of words.</S>
			<S sid ="119" ssid = "67">The action label φ means that the feature is not combined with any label; “as-is” denotes the use of the default action set “A, SH(t), and RR/RL” as is. Table 1: Feature templates for the full joint model.</S>
			<S sid ="120" ssid = "68">the global weights for the parsing features will in crease as needed and compensate for the small σp as the training proceeds.</S>
			<S sid ="121" ssid = "69">In this way, we can control the contribution of syntactic dependencies at the early stage of training.</S>
			<S sid ="122" ssid = "70">Section 4.3 shows that the best setting we found is σp = 0.5: this result suggests that we probably should resolve remaining errors by preferentially using the local n-gram based features at the early stage of training.</S>
			<S sid ="123" ssid = "71">Otherwise, the premature incorporation of the non-local syntactic dependencies might engender overfitting to the training data.</S>
			<S sid ="124" ssid = "72">4 Experiment 4.1 Experimental.</S>
			<S sid ="125" ssid = "73">Settings We use the Chinese Penn Treebank ver.</S>
			<S sid ="126" ssid = "74">5.1, 6.0, and 7.0 (hereinafter CTB5, CTB6, and CTB7) for evaluation.</S>
			<S sid ="127" ssid = "75">These corpora are split into training, development, and test sets, according to previous works.</S>
			<S sid ="128" ssid = "76">For CTB5, we refer to the split by Duan et al.</S>
			<S sid ="129" ssid = "77">(2007) as CTB 5d, and to the split by Jiang et al.</S>
			<S sid ="130" ssid = "78">(2008) as CTB5j.</S>
			<S sid ="131" ssid = "79">We also prepare a dataset for cross validation: the dataset CTB5c consists of sentences from CTB5 excluding the development and test sets of CTB5d and CTB5j.</S>
			<S sid ="132" ssid = "80">We split CTB 5c into five sets (CTB5c-n), and alternatively use four of these as the training set and the rest as the test set.</S>
			<S sid ="133" ssid = "81">CTB6 is split according to the official split described in the documentation, and CTB7 is split according to Wang et al.</S>
			<S sid ="134" ssid = "82">(2011).</S>
			<S sid ="135" ssid = "83">The statistics of 96 these splits are shown in Table 2.</S>
			<S sid ="136" ssid = "84">As external dic94 tionaries, we use the HowNet Word List3, consist ing of 91,015 words, and page names from the Chi- 92 nese Wikipedia4 as of Oct 26, 2011, consisting of 709,352 words.</S>
			<S sid ="137" ssid = "85">These dictionaries only consist of 90 word forms with no frequency or POS information.</S>
			<S sid ="138" ssid = "86">88We use standard measures of word-level preci 76 74 72 70 68 66 Seg (σ_p=0.1) Seg (σ_p=0.2) Seg (σ_p=0.5) 64 Seg (σ_p=1.0) Tag (σ_p=0.1) Tag (σ_p=0.2) 62 Tag (σ_p=0.5) Dep (σ_p=0.1) Dep (σ_p=0.2) Dep (σ_p=0.5) sion, recall, and F1 score, for evaluating each task.</S>
			<S sid ="139" ssid = "87">The output of dependencies cannot be correct unless Tag (σ_p=1.0) 86 60 0 10 20 30 40 50 60 70 80 Dep (σ_p=1.0) 0 10 20 30 40 50 60 70 80 the syntactic head and dependent of the dependency relation are both segmented correctly.</S>
			<S sid ="140" ssid = "88">Following the standard setting in dependency parsing works, we evaluate the task of dependency parsing with the unlabeled attachment scores excluding punctuations.</S>
			<S sid ="141" ssid = "89">Statistical significance is tested by McNemar’s test († : p &lt; 0.05, ‡ : p &lt; 0.01).</S>
			<SUBSECTION>4.2 Baseline and Proposed Models.</SUBSECTION>
			<S sid ="142" ssid = "90">We use the following baseline and proposed models for evaluation.</S>
			<S sid ="143" ssid = "91">• SegTag: our reimplementation of the joint segmentation and POS tagging model by Zhang and Clark (2010).</S>
			<S sid ="144" ssid = "92">Table 5 shows that this reimplementation almost reproduces the accuracy of their implementation.</S>
			<S sid ="145" ssid = "93">We used the beam of 16, which they reported to achieve the best accuracies.</S>
			<S sid ="146" ssid = "94">• Dep’: the state-of-the-art dependency parser by Huang and Sagae (2010).</S>
			<S sid ="147" ssid = "95">We used our reimplementation, which is used in Hatori et al.</S>
			<S sid ="148" ssid = "96">(2011).</S>
			<S sid ="149" ssid = "97">• Dep: Dep’ without look-ahead features.</S>
			<S sid ="150" ssid = "98">• TagDep: the joint POS tagging and dependency parsing model (Hatori et al., 2011), where the look-ahead features are omitted.5 • SegTag+Dep/SegTag+Dep’: a pipeline combination of SegTag and Dep or Dep’.</S>
			<S sid ="151" ssid = "99">• SegTag+TagDep: a pipeline combination of Seg- Tag and TagDep, where only the segmentation output of SegTag is used as input to TagDep; the output tags of TagDep are used for evaluation.</S>
			<S sid ="152" ssid = "100">• SegTagDep: the proposed full joint model.</S>
			<S sid ="153" ssid = "101">All of the models described above except Dep’ are based on the same feature sets for segmentation and 3 http://www.keenage.com/html/e index.html 4 http://zh.wikipedia.org/wiki 5 We used the original implementation used in Hatori et al.</S>
			<S sid ="154" ssid = "102">(2011).</S>
			<S sid ="155" ssid = "103">In Hatori et al.</S>
			<S sid ="156" ssid = "104">(2011), we confirmed that omission of the look-ahead features results in a 0.26% decrease in the parsing accuracy on CTB5d (dev).Figure 2: F1 scores (in %) of SegTagDep on CTB 5c1 w.r.t. the training epoch (x-axis) and parsing feature weights (in legend).</S>
			<S sid ="157" ssid = "105">tagging (Zhang and Clark, 2008; Zhang and Clark, 2010) and dependency parsing (Huang and Sagae, 2010).</S>
			<S sid ="158" ssid = "106">Therefore, we can investigate the contribution of the joint approach through comparison with the pipeline and joint models.</S>
			<SUBSECTION>4.3 Development Results.</SUBSECTION>
			<S sid ="159" ssid = "107">We have some parameters to tune: parsing feature weight σp, beam size, and training epoch.</S>
			<S sid ="160" ssid = "108">All these parameters are set based on experiments on CTB5c.</S>
			<S sid ="161" ssid = "109">For experiments on CTB5j, CTB6, and CTB7, the training epoch is set using the development set.</S>
			<S sid ="162" ssid = "110">Figure 2 shows the F1 scores of the proposed model (SegTagDep) on CTB5c1 with respect to the training epoch and different parsing feature weights, where “Seg”, “Tag”, and “Dep” respectively denote the F1 scores of word segmentation, POS tagging, and dependency parsing.</S>
			<S sid ="163" ssid = "111">In this experiment, the external dictionaries are not used, and the beam size of 32 is used.</S>
			<S sid ="164" ssid = "112">Interestingly, if we simply set σp to 1, the accuracies seem to converge at lower levels.</S>
			<S sid ="165" ssid = "113">The σp = 0.2 setting seems to reach almost identical segmentation and tagging accuracies as the best setting σp = 0.5, but the convergence occurs more slowly.</S>
			<S sid ="166" ssid = "114">Based on this experiment, we set σp to 0.5 throughout the experiments in this paper.</S>
			<S sid ="167" ssid = "115">Table 3 shows the performance and speed of the full joint model (with no dictionaries) on CTB5c1 with respect to the beam size.</S>
			<S sid ="168" ssid = "116">Although even the beam size of 32 results in competitive accuracies for word segmentation and POS tagging, the dependency accuracy is affected most by the increase of the beam size.</S>
			<S sid ="169" ssid = "117">Based on this experiment, we set the beam size of SegTagDep to 64 throughout the exper 64 96.28 92.37 74.96 0.48 Table 3: F1 scores and speed (in sentences per sec.)</S>
			<S sid ="170" ssid = "118">of SegTagDep on CTB5c1 w.r.t. the beam size.</S>
			<S sid ="171" ssid = "119">iments in this paper, unless otherwise noted.</S>
			<S sid ="172" ssid = "120">97 4.4 Main Results 96.</S>
			<S sid ="173" ssid = "121">In this section, we present experimentally obtained 95results using the proposed and baseline models.</S>
			<S sid ="174" ssid = "122">Ta SegTag 97.66 93.61 SegTagDep 97.73 94.46 SegTag(d) 98.18 94.08 SegTagDep(d) 98.26 94.64 Table 5: Final results on CTB5j 76 75 74 ble 4 shows the segmentation, POS tagging, and dependency parsing F1 scores of these models on CTB5c.</S>
			<S sid ="175" ssid = "123">Irrespective of the existence of the dictionary features, the joint model SegTagDep largely increases the POS tagging and dependency parsing accuracies (by 0.56–0.63% and 2.34–2.44%); the improvements in parsing accuracies are still 94 SegTag (Seg).</S>
			<S sid ="176" ssid = "124">SegTagDep (Seg) SegTag (Tag) SegTag+TagDep (Tag) SegTagDep (Tag) 92 91 90 0.05 0.1 0.2 0.5 1 2 73 72 71 70 SegTag+Dep (Dep) SegTag+TagDep (Dep) SegTagDep (Dep).</S>
			<S sid ="177" ssid = "125">69 0.05 0.1 0.2 0.5 1 2 significant even compared with SegTag+Dep’ (the pipeline model with the look-ahead features).</S>
			<S sid ="178" ssid = "126">However, when the external dictionaries are not used (“wo/dict”), no substantial improvements for segmentation accuracies were observed.</S>
			<S sid ="179" ssid = "127">In contrast, when the dictionaries are used (“w/dict”), the segmentation accuracies are now improved over the baseline model SegTag consistently (on every trial).</S>
			<S sid ="180" ssid = "128">Although the overall improvement in segmentation is only around 0.1%, more than 1% improvement is observed if we specifically examine OOV6 words.</S>
			<S sid ="181" ssid = "129">The difference between “wo/dict” and “w/dict” results suggests that the syntactic dependencies might work as a noise when the segmentation model is insufficiently stable, but the model does improve when it is stable, not receiving negative effects from the syntactic dependencies.</S>
			<S sid ="182" ssid = "130">The partially joint model SegTag+TagDep is shown to perform reasonably well in dependency parsing: with dictionaries, it achieved the 2.02% improvement over SegTag+Dep, which is only 0.32% lower than SegTagDep.</S>
			<S sid ="183" ssid = "131">However, whereas Seg- Tag+TagDep showed no substantial improvement in tagging accuracies over SegTag (when the dictionaries are used), SegTagDep achieved consistent improvements of 0.46% and 0.58% (without/with dic 6 We define the OOV words as the words that have not seen in the training data, even when the external dictionaries are used.</S>
			<S sid ="184" ssid = "132">Figure 3: Performance of baseline and joint models w.r.t. the average processing time (in sec.)</S>
			<S sid ="185" ssid = "133">per sentence.</S>
			<S sid ="186" ssid = "134">Each point corresponds to the beam size of 4, 8, 16, 32, (64).</S>
			<S sid ="187" ssid = "135">The beam size of 16 is used for SegTag in SegTag+Dep and SegTag+TagDep.</S>
			<S sid ="188" ssid = "136">tionaries); these differences can be attributed to the combination of the relieved error propagation and the incorporation of the syntactic dependencies.</S>
			<S sid ="189" ssid = "137">In addition, SegTag+TagDep has OOV tagging accuracies consistently lower than SegTag, suggesting that the syntactic dependency has a negative effect on the POS tagging accuracy of OOV words7.</S>
			<S sid ="190" ssid = "138">In contrast, this negative effect is not observed for SegTagDep: both the overall tagging accuracy and the OOV accuracy are improved, demonstrating the effectiveness of the proposed model.</S>
			<S sid ="191" ssid = "139">Figure 3 shows the performance and processing time comparison of various models and their combinations.</S>
			<S sid ="192" ssid = "140">Although SegTagDep takes a few times longer to achieve accuracies comparable to those of SegTag+Dep/TagDep, it seems to present potential 7 This is consistent with Hatori et al.</S>
			<S sid ="193" ssid = "141">(2011)’s observation that although the joint POS tagging and dependency parsing improves the accuracy of syntactically influential POS tags, it has a slight side effect of increasing the confusion between general and proper nouns (NN vs. NR).</S>
			<S sid ="194" ssid = "142">Model Segmentation POS Tagging Dependency wo /di ct S e g T a g + D e p S e g T a g + D e p’ S e g T a g + T a g D e p S e g T a g D e p 9 6 . 2 2 7 2 . 2 4 9 1 . 7 4 5 9 . 8 2 7 2 . 5 8 72.</S>
			<S sid ="195" ssid = "143">94 (+0 .36 ‡ ) 74.</S>
			<S sid ="196" ssid = "144">60 (+2 .02 ‡ ) 74.</S>
			<S sid ="197" ssid = "145">92 (+2 .34 ‡ ) 91.</S>
			<S sid ="198" ssid = "146">86 (+0 .12 ‡ ) 58.</S>
			<S sid ="199" ssid = "147">89 ( 0.9 3‡ ) 92.</S>
			<S sid ="200" ssid = "148">30 (+0 .56 ‡ ) 61.</S>
			<S sid ="201" ssid = "149">03 (+1 .21 ‡ ) 96.</S>
			<S sid ="202" ssid = "150">19 ( 0.0 3) 72.24 (+0.00) w/ dic t S e g T a g + D e p S e g T a g + D e p’ S e g T a g + T a g D e p S e g T a g D e p 9 6 . 8 2 7 8 . 3 2 9 2 . 3 4 6 5 . 4 4 7 3 . 5 3 73.</S>
			<S sid ="203" ssid = "151">90 (+0 .37 ‡ ) 75.</S>
			<S sid ="204" ssid = "152">45 (+1 .92 ‡ ) 75.</S>
			<S sid ="205" ssid = "153">97 (+2 .44 ‡ ) 92.</S>
			<S sid ="206" ssid = "154">35 (+0 .01 ) 63.</S>
			<S sid ="207" ssid = "155">20 ( 2.2 4‡ ) 92.</S>
			<S sid ="208" ssid = "156">97 (+0 .63 ‡ ) 67.</S>
			<S sid ="209" ssid = "157">40 (+1 .96 ‡ ) 96.</S>
			<S sid ="210" ssid = "158">90 (+0 .08 ‡ ) 79.</S>
			<S sid ="211" ssid = "159">38 (+1 .06 ‡ ) Table 4: Segmentation, POS tagging, and (unlabeled attachment) dependency F1 scores averaged over five trials on CTB5c.</S>
			<S sid ="212" ssid = "160">Figures in parentheses show the differences over SegTag+Dep (‡ : p &lt; 0.01).</S>
			<S sid ="213" ssid = "161">for greater improvement, especially for tagging and Model CTB6 Test Se CTB7 Test Se parsing accuracies, when a larger beam can be used.</S>
			<SUBSECTION>4.5 Comparison with Other Systems.</SUBSECTION>
			<S sid ="214" ssid = "162">Table 5 and Table 6 show a comparison of the segmentation and POS tagging accuracies with other state-of-the-art models.</S>
			<S sid ="215" ssid = "163">“Kruengkrai+ ’09” is a lattice-based model by Kruengkrai et al.</S>
			<S sid ="216" ssid = "164">(2009).</S>
			<S sid ="217" ssid = "165">“Zhang ’10” is the incremental model by Zhang and Clark (2010).</S>
			<S sid ="218" ssid = "166">These two systems use no external resources other than the CTB corpora.</S>
			<S sid ="219" ssid = "167">“Sun+ ’11” is a CRF-based model (Sun, 2011) that uses a combination of several models, with a dictionary of idioms.</S>
			<S sid ="220" ssid = "168">“Wang+ ’11” is a semi-supervised model by Wang et al.</S>
			<S sid ="221" ssid = "169">(2011), which additionally uses the Chinese Gigaword Corpus.</S>
			<S sid ="222" ssid = "170">Our models with dictionaries (those marked with ‘(d)’) have competitive accuracies to other state-of- the-art systems, and SegTagDep(d) achieved the best reported segmentation and POS tagging accuracies, using no additional corpora other than the dictionaries.</S>
			<S sid ="223" ssid = "171">Particularly, the POS tagging accuracy is more than 0.4% higher than the previous best system thanks to the contribution of syntactic dependencies.</S>
			<S sid ="224" ssid = "172">These results also suggest that the use of readily available dictionaries can be more effective than semi-supervised approaches.</S>
			<S sid ="225" ssid = "173">5 Conclusion.</S>
			<S sid ="226" ssid = "174">In this paper, we proposed the first joint model for word segmentation, POS tagging, and dependency parsing in Chinese.</S>
			<S sid ="227" ssid = "175">The model demonstrated substantial improvements on the three tasks over the pipeline combination of the state-of-the-art joint segmentation and POS tagging model, and dependency parser.</S>
			<S sid ="228" ssid = "176">Particularly, results showed that the g Tag Dep g Tag Dep Kruengkrai ’09 95.50 90.5095.40 89.86 Wang ’11 95.79 91.1295.65 90.46SegTag+Dep 95.46 90.64 72.57 95.49 90.11 71.25 SegTagDep 95.45 91.27 74.88 95.42 90.62 73.58 (diff.)</S>
			<S sid ="229" ssid = "177">-0.01 +0.63 ‡ +2.31‡ -0.07 +0.51 ‡ +2.33 ‡ SegTag+Dep(d) 96.13 91.38 73.62 95.98 90.68 72.06 SegTagDep(d) 96.18 91.95 75.76 96.07 91.28 74.58 (diff.)</S>
			<S sid ="230" ssid = "178">+0.05 +0.57‡ +2.14‡ +0.09‡ +0.60‡ +2.52‡ Table 6: Final results on CTB6 and CTB7 accuracies of POS tagging and dependency parsing were remarkably improved by 0.6% and 2.4%, respectively corresponding to 8.3% and 10.2% error reduction.</S>
			<S sid ="231" ssid = "179">For word segmentation, although the overall improvement was only around 0.1%, greater than 1% improvements was observed for OOV words.</S>
			<S sid ="232" ssid = "180">We conducted some comparison experiments of the partially joint and full joint models.</S>
			<S sid ="233" ssid = "181">Compared to SegTagDep, SegTag+TagDep performs reasonably well in terms of dependency parsing accuracy, whereas the POS tagging accuracies are more than 0.5% lower.</S>
			<S sid ="234" ssid = "182">In future work, probabilistic pruning techniques such as the one based on a maximum entropy model are expected to improve the efficiency of the joint model further because the accuracies are apparently still improved if a larger beam can be used.</S>
			<S sid ="235" ssid = "183">More efficient decoding would also allow the use of the look-ahead features (Hatori et al., 2011) and richer parsing features (Zhang and Nivre, 2011).</S>
			<S sid ="236" ssid = "184">Acknowledgement We are grateful to the anonymous reviewers for their comments and suggestions, and to Xianchao Wu, Kun Yu, Pontus Stenetorp, and Shin- suke Mori for their helpful feedback.</S>
	</SECTION>
</PAPER>
