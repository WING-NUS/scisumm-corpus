<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Dependency cohesion refers to the observation that phrases dominated by disjoint dependency subtrees in the source language generally do not overlap in the target language.</S>
		<S sid ="2" ssid = "2">It has been verified to be a useful constraint for word alignment.</S>
		<S sid ="3" ssid = "3">However, previous work either treats this as a hard constraint or uses it as a feature in discriminative models, which is ineffective for large-scale tasks.</S>
		<S sid ="4" ssid = "4">In this paper, we take dependency cohesion as a soft constraint, and integrate it into a generative model for large-scale word alignment experiments.</S>
		<S sid ="5" ssid = "5">We also propose an approximate EM algorithm and a Gibbs sampling algorithm to estimate model parameters in an unsupervised manner.</S>
		<S sid ="6" ssid = "6">Experiments on large-scale ChineseEnglish translation tasks demonstrate that our model achieves improvements in both alignment quality and translation quality.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">Word alignment is the task of identifying word correspondences between parallel sentence pairs.</S>
			<S sid ="8" ssid = "8">Word alignment has become a vital component of statistical machine translation (SMT) systems, since it is required by almost all state-of-the-art SMT systems for the purpose of extracting phrase tables or even syntactic transformation rules (Koehn et al., 2007; Galley et al., 2004).</S>
			<S sid ="9" ssid = "9">During the past two decades, generative word alignment models such as the IBM Models (Brown et al., 1993) and the HMM model (Vogel et al., 1996) have been widely used, primarily because they are trained on bilingual sentences in an unsupervised manner and the implementation is freely available in the GIZA++ toolkit (Och and Ney, 2003).</S>
			<S sid ="10" ssid = "10">However, the word alignment quality of generative models is still far from satisfactory for SMT systems.</S>
			<S sid ="11" ssid = "11">In recent years, discriminative alignment models incorporating linguistically motivated features have become increasingly popular (Moore, 2005; Taskar et al., 2005; Riesa and Marcu, 2010; Saers et al., 2010; Riesa et al., 2011).</S>
			<S sid ="12" ssid = "12">These models are usually trained with manually annotated parallel data.</S>
			<S sid ="13" ssid = "13">However, when moving to a new language pair, large amount of hand-aligned data are usually unavailable and expensive to create.</S>
			<S sid ="14" ssid = "14">A more practical way to improve large-scale word alignment quality is to introduce syntactic knowledge into a generative model and train the model in an unsupervised manner (Wu, 1997; Yamada and Knight, 2001; Lopez and Resnik, 2005; DeNero and Klein, 2007; Pauls et al., 2010).</S>
			<S sid ="15" ssid = "15">In this paper, we take dependency cohesion (Fox, 2002) into account, which assumes phrases dominated by disjoint dependency subtrees tend not to overlap after translation.</S>
			<S sid ="16" ssid = "16">Instead of treating dependency cohesion as a hard constraint (Lin and Cherry, 2003) or using it as a feature in discriminative models (Cherry and Lin, 2006b), we treat dependency cohesion as a distortion constraint, and integrate it into a modified HMM word alignment model to softly influence the probabilities of alignment candidates.</S>
			<S sid ="17" ssid = "17">We also propose an approximate EM algorithm and an explicit Gibbs sampling algorithm to train the model in an unsupervised manner.</S>
			<S sid ="18" ssid = "18">Experiments on a large-scale ChineseEnglish translation task demonstrate that our model achieves improvements in both word alignment quality and machine translation quality.</S>
			<S sid ="19" ssid = "19">The remainder of this paper is organized as follows: Section 2 introduces dependency cohesion 291 Transactions of the Association for Computational Linguistics, 1 (2013) 291–300.</S>
			<S sid ="20" ssid = "20">Action Editor: Chris CallisonBurch.</S>
			<S sid ="21" ssid = "21">Submitted 5/2013; Published 7/2013.</S>
			<S sid ="22" ssid = "22">c�2013 Association for Computational Linguistics.</S>
			<S sid ="23" ssid = "23">constraint for word alignment.</S>
			<S sid ="24" ssid = "24">Section 3 presents our generative model for word alignment using dependency cohesion constraint.</S>
			<S sid ="25" ssid = "25">Section 4 describes algorithms for parameter estimation.</S>
			<S sid ="26" ssid = "26">We discuss and analyze the experiments in Section 5.</S>
			<S sid ="27" ssid = "27">Section 6 gives the related work.</S>
			<S sid ="28" ssid = "28">Finally, we conclude this paper and mention future work in Section 7.</S>
	</SECTION>
	<SECTION title="Dependency Cohesion Constraint for. " number = "2">
			<S sid ="29" ssid = "1">Word Alignment Given a source (foreign) sentence f 1 = fi, f2, ...</S>
			<S sid ="30" ssid = "2">, fj and a target (English) sentence ell = el, e2, ..., el, the alignment A between fi and el is defined as a subset of the Cartesian product of word positions: A E {(j, i): j = 1,..., J; i = 1, ..., I) When given the source side dependency tree T, we can project dependency subtrees in T onto the target sentence through the alignment A . Dependency cohesion assumes projection spans of disjoint subtrees tend not to overlap.</S>
			<S sid ="31" ssid = "3">Let T(fi) be the subtree of T rooted at fi, we define two kinds of projection span for the node fi: subtree span and head span.</S>
			<S sid ="32" ssid = "4">The subtree span is the projection span of the total subtree T(fi), while the head span is the projection span of the node fi itself.</S>
			<S sid ="33" ssid = "5">Following Fox (2002) and Lin and Cherry (2003), weconsider two types of dependency cohesion: head modifier cohesion and modifier-modifier cohesion.</S>
			<S sid ="34" ssid = "6">Head-modifier cohesion is defined as the subtree span of a node does not overlap with the head span of its head (parent) node, while modifier-modifier cohesion is defined as subtree spans of two nodes under the same head node do not overlap each other.</S>
			<S sid ="35" ssid = "7">We call a situation where cohesion is not maintained crossing.</S>
			<S sid ="36" ssid = "8">Using the dependency tree in Figure 1 as an example, given the correct alignment “R”, the subtree span of “有/have” is [8, 14] , and the head span of its head node “之一/one of” is [3, 4].</S>
			<S sid ="37" ssid = "9">They do not overlap each other, so the head-modifier cohesion is maintained.</S>
			<S sid ="38" ssid = "10">Similarly, the subtree span of “少数/few” is [6, 6], and it does not overlap the subtree span of “有/have”, so a modifier-modifier cohesion is maintained.</S>
			<S sid ="39" ssid = "11">However, when “R” is replaced with the incorrect alignment “W”, the subtree span of “有/have” becomes [3, 14], and it overlaps the head span of its head “之一/one of”, so a head-modifier crossing occurs.</S>
			<S sid ="40" ssid = "12">Meanwhile, the subtree spans of the two nodes “有/have” and“ 少 数 /few” overlap each other, so a modifier modifier crossing occurs.</S>
			<S sid ="41" ssid = "13">是 与 北 韩 有 邦 的 数 国 家 之 。 Figure 1: A ChineseEnglish sentence pair including the word alignments and the Chinese side dependency tree.</S>
			<S sid ="42" ssid = "14">The Chinese and English words are listed horizontally and vertically, respectively.</S>
			<S sid ="43" ssid = "15">The black grids are gold-standard alignments.</S>
			<S sid ="44" ssid = "16">For the Chinese word “有/have”, we give two alignment positions, where “R” is the correct alignment and “W” is the incorrect alignment.</S>
			<S sid ="45" ssid = "17">Fox (2002) showed that dependency cohesion is generally maintained between English and French.</S>
			<S sid ="46" ssid = "18">To test how well this assumption holds between Chinese and English, we measure the dependency cohesion between the two languages with a manually annotated bilingual ChineseEnglish dataset of 502 sentence pairs 1 . We use the head modifier cohesion percentage (HCP) and the modifier-modifier cohesion percentage (MCP) to measure the degree of cohesion in the corpus.</S>
			<S sid ="47" ssid = "19">HCP(or MCP) is used for measuring how many head modifier (or modifier-modifier) pairs are actually cohesive.</S>
			<S sid ="48" ssid = "20">Table 1 lists the relative percentages in both Chinese-to-English (chen, using Chinese side dependency trees) and English-to-Chinese (ench, using English side dependency trees) directions.</S>
			<S sid ="49" ssid = "21">As we see from Table 1, dependency cohesion is 1 The data set is the development set used in Section 5..</S>
			<S sid ="50" ssid = "22">1 Australia.</S>
			<S sid ="51" ssid = "23">is one of the few countries that have diplomatic relations with North Korea . 2 3 4 5 6 7 8 9 10 11 12 13 14 15 澳 洲 少 一 交 292 generally maintained between Chinese and English.</S>
			<S sid ="52" ssid = "24">So dependency cohesion would be helpful for word alignment between Chinese and English.</S>
			<S sid ="53" ssid = "25">However, there are still a number of crossings.</S>
			<S sid ="54" ssid = "26">If we restrict alignment space with a hard cohesion constraint, the correct alignments that result in crossings will be ruled out directly.</S>
			<S sid ="55" ssid = "27">In the next section, we describe an approach to integrating dependency cohesion constraint into a generative model to softly influence the probabilities of alignment candidates.</S>
			<S sid ="56" ssid = "28">We show that our new approach addresses the shortcomings of using dependency cohesion as a hard constraint.</S>
			<S sid ="57" ssid = "29">chen ench HCP MCP HCP MCP 88.43 95.82 81.53 91.62 Table 1: Cohesion percentages (%) of a manually annotated data set between Chinese and English.</S>
	</SECTION>
	<SECTION title="A Generative Word Alignment Model" number = "3">
			<S sid ="58" ssid = "1">with Dependency Cohesion Constraint The most influential generative word alignment models are the IBM Models 15 and the HMM model (Brown et al., 1993; Vogel et al., 1996; Och and Ney, 2003).</S>
			<S sid ="59" ssid = "2">These models can be classified into sequence-based models (IBM Models 1, 2 and HMM) and fertility-based models (IBM Models 3, 4 and 5).</S>
			<S sid ="60" ssid = "3">The sequence-based model is easier to implement, and recent experiments have shown that appropriately modified sequence-based model can produce comparable performance with fertility-based models (Lopez and Resnik, 2005; Liang et al., 2006; DeNero and Klein, 2007; Zhao and Gildea, 2010; Bansal et al., 2011).</S>
			<S sid ="61" ssid = "4">So we built a generative word alignment model with dependency cohesion constraint based on the sequence-based model.</S>
			<S sid ="62" ssid = "5">3.1 The Sequence-based Alignment Model.</S>
			<S sid ="63" ssid = "6">According to Brown et al.</S>
			<S sid ="64" ssid = "7">(1993) and Och and Ney (2003), the sequence-based model is built as a noisy channel model, where the source sentence 𝒇1𝐽 and the alignment 𝒂1𝐽 are generated conditioning on the target sentence 𝒆1𝐼 . The model assumes each source word is assigned to exactly one target word, and defines an asymmetric alignment for the sentence pair as 𝒂1 𝐽 = 𝑎1, 𝑎2, ...</S>
			<S sid ="65" ssid = "8">, 𝑎𝑗, ...</S>
			<S sid ="66" ssid = "9">, 𝑎𝐽, where each 𝑎𝑗 ∈ [0, 𝐼] is an alignment from the source position j to the target position 𝑎𝑗 , 𝑎𝑗 = 0 means 𝑓𝑗 is not aligned with any target words.</S>
			<S sid ="67" ssid = "10">The sequence-based model divides alignment procedure into two stages (distortion and translation) and factors as: 𝐽 𝑝(𝒇1 𝐽, 𝒂1 𝐽|𝒆1 𝐼 ) = ∏ 𝑝𝑑(𝑎𝑗|𝑎𝑗−1, 𝐼)𝑝𝑡(𝑓𝑗|𝑒𝑎𝑗) (1) 𝑗=1 where 𝑝𝑑 is the distortion model and 𝑝𝑡 is the translation model.</S>
			<S sid ="68" ssid = "11">IBM Models 1, 2 and the HMM model all assume the same translation model 𝑝𝑡 (𝑓𝑗|𝑒𝑎𝑗) . However, they use three different distortion models.</S>
			<S sid ="69" ssid = "12">IBM Model 1 assumes a uniform distortion probability 1/(I+1), IBM Model 2 assumes 𝑝𝑑 (𝑎𝑗 |𝑗) that depends on word position j and HMM model assumes 𝑝𝑑(𝑎𝑗|𝑎𝑗−1,𝐼) that depends on the previous alignment 𝑎𝑗−1.</S>
			<S sid ="70" ssid = "13">Recently, tree distance models (Lopez and Resnik, 2005; DeNero and Klein, 2007) formulate the distortion model as 𝑝𝑑(𝑎𝑗|𝑎𝑗−1,𝑇) , where the distance between 𝑎𝑗 and 𝑎𝑗−1 are calculated by walking through the phrase (or dependency) tree T. 3.2 Proposed Model.</S>
			<S sid ="71" ssid = "14">To integrate dependency cohesion constraint into a generative model, we refine the sequence-based model in two ways with the help of the source side dependency tree 𝑇𝑓.</S>
			<S sid ="72" ssid = "15">First, we design a new word alignment order.</S>
			<S sid ="73" ssid = "16">In the sequence-based model, source words are aligned from left to right by taking source sentence as a linear sequence.</S>
			<S sid ="74" ssid = "17">However, to apply dependency cohesion constraint, the subtree span of a head node is computed based on the alignments of its children, so children must be aligned before the head node.</S>
			<S sid ="75" ssid = "18">Riesa and Marcu (2010) propose a hierarchical search procedure to traverse all nodes in a phrase structure tree.</S>
			<S sid ="76" ssid = "19">Similarly, we define a bottom-up topological order (BUT-order) to traverse all words in the source side dependency tree 𝑇𝑓 . In the BUT-order, tree nodes are aligned bottom-up with 𝑇𝑓 as a backbone.</S>
			<S sid ="77" ssid = "20">For all children under the same head node, left children are aligned from right to left, and then right children are aligned from left to right.</S>
			<S sid ="78" ssid = "21">For example, the BUT-order for the following dependency tree is “C B E F D A H G”.</S>
			<S sid ="79" ssid = "22">A B C D E F G H 293 For the sake of clarity, we define a function to map all nodes in 𝑇𝑓 into their BUT-order, and notate it as BUT(𝑇𝑓) = 𝜋1, 𝜋2, ..., 𝜋𝑗, ..., 𝜋𝐽, where 𝜋𝑗 means the j-th node in BUT-order is the 𝜋𝑗-th word in the original source sentence.</S>
			<S sid ="80" ssid = "23">We arrange alignment sequence 𝒂1𝐽 according the BUT-order and notate it as 𝒂[1,𝐽] = 𝑎𝜋 1, ...</S>
			<S sid ="81" ssid = "24">, 𝑎𝜋𝑗, ...</S>
			<S sid ="82" ssid = "25">, 𝑎𝜋 𝐽 , where 𝑎𝜋𝑗 is the aligned position for a node 𝑓𝜋𝑗.</S>
			<S sid ="83" ssid = "26">We also notate the sub-sequence 𝑎𝜋 𝑖, . .., 𝑎𝜋𝑗as 𝒂[𝑖 ,𝑗].</S>
			<S sid ="84" ssid = "27">Second, we keep the same translation model as the sequence-based model and integrate the dependency cohesion constraints into the distortion model.</S>
			<S sid ="85" ssid = "28">The main idea is to influence the distortion procedure with the dependency cohesion constraints.</S>
			<S sid ="86" ssid = "29">Assume node 𝑓ℎ and node 𝑓𝑚 are a head-modifier pair in 𝑇𝑓, where 𝑓ℎ is the head and 𝑓𝑚 is the modifier.</S>
			<S sid ="87" ssid = "30">The head-modifier cohesion relationship between them is notated as 𝒽ℎ,𝑚 ∈ {𝑐𝑜ℎ𝑒𝑠𝑖𝑜𝑛, 𝑐𝑟𝑜𝑠𝑠𝑖𝑛𝑔} . When the head-modifier cohesion is maintained 𝒽ℎ,𝑚 = 𝑐𝑜ℎ𝑒𝑠𝑖𝑜𝑛, otherwise𝒽ℎ,𝑚 = 𝑐𝑟𝑜𝑠𝑠𝑖𝑛𝑔.</S>
			<S sid ="88" ssid = "31">We represent the set of headmodifier cohesion relationships for all the head modifier pairs in 𝑇𝑓 as: 𝑯 = {𝒽ℎ,𝑚 |ℎ ∈ [1,𝐽], 𝑚 ∈ [1,𝐽], ℎ ≠ 𝑚, 𝑓ℎ and 𝑓𝑚 are a head-modifier pair in 𝑇𝑓 } The set of head-modifier cohesion relationships for all the head-modifier pairs taking 𝑓ℎ as the head node can be represented as: 𝓱ℎ = {𝒽ℎ,𝑚 |𝑚 ∈ [1,𝐽], 𝑚 ≠ ℎ, 𝑓ℎ and 𝑓𝑚 are a head-modifier pair in 𝑇𝑓 } Obviously, 𝑯 = ⋃ 𝓱ℎ 𝐽 ℎ=0 . Similarly, we assume node 𝑓𝑘 and node 𝑓𝑙 are a modifier-modifier pair in 𝑇𝑓.</S>
			<S sid ="89" ssid = "32">To avoid repetition, we assume 𝑓𝑘 is the node sitting at the positionafter 𝑓𝑙 in BUT-order and call 𝑓𝑘 as the higher order node of the pair.</S>
			<S sid ="90" ssid = "33">The modifier-modifier cohesion relationship between them is notated as𝓂𝑘,𝑙 ∈ {𝑐𝑜ℎ𝑒𝑠𝑖𝑜𝑛, 𝑐𝑟𝑜𝑠𝑠𝑖𝑛𝑔} . When the modifier modifier cohesion is maintained 𝓂𝑘,𝑙 = 𝑐𝑜ℎ𝑒𝑠𝑖𝑜𝑛, otherwise 𝓂𝑘,𝑙 = 𝑐𝑟𝑜𝑠𝑠𝑖𝑛𝑔.</S>
			<S sid ="91" ssid = "34">We represent the set of modifier-modifier cohesion relationships for all the modifier-modifier pairs in 𝑇𝑓 as: 𝑴 = {𝓂𝑘,𝑙 |𝑘 ∈ [1,𝐽], 𝑙 ∈ [1,𝐽], 𝑘 ≠ 𝑙, 𝑓𝑘 and 𝑓𝑙 are a modifier-modifier pair in 𝑇𝑓 } The set of modifier-modifier cohesion relationships for all the modifier-modifier pairs taking 𝑓𝑘 as the higher-order node can be represented as: 𝓶𝑘 = {𝓂𝑘,𝑙 |𝑙 ∈ [1,𝐽], 𝑙 ≠ 𝑘, 𝑓𝑘 and 𝑓𝑙 are a modifier-modifier pair in 𝑇𝑓 } Obviously, 𝑴 = ⋃ 𝓶𝑘 𝐽 𝑘=0 . With the above notations, we formulate the distortion probability for a node 𝑓𝜋𝑗 as 𝑝𝑑 (𝑎𝜋𝑗, 𝓱𝜋𝑗,𝓶𝜋𝑗|𝒂[1,𝑗−1]).</S>
			<S sid ="92" ssid = "35">According to Eq.</S>
			<S sid ="93" ssid = "36">(1) and the two improvements, we formulated our model as: 𝑝(𝒇1𝐽, 𝒂[1,𝐽]|𝒆1𝐼, 𝑇𝑓) = 𝑝(𝒂[1,𝐽], 𝑯, 𝑴, 𝒇1𝐽, |𝒆1𝐼, 𝑇𝑓 ) ≈∏𝜋𝑗∈𝐵𝑈𝑇(𝑇𝑓)𝑝𝑑(𝑎𝜋𝑗,𝓱𝜋𝑗, 𝓶𝜋𝑗|𝒂[1,𝑗−1]) 𝑝𝑡(𝑓𝜋𝑗|𝑒𝑎𝜋𝑗) Here, we use the approximation symbol, because the right hand side is not guaranteed to be normalized.</S>
			<S sid ="94" ssid = "37">In practice, we only compute ratios of these terms, so it is not actually a problem.</S>
			<S sid ="95" ssid = "38">Such model is called deficient (Brown et al., 1993), and many successful unsupervised models are deficient, e.g., IBM model 3 and IBM model 4.</S>
			<S sid ="96" ssid = "39">3.3 Dependency Cohesive Distortion Model.</S>
			<S sid ="97" ssid = "40">We assume the distortion procedure is influenced by three factors: words distance, head-modifier cohesion and modifier-modifier cohesion.</S>
			<S sid ="98" ssid = "41">Therefore, we further decompose the distortion model 𝑝𝑑 into three terms as follows: 𝑝𝑑 (𝑎𝜋𝑗, 𝓱𝜋𝑗, 𝓶𝜋𝑗|𝒂[1,𝑗−1]) = 𝑝 (𝑎𝜋𝑗|𝒂[1,𝑗−1]) 𝑝 (𝓱𝜋𝑗 |𝒂[1,𝑗]) 𝑝 (𝓶𝜋𝑗 |𝒂[1,𝑗], 𝓱𝜋𝑗) ≈𝑝𝑤𝑑 (𝑎𝜋𝑗 |𝑎𝜋𝑗−1, 𝐼) 𝑝ℎ𝑐 (𝓱𝜋𝑗 |𝒂[1,𝑗]) 𝑝𝑚𝑐 (𝓶𝜋𝑗 |𝒂[1,𝑗]) where 𝑝 𝑤𝑑 is the words distance term, 𝑝ℎ𝑐 is the head-modifier cohesion term and 𝑝𝑚𝑐 is the modifier-modifier cohesion term.</S>
			<S sid ="99" ssid = "42">The word distance term 𝑝 𝑤𝑑 has been verified to be very useful in the HMM alignment model.</S>
			<S sid ="100" ssid = "43">However, in our model, the word distance iscalculated based on the previous node in BUT order rather than the previous word in the original sentence.</S>
			<S sid ="101" ssid = "44">We follow the HMM word alignment model (Vogel et al., 1996) and parameterize 𝑝 𝑤𝑑 in terms of the jump width: 𝑝𝑤𝑑(𝑖|𝑖′,𝐼) = 𝑐(𝑖−𝑖′) ∑ 𝑐(𝑖′′−𝑖′) 𝑖′′ (4) where 𝑐() is the count of jump width.</S>
			<S sid ="102" ssid = "45">294 The head-modifier cohesion term 𝑝ℎ𝑐 is used to penalize the distortion probability according to relationships between the head node and its children (modifiers).</S>
			<S sid ="103" ssid = "46">Therefore, we define 𝑝ℎ𝑐 as the product of probabilities for all head-modifier pairs taking 𝑓𝜋𝑗 as head node: 𝑝ℎ𝑐 (𝓱𝜋𝑗|𝒂[1,𝑗]) = ∏ 𝒽𝜋𝑗,𝑐∈𝓱𝜋𝑗 𝑝ℎ (𝒽𝜋𝑗,𝑐|𝑓𝑐, 𝑒𝑎𝜋𝑗, 𝑒𝑎𝑐) (5)where 𝒽𝜋𝑗,𝑐 ∈ {𝑐𝑜ℎ𝑒𝑠𝑖𝑜𝑛, 𝑐𝑟𝑜𝑠𝑠𝑖𝑛𝑔} is the head modifier cohesion relationship between 𝑓𝜋 𝑗 and one of its child 𝑓𝑐 , 𝑝ℎ is the corresponding probability, 𝑒𝑎𝜋 𝑗 and 𝑒𝑎𝑐 are the aligned words for 𝑓𝜋 𝑗 and 𝑓𝑐.</S>
			<S sid ="104" ssid = "47">Similarly, the modifier-modifier cohesion term 𝑝𝑚𝑐 is used to penalize the distortion probability according to relationships between 𝑓𝜋𝑗 and its siblings.</S>
			<S sid ="105" ssid = "48">Therefore, we define 𝑝𝑚𝑐 as the product of probabilities for all the modifier-modifier pairs taking 𝑓𝜋𝑗 as the higher-order node: 𝑝𝑚𝑐 (𝓶𝜋𝑗 |𝒂[1,𝑗]) = ∏𝓂𝜋𝑗,𝑠∈𝓶𝜋𝑗 𝑝𝑚 (𝓂𝜋𝑗,𝑠 |𝑓𝑠, 𝑒𝑎𝜋𝑗, 𝑒𝑎𝑠) (6)where 𝓂𝜋𝑗,𝑠 ∈ {𝑐𝑜ℎ𝑒𝑠𝑖𝑜𝑛, 𝑐𝑟𝑜𝑠𝑠𝑖𝑛𝑔} is the modifier modifier cohesion relationship between 𝑓𝜋 𝑗 and one of its sibling 𝑓𝑠 , 𝑝𝑚 is the corresponding probability, 𝑒𝑎𝜋 𝑗 and 𝑒𝑎𝑠 are the aligned words for 𝑓𝜋𝑗 and 𝑓𝑠. Both 𝑝ℎ and 𝑝𝑚 in Eq.</S>
			<S sid ="106" ssid = "49">(5) and Eq.</S>
			<S sid ="107" ssid = "50">(6) are conditioned on three words, which would make them very sparse.</S>
			<S sid ="108" ssid = "51">To cope with this problem, we use the word clustering toolkit, mkcls (Och et al., 1999), to cluster all words into 50 classes, and replace the three words with their classes.</S>
	</SECTION>
	<SECTION title="Parameter Estimation. " number = "4">
			<S sid ="109" ssid = "1">To align sentence pairs with the model in Eq.</S>
			<S sid ="110" ssid = "2">(2), we have to estimate some parameters: 𝑝𝑡, 𝑝𝑤𝑑, 𝑝ℎand 𝑝𝑚. The traditional approach for sequence based models uses Expectation Maximization (EM) algorithm to estimate parameters.</S>
			<S sid ="111" ssid = "3">However, in our model, it is hard to find an efficient way to sum over all the possible alignments, which is required in the E-step of EM algorithm.</S>
			<S sid ="112" ssid = "4">Therefore, we propose an approximate EM algorithm and a Gibbs sampling algorithm for parameter estimation.</S>
			<S sid ="113" ssid = "5">4.1 Approximate EM Algorithm.</S>
			<S sid ="114" ssid = "6">The approximate EM algorithm is similar to the training algorithm for fertility-based alignment models (Och and Ney, 2003).</S>
			<S sid ="115" ssid = "7">The main idea is to enumerate only a small subset of good alignments in the E-step, then collect expectation counts andestimate parameters among the small subset in M step.</S>
			<S sid ="116" ssid = "8">Following with Och and Ney (2003), we employ neighbor alignments of the Viterbi alignment as the small subset.</S>
			<S sid ="117" ssid = "9">Neighbor alignments are obtained by performing one swap or move operation over the Viterbi alignment.</S>
			<S sid ="118" ssid = "10">Obtaining the Viterbi alignment itself is not so easy for our model.</S>
			<S sid ="119" ssid = "11">Therefore, we take the Viterbi alignment of the sequence-based model (HMMmodel) as the starting point, and iterate the hill climbing algorithm (Brown et al., 1993) many times to get the best alignment greedily.</S>
			<S sid ="120" ssid = "12">In each iteration, we find the best alignment with Eq.</S>
			<S sid ="121" ssid = "13">(2) among neighbor alignments of the initial point, and then make the best alignment as the initial point for the next iteration.</S>
			<S sid ="122" ssid = "14">The algorithm iterates until no update could be made.</S>
			<S sid ="123" ssid = "15">4.2 Gibbs Sampling Algorithm.</S>
			<S sid ="124" ssid = "16">Gibbs sampling is another effective algorithm for unsupervised learning problems.</S>
			<S sid ="125" ssid = "17">As is described in the literatures (Johnson et al., 2007; Gao and Johnson, 2008), there are two types of Gibbs samplers: explicit and collapsed.</S>
			<S sid ="126" ssid = "18">An explicit sampler represents and samples the model parameters in addition to the word alignments, while in a collapsed sampler the parameters are integrated out and only alignments are sampled.</S>
			<S sid ="127" ssid = "19">Mermer and Saraçlar (2011) proposed a collapsed sampler for IBM Model 1.</S>
			<S sid ="128" ssid = "20">However, their sampler updates parameters constantly and thus cannot run efficiently on large-scale tasks.</S>
			<S sid ="129" ssid = "21">Instead, we take advantage of explicit Gibbs sampling to make a highly parallelizable sampler.</S>
			<S sid ="130" ssid = "22">Our Gibbs sampler is similar to the MCMC algorithm in Zhao and Gildea (2010), but we assume Dirichlet priors when sampling model parameters and take a different sampling approach based on the source side dependency tree.</S>
			<S sid ="131" ssid = "23">Our sampler performs a sequence of consecutive iterations.</S>
			<S sid ="132" ssid = "24">Each iteration consists of two sampling steps.</S>
			<S sid ="133" ssid = "25">The first step samples the aligned positionfor each dependency node according to the BUT order.</S>
			<S sid ="134" ssid = "26">Concretely, when sampling the aligned 295 position 𝑎𝜋𝑗 (𝑡+1) for node 𝑓𝜋𝑗 on iteration 𝑡+1, the aligned positions for 𝒂[1,𝑗−1] are fixed on the new sampling results 𝒂[1,𝑗−1] (𝑡+1) on iteration 𝑡+1, and the aligned positions for 𝒂[𝑗+1,𝐽] are fixed on the old sampling results 𝒂[𝑗+1,𝐽] (𝑡) on iteration 𝑡.</S>
			<S sid ="135" ssid = "27">Therefore, we sample the aligned position 𝑎𝜋𝑗 (𝑡+1) as follows: 𝑎𝜋𝑗 (𝑡+1) ~ 𝑝 (𝑎𝜋𝑗|𝒂[1,𝑗−1] (𝑡+1) , 𝒂[𝑗+1,𝐽] (𝑡) , 𝑓1 𝐽, 𝑒1 𝐼) 𝑝(𝒇1𝐽, 𝒂̂𝑎𝜋𝑗|𝒆1𝐼) ∑ 𝑝 (𝒇1 𝐽,𝒂̂𝑎𝜋𝑗|𝒆1 𝐼 ) 𝑎𝜋𝑗∈{0,1,...,𝐼} (7) where 𝒂̂𝑎𝜋𝑗 = 𝒂[1,𝑗−1] (𝑡+1) ∪ 𝑎𝜋𝑗 ∪ 𝒂[𝑗+1,𝐽] (𝑡) , the numerator is the probability of aligning 𝑓𝜋𝑗 with 𝑒𝑎𝜋𝑗 (the alignments for other nodes are fixed at 𝒂[1,𝑗−1] (𝑡+1) and 𝒂[𝑗+1,𝐽] (𝑡) ) calculated with Eq.</S>
			<S sid ="136" ssid = "28">(2), and the denominator is the summation of the probabilities of aligning 𝑓𝜋𝑗 with each target word.</S>
			<S sid ="137" ssid = "29">The second step of our sampler calculates parameters 𝑝𝑡, 𝑝𝑤𝑑, 𝑝ℎ and 𝑝𝑚 using their counts, where all these counts can be easily collected during the first sampling step.</S>
			<S sid ="138" ssid = "30">Because all these parameters follow multinomial distributions, we consider Dirichlet priors for them, which would greatly simplify the inference procedure.</S>
			<S sid ="139" ssid = "31">In the first sampling step, all the sentence pairs are processed independently.</S>
			<S sid ="140" ssid = "32">So we can make this step parallel and process all the sentence pairs efficiently with multi-threads.</S>
			<S sid ="141" ssid = "33">When using the Gibbs sampler for decoding, we just ignore the second sampling step and iterate the first sampling step many times.</S>
	</SECTION>
	<SECTION title="Experiments. " number = "5">
			<S sid ="142" ssid = "1">We performed a series of experiments to evaluate our model.</S>
			<S sid ="143" ssid = "2">All the experiments are conducted on the ChineseEnglish language pair.</S>
			<S sid ="144" ssid = "3">We employ two training sets: FBIS and LARGE.</S>
			<S sid ="145" ssid = "4">The size and source corpus of these training sets are listed in Table 2.</S>
			<S sid ="146" ssid = "5">We will use the smaller training set FBIS to evaluate the characters of our model and use the LARGE training set to evaluate whether our model is adaptable for large-scale task.</S>
			<S sid ="147" ssid = "6">For wordalignment quality evaluation, we take the hand aligned data sets from SSMT20072, which contains2 http://nlp.ict.ac.cn/guidelines/guidelines-2007 SSMT(English).doc 505 sentence pairs in the testing set and 502 sentence pairs in the development set.</S>
			<S sid ="148" ssid = "7">Following Och and Ney (2003), we evaluate word alignment quality with the alignment error rate (AER), where lower AER is better.</S>
			<S sid ="149" ssid = "8">Because our model takes dependency trees as input, we parse both sides of the two training sets, the development set and the testing set with Berkeley parser (Petrov et al., 2006), and then convert the generated phrase trees into dependency trees according to Wang and Zong (2010; 2011).</S>
			<S sid ="150" ssid = "9">Our model is an asymmetric model, so we perform word alignment in both forward (Chinese4English) and reverse (English4Chinese) directions.</S>
			<S sid ="151" ssid = "10">Train Set Source Corpus # Words FBIS FBIS newswire data Ch: 7.1M En: 9.1M LARGE LDC2000T50, LDC2003E14, Ch: 27.6M LDC2003E07, LDC2004T07, En: 31.8M LDC2005T06, LDC2002L27, LDC2005T10, LDC2005T34 Table 2: The size and the source corpus of the two training sets.</S>
			<S sid ="152" ssid = "11">5.1 Effectiveness of Cohesion Constraints.</S>
			<S sid ="153" ssid = "12">In Eq.</S>
			<S sid ="154" ssid = "13">(3), the distortion probability 𝑝𝑑 is decomposed into three terms: 𝑝𝑤𝑑, 𝑝ℎ𝑐 and 𝑝𝑚𝑐 . To study whether cohesion constraints are effective for word alignment, we construct four sub-models as follows: (1) wd: 𝑝𝑑 = 𝑝𝑤𝑑; (2) wdhc: 𝑝𝑑 = 𝑝𝑤𝑑 ∙ 𝑝ℎ𝑐; (3) wdmc: 𝑝𝑑 = 𝑝𝑤𝑑 ∙ 𝑝𝑚𝑐; (4) wdhc-mc: 𝑝𝑑 = 𝑝𝑤𝑑 ∙ 𝑝ℎ𝑐 ∙ 𝑝𝑚𝑐.</S>
			<S sid ="155" ssid = "14">We train these four models with the approximate EM and the Gibbs sampling algorithms on the FBIS training set.</S>
			<S sid ="156" ssid = "15">For approximate EM algorithm, we first train a HMM model (with 5 iterations of IBM model 1 and 5 iterations of HMM model), then train these four sub-models with 10 iterations of the approximate EM algorithm.</S>
			<S sid ="157" ssid = "16">For Gibbs sampling, we choose symmetric Dirichlet priors identically with all hyper-parameters equals 0.0001 to obtain a sparse Dirichlet prior.</S>
			<S sid ="158" ssid = "17">Then, we make the alignments produced by the HMM model as the initial points, and train these sub-models with 20 iterations of the Gibbs sampling.</S>
			<S sid ="159" ssid = "18">AERs on the development set are listed in Table 3.</S>
			<S sid ="160" ssid = "19">We can easily find: 1) when employing the.</S>
			<S sid ="161" ssid = "20">head-modifier cohesion constraint, the wdhc model yields better AERs than the wd model; 2) = 296 when employing the modifier-modifier cohesion constraint, the wdmc model also yields better AERs than the wd model; and 3) when employing both head-modifier cohesion constraint and modifier-modifier cohesion constraint together, the wdhc-mc model yields the best AERs among the four sub-models.</S>
			<S sid ="162" ssid = "21">So both head-modifier cohesion constraint and modifier-modifier cohesion constraint are helpful for word alignment.</S>
			<S sid ="163" ssid = "22">Table 3 also shows that the approximate EM algorithm yields better AERs in the forward direction than reverse direction, while the Gibbs sampling algorithm yields close AERs in both directions.</S>
			<S sid ="164" ssid = "23">EM Gibbs forward reverse forward reverse wd 26.12 28.66 27.09 26.40 wdhc 24.67 25.86 26.24 24.39 wdmc 24.49 26.53 25.51 25.40 wdhc-mc 23.63 25.17 24.65 24.33 Table 3: AERs on the development set (trained on the FBIS data set).</S>
			<S sid ="165" ssid = "24">5.2 Comparison with State-of-the-Art Models.</S>
			<S sid ="166" ssid = "25">To show the effectiveness of our model, wecompare our model with some of the state-of-the art models.</S>
			<S sid ="167" ssid = "26">All the systems are listed as follows: 1) IBM4: The fertility-based model (IBM model 4) which is implemented in GIZA++ toolkit.</S>
			<S sid ="168" ssid = "27">The training scheme is 5 iterations of IBM model 1, 5 iterations of the HMM model and 10 iterations of IBM model 4.</S>
			<S sid ="169" ssid = "28">2) IBM4L0: A modification to the GIZA++toolkit which extends IBM models with ℓ0 norm (Vaswani et al., 2012).</S>
			<S sid ="170" ssid = "29">The training scheme is the same as IBM4.</S>
			<S sid ="171" ssid = "30">3) IBM4-Prior: A modification to the GIZA++ toolkit which extends the translation model of IBM models with Dirichlet priors (Riley and Gildea, 2012).</S>
			<S sid ="172" ssid = "31">The training scheme is the same as IBM4.</S>
			<S sid ="173" ssid = "32">4) Agree-HMM: The HMM alignment model by jointly training the forward and reverse models (Liang et al., 2006), which is implemented in the BerkeleyAligner.</S>
			<S sid ="174" ssid = "33">The training scheme is 5 iterations of jointly training IBM model 1 and 5 iterations of jointly training HMM model.</S>
			<S sid ="175" ssid = "34">5) Tree-Distance: The tree distance alignment model proposed in DeNero and Klein (2007), which is implemented in the BerkeleyAligner.</S>
			<S sid ="176" ssid = "35">The training scheme is 5 iterations of jointly training IBM model 1 and 5 iterations of jointly training the tree distance model.</S>
			<S sid ="177" ssid = "36">6) Hard-Cohesion: The implemented “Cohesion Checking Algorithm” (Lin and Cherry, 2003) which takes dependency cohesion as a hard constraint during beam search word alignment decoding.</S>
			<S sid ="178" ssid = "37">We use the model trained by the Agree-HMM system to estimate alignment candidates.</S>
			<S sid ="179" ssid = "38">We also build two systems for our soft dependency cohesion model: 7) Soft-Cohesion-EM: the wdhc-mc sub-model trained with the approximate EM algorithm as described in subsection 5.1.</S>
			<S sid ="180" ssid = "39">8) Soft-Cohesion-Gibbs: the wdhc-mc sub-model trained with the Gibbs sampling algorithm as described in subsection 5.1.</S>
			<S sid ="181" ssid = "40">We train all these systems on the FBIS training set, and test them on the testing set.</S>
			<S sid ="182" ssid = "41">We also combine the forward and reverse alignments with the grow-diag-final-and (GDFA) heuristic (Koehn et al., 2007).</S>
			<S sid ="183" ssid = "42">All AERs are listed in Table 4.</S>
			<S sid ="184" ssid = "43">We find our soft cohesion systems produce better AERs than the Hard-Cohesion system as well as the other systems.</S>
			<S sid ="185" ssid = "44">Table 5 gives the head-modifiercohesion percentage (HCP) and the modifier modifier cohesion percentage (MCP) of each system.</S>
			<S sid ="186" ssid = "45">We find HCPs and MCPs of our softcohesion systems are much closer to the gold standard alignments.</S>
			<S sid ="187" ssid = "46">forward reverse GDFA IBM4 42.90 42.81 44.32 IBM4L0 42.59 41.04 43.19 IBM4-Prior 41.94 40.46 42.44 Agree-HMM 38.03 37.91 41.01 Tree-Distance 34.21 37.22 38.42 Hard-Cohesion 37.32 38.92 38.92 Soft-Cohesion-EM 33.65 34.74 35.85 Soft-Cohesion-Gibbs 34.45 33.72 34.46 Table 4: AERs on the testing set (trained on the FBIS data set).</S>
			<S sid ="188" ssid = "47">To evaluate whether our model is adaptable for large-scale task, we retrained these systems using the LARGE training set.</S>
			<S sid ="189" ssid = "48">AERs on the testing set are listed in Table3 6.</S>
			<S sid ="190" ssid = "49">Compared with Table 4, we 3 Tree-Distance system requires too much memory to run on.</S>
			<S sid ="191" ssid = "50">our server when using the LARGE data set, so we can’t get the result.</S>
			<S sid ="192" ssid = "51">297 find all the systems yield better performance when using more training data.</S>
			<S sid ="193" ssid = "52">Our soft cohesion systems still produce better AERs than other systems, suggesting that our soft cohesion model is very effective for large-scale word alignment tasks.</S>
			<S sid ="194" ssid = "53">forward reverse HCP MCP HCP MCP IBM4 60.53 63.94 56.15 64.80 IBM4L0 60.57 62.53 66.49 65.68 IBM4-Prior 66.48 74.65 67.19 72.32 Agree-HMM 75.52 66.61 73.88 66.07 Tree-Distance 81.37 74.69 78.00 71.73 Hard-Cohesion 98.70 97.43 98.25 97.84 Soft-Cohesion-EM 85.21 81.96 82.96 81.36 Soft-Cohesion-Gibbs 88.74 85.55 87.81 84.83 gold-standard 88.43 95.82 81.53 91.62 Table 5: HCPs and MCPs on the development set.</S>
			<S sid ="195" ssid = "54">forward reverse GDFA IBM4 37.45 39.18 40.52 IBM4L0 38.17 38.88 39.82 IBM4-Prior 35.86 36.71 37.08 Agree-HMM 35.58 35.73 39.10 Hard-Cohesion 35.04 37.59 37.63 Soft-Cohesion-EM 30.93 32.67 33.65 Soft-Cohesion-Gibbs 32.07 32.68 32.28 Table 6: AERs on the testing set (trained on the LARGE data set).</S>
			<S sid ="196" ssid = "55">5.3 Machine Translation Quality Comparison.</S>
			<S sid ="197" ssid = "56">We then evaluate the effect of word alignment on machine translation quality using the phrase-based translation system Moses (Koehn et al., 2007).</S>
			<S sid ="198" ssid = "57">We take NIST MT03 test data as the development set, NIST MT05 test data as the testing set.</S>
			<S sid ="199" ssid = "58">We train a 5-gram language model with the Xinhua portion of English Gigaword corpus and the English side of the training set using the SRILM Toolkit (Stolcke, 2002).</S>
			<S sid ="200" ssid = "59">We train machine translation models using GDFA alignments of each system.</S>
			<S sid ="201" ssid = "60">BLEU scores on NIST MT05 are listed in Table 7, where BLEU scores are calculated using lowercased and tokenized data (Papineni et al., 2002).</S>
			<S sid ="202" ssid = "61">Although the IBM4L0, Agree-HMM, Tree-Distance and Hard-Cohesion systems improve word alignment than IBM4, they fail to outperform the IBM4 system on machine translation.</S>
			<S sid ="203" ssid = "62">The BLEU score of our Soft-Cohesion-EM system is better than the IBM4 system when using the FBIS training set, but worse when using the LARGE training set.</S>
			<S sid ="204" ssid = "63">Our Soft-Cohesion-Gibbs system produces the best BLEU score when using both training sets.</S>
			<S sid ="205" ssid = "64">We also performed a statistical significance test using bootstrap resampling with 1000 samples (Koehn, 2004; Zhang et al., 2004).</S>
			<S sid ="206" ssid = "65">Experimental results show the Soft-Cohesion-Gibbs system is significantly better (p&amp;lt;0.05) than the IBM4 system.</S>
			<S sid ="207" ssid = "66">The IBM4-Prior system slightly outperforms IBM4, but it’s not significant.</S>
			<S sid ="208" ssid = "67">FBIS LARGE IBM4 30.7 33.1 IBM4L0 30.4 32.3 IBM4-Prior 30.9 33.2 Agree-HMM 27.2 30.1 Tree-Distance 28.2 N/A Hard-Cohesion 30.4 32.2 Soft-Cohesion-EM 30.9 33.1 Soft-Cohesion-Gibbs 31.6* 33.9* Table 7: BLEU scores, where * indicates significantly better than IBM4 (p&amp;lt;0.05).</S>
	</SECTION>
	<SECTION title="Related Work. " number = "6">
			<S sid ="209" ssid = "1">There have been many proposals of integrating syntactic knowledge into generative alignment models.</S>
			<S sid ="210" ssid = "2">Wu (1997) proposed the inversion transduction grammar (ITG) to model word alignment as synchronous parsing for a sentence pair.</S>
			<S sid ="211" ssid = "3">Yamada and Knight (2001) represented translation as a sequence of reordering operations over child nodes of a syntactic tree.</S>
			<S sid ="212" ssid = "4">Gildea (2003) introduced a “loosely” tree-based alignment technique, which allows alignments to violate syntactic constraints by incurring a cost in probability.</S>
			<S sid ="213" ssid = "5">Pauls et al.</S>
			<S sid ="214" ssid = "6">(2010) gave a new instance of the ITG formalism, in which one side of the synchronous derivation is constrained by the syntactic tree.</S>
			<S sid ="215" ssid = "7">Fox (2002) measured syntactic cohesion in gold standard alignments and showed syntactic cohesion is generally maintained between English and French.</S>
			<S sid ="216" ssid = "8">She also compared three variant syntactic representations (phrase tree, verb phrase flattening tree and dependency tree), and found the dependency tree produced the highest degree of cohesion.</S>
			<S sid ="217" ssid = "9">So Cherry and Lin (2003; 2006a) used dependency cohesion as a hard constraint to restrict the alignment space, where all potential alignments violating cohesion constraint are ruled 298 out directly.</S>
			<S sid ="218" ssid = "10">Although the alignment quality is improved, they ignored situations where a small set of correct alignments can violate cohesion.</S>
			<S sid ="219" ssid = "11">To address this limitation, Cherry and Lin (2006b) proposed a soft constraint approach, which took dependency cohesion as a feature of a discriminative model, and verified that the soft constraint works better than the hard constraint.However, the training procedure is very time consuming, and they trained the model with only 100 hand-annotated sentence pairs.</S>
			<S sid ="220" ssid = "12">Therefore, their method is not suitable for large-scale tasks.</S>
			<S sid ="221" ssid = "13">In this paper, we also use dependency cohesion as a soft constraint.</S>
			<S sid ="222" ssid = "14">But, unlike Cherry and Lin (2006b), we integrate the soft dependency cohesion constraint into a generative model that is more suitable for large-scale word alignment tasks.</S>
	</SECTION>
	<SECTION title="Conclusion and Future Work. " number = "7">
			<S sid ="223" ssid = "1">We described a generative model for word alignment that uses dependency cohesion as a soft constraint.</S>
			<S sid ="224" ssid = "2">We proposed an approximate EM algorithm and an explicit Gibbs sampling algorithm for parameter estimation in an unsupervised manner.</S>
			<S sid ="225" ssid = "3">Experimental results performed on a large-scale data set show that our model improves word alignment quality as well as machine translation quality.</S>
			<S sid ="226" ssid = "4">Our experimental results also indicate that the soft constraint approach is much better than the hard constraint approach.</S>
			<S sid ="227" ssid = "5">It is possible that our word alignment model can be improved further.</S>
			<S sid ="228" ssid = "6">First, we generated word alignments in both forward and reverse directions separately, but it might be helpful to use dependency trees of the two sides simultaneously.</S>
			<S sid ="229" ssid = "7">Second, we only used the one-best automatically generated dependency trees in the model.</S>
			<S sid ="230" ssid = "8">However, errors are inevitable in those trees, so we will investigate how to use N-best dependency trees or dependency forests (Hayashi et al., 2011) to see if they can improve our model.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="231" ssid = "9">We would like to thank Nianwen Xue for insightful discussions on writing this article.</S>
			<S sid ="232" ssid = "10">We are grateful to anonymous reviewers for many helpful suggestions that helped improve the final version of this article.</S>
			<S sid ="233" ssid = "11">The research work has been funded by the Hi-Tech Research and Development Program (&amp;amp;quot;863&amp;amp;quot; Program) of China under Grant No. 2011AA01A207, 2012AA011101, and 2012AA011102 and also supported by the Key Project of Knowledge Innovation Program of Chinese Academy of Sciences under Grant No.KGZDEW-501.</S>
			<S sid ="234" ssid = "12">This work is also supported inpart by the DAPRA via contract HR001111-C 0145 entitled &amp;amp;quot;Linguistic Resources for Multilingual Processing&amp;amp;quot;.</S>
	</SECTION>
</PAPER>
