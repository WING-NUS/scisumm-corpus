If the key distribution’s range is also known (i.e. vocabulary identifiers range from 0 to the number of words)  then interpolation search can use this information instead of reading A[0] and A[|A |− 1] to estimate pivots; this optimization alone led to a 24% speed improvement.For the perplexity and translation tasks  we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn  2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.For example  syntactic decoders (Koehn et al.  2007; Dyer et al.  2010; Li et al.  2009) perform dynamic programming parametrized by both backward- and forward-looking state.We evaluate the time and memory consumption of each data structure by computing perplexity on 4 billion tokens from the English Gigaword corpus (Parker et al.  2009).Performance improvements transfer to the Moses (Koehn et al.  2007)  cdec (Dyer et al.  2010)  and Joshua (Li et al.  2009) translation systems where our code has been integrated.The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.All language model queries issued by machine translation decoders follow a left-to-right pattern  starting with either the begin of sentence token or null context for mid-sentence fragments.Along with IRSTLM and TPT  our binary format is memory mapped  meaning the file and in-memory representation are the same.The model was built with open vocabulary  modified Kneser-Ney smoothing  and default pruning settings that remove singletons of order 3 and higher.Compared with SRILM  IRSTLM adds several features: lower memory consumption  a binary file format with memory mapping  caching to increase speed  and quantization.As noted in Section 1  our code finds the longest matching entry wnf for query p(wn|s(wn−1 f ) The probability p(wn|wn−1 f ) is stored with wnf and the backoffs are immediately accessible in the provided state s(wn−1 When our code walks the data structure to find wnf   it visits wnn  wnn−1  ...   wnf .The authors provided us with a ratio between TPT and SRI under different conditions. aLossy compression with the same weights. bLossy compression with retuned weights. ditions make the value appropriate for estimating repeated run times  such as in parameter tuning.Language models that contain wi must also contain prefixes wi for 1 G i G k. Therefore  when the model is queried for p(wnjwn−1 1 ) but the longest matching suffix is wnf   it may return state s(wn1) = wnf since no longer context will be found.BerkeleyLM revision 152 (Pauls and Klein  2011) implements tries based on hash tables and sorted arrays in Java with lossy quantization.This technique was introduced by Clarkson and Rosenfeld (1997) and is also implemented by IRSTLM and BerkeleyLM’s compressed option.Their default variant implements a forward trie  in which words are looked up in their natural left-to-right order.The PROBING model can perform optimistic searches by jumping to any n-gram without needing state and without any additional memory.Most similar is scrolling queries  wherein left-to-right queries that add one word at a time are optimized.Unigrams also have 64-bit overhead for vocabulary lookup.This has the effect of randomly permuting vocabulary identifiers  meeting the requirements of interpolation search when vocabulary identifiers are used as keys.These packages are further described in Section 3.The developer explained that the loading process requires extra memory that it then frees. eBased on the ratio to SRI’s speed reported in Guthrie and Hepple (2010) under different conditions.Our TRIE implements the popular reverse trie  in which the last word of an n-gram is looked up first  as do SRILM  IRSTLM’s inverted variant  and BerkeleyLM except for the scrolling variant.Values in the trie are minimally sized at the bit level  improving memory consumption over trie implementations in SRILM  IRSTLM  and BerkeleyLM.SRILM’s compact variant has an incredibly expensive destructor  dwarfing the time it takes to perform translation  and so we also modified Moses to avoiding the destructor by calling exit instead of returning normally.The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie)  allocating memory all at once (eliminating the need for full pointers)  and being easy to compile.This differs from other implementations (Stolcke  2002; Pauls and Klein  2011) that use hash tables as nodes in a trie  as explained in the next section.For even larger models  storing counts (Talbot and Osborne  2007; Pauls and Klein  2011; Guthrie and Hepple  2010) is a possibility.Further  it needs extra pointers in the trie  increasing model size by 40%.Hieu Hoang named the code “KenLM” and assisted with Moses along with Barry Haddow.Throughout this paper we compare with several packages: SRILM 1.5.12 (Stolcke  2002) is a popular toolkit based on tries used in several decoders.This is similar to using the Linux MAP POPULATE flag that is our default loading mechanism.The BerkeleyLM direct-mapped cache is in principle faster than caches implemented by RandLM and by IRSTLM  so we may write a C++ equivalent implementation as future work.While sorted arrays could be used to implement the same data structure as PROBING  effectively making m = 1  we abandoned this implementation because it is slower and larger than a trie implementation.For even larger models  we recommend RandLM; the memory consumption of the cache is not expected to grow with model size  and it has been reported to scale well.In our case multi-threading is trivial because our data structures are read-only and uncached.Along with locking and background kernel operations such as prefaulting  this explains why wall time is not one-eighth that of the single-threaded case. aLossy compression with the same weights. bLossy compression with retuned weights. the non-lossy options.For sorted lookup  we compare interpolation search  standard C++ binary search  and standard C++ set based on red-black trees.While we have minimized forward-looking state in Section 4.1  machine translation systems could also benefit by minimizing backward-looking state.Another option is the closedsource data structures from Sheffield (Guthrie and Hepple  2010).