Citance Number,Reference Article,Citing Article,Citation Marker Offset,Citation Marker,Citation Offset,Citation Text,Citation Text Clean,Reference Offset,Reference Text,Discourse Facet
1,P11-1060,D11-1039,0,2011,0,"Clarkeet al (2010) and Liang et al (2011) describe approaches for learning semantic parsers from questions paired with database answers, while Goldwasser et al (2011) presents work on unsupervised learning","Clarke et al (2010) and Liang et al (2011) describe approaches for learning semantic parsers from questions paired with database answers, while Goldwasser et al (2011) presents work on unsupervised learning","['57', '39', '60', '22', '167']","<S sid =""57"" ssid = ""33"">But consider Figure 4: (a) is headed by borders  but states needs to be extracted; in (b)  the quantifier no is syntactically dominated by the head verb borders but needs to take wider scope.</S><S sid =""39"" ssid = ""15"">Such a z defines a constraint satisfaction problem (CSP) with nodes as variables.</S><S sid =""60"" ssid = ""36"">Then higher up in the tree  we invoke it with an execute relation Xi to create the desired semantic scope.2 This mark-execute construct acts non-locally  so to maintain compositionality  we must augment the denotation d = JzKw to include any information about the marked nodes in z that can be accessed by an execute relation later on.</S><S sid =""22"" ssid = ""18"">The logical forms in this framework are trees  which is desirable for two reasons: (i) they parallel syntactic dependency trees  which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid =""167"" ssid = ""52"">In DCS  we start with lexical triggers  which are 6 Conclusion more basic than CCG lexical entries.</S>",['Implication_Citation']
2,P11-1060,P13-1092,0,2011,0,"In particular, Clarke et al (2010) and Liang et al (2011) proposed methods to learn from question answer pairs alone, which represents a significant advance","In particular, Clarke et al (2010) and Liang et al (2011) proposed methods to learn from question answer pairs alone, which represents a significant advance","['15', '71', '141', '120', '85']","<S sid =""15"" ssid = ""11"">Unlike standard semantic parsing  our end goal is only to generate the correct y  so we are free to choose the representation for z.</S><S sid =""71"" ssid = ""47"">Let z be a DCS tree.</S><S sid =""141"" ssid = ""26"">Rather than using lexical triggers  several of the other systems use IBM word alignment models to produce an initial word-predicate mapping.</S><S sid =""120"" ssid = ""5"">GEO has 48 non-value predicates and JOBS has 26.</S><S sid =""85"" ssid = ""61"">Extraction allows us to return the set of consistent values of a marked non-root node.</S>",['Implication_Citation']
3,P11-1060,P13-1092,0,2011,0,"To handle syntax-semantics mismatch, GUSP introduces a novel dependency-based meaning representation 1Clarke et al (2010) and Liang et al (2011) used the annotated logical forms to compute answers for their experiments","To handle syntax-semantics mismatch, GUSP introduces a novel dependency-based meaning representation. Clarke et al (2010) and Liang et al (2011) used the annotated logical forms to compute answers for their experiments","['46', '51', '3', '39', '147']","<S sid =""46"" ssid = ""22"">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees  where each z ∈ Z consists of (i) a predicate for each child i  the ji-th component of v must equal the j'i-th component of some t in the child’s denotation (t ∈ JciKw).</S><S sid =""51"" ssid = ""27"">It is impossible to represent the semantics of this phrase with just a CSP  so we introduce a new aggregate relation  notated E. Consider a tree hE:ci  whose root is connected to a child c via E. If the denotation of c is a set of values s  the parent’s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""39"" ssid = ""15"">Such a z defines a constraint satisfaction problem (CSP) with nodes as variables.</S><S sid =""147"" ssid = ""32"">However  training on just these examples is enough to improve the parameters  and this 29% increases to 66% and then to 95% over the next few iterations.</S>",['Results_Citation']
4,P11-1060,P13-1092,0,2011,0,"More recently, Liang et al (2011 )proposedDCS for dependency-based compositional semantics, which represents a semantic parse as a tree with nodes representing database elements and operations, and edges representing relational joins","More recently, Liang et al (2011) proposed DCS for dependency-based compositional semantics, which represents a semantic parse as a tree with nodes representing database elements and operations, and edges representing relational joins","['51', '84', '170', '46', '98']","<S sid =""51"" ssid = ""27"">It is impossible to represent the semantics of this phrase with just a CSP  so we introduce a new aggregate relation  notated E. Consider a tree hE:ci  whose root is connected to a child c via E. If the denotation of c is a set of values s  the parent’s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S><S sid =""84"" ssid = ""60"">There are three cases: Extraction (d.ri = E) In the basic version  the denotation of a tree was always the set of consistent values of the root node.</S><S sid =""170"" ssid = ""55"">Our features as soft preferences.</S><S sid =""46"" ssid = ""22"">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees  where each z ∈ Z consists of (i) a predicate for each child i  the ji-th component of v must equal the j'i-th component of some t in the child’s denotation (t ∈ JciKw).</S><S sid =""98"" ssid = ""74"">The filtering function F rules out improperly-typed trees such as hcity; 00:hstateii.</S>",['Method_Citation']
5,P11-1060,P13-1092,0,"Liang et al, 2011",0,"GUSP represents meaning by a semantic tree, which is similar to DCS (Liang et al, 2011)","GUSP represents meaning by a semantic tree, which is similar to DCS (Liang et al, 2011)","['122', '94', '102', '98', '95']","<S sid =""122"" ssid = ""7"">For JOBS  if we use the standard Jobs database  close to half the y’s are empty  which makes it uninteresting.</S><S sid =""94"" ssid = ""70"">We now turn to the task of mapping natural language For the example in Figure 4(b)  the de- utterances to DCS trees.</S><S sid =""102"" ssid = ""78"">As a running example  consider x = city that is in California and z = hcity; 11:hloc; 21:hCAiii  where city triggers city and California triggers CA.</S><S sid =""98"" ssid = ""74"">The filtering function F rules out improperly-typed trees such as hcity; 00:hstateii.</S><S sid =""95"" ssid = ""71"">Our first question is: given notation of the DCS tree before execution is an utterance x  what trees z ∈ Z are permissible?</S>",['Method_Citation']
6,P11-1060,W12-2802,0,2011,0,"Matuszek et al [2010], Liang et al [2011] and Chen and Mooney [2011] describe models that learn compositional semantics, but word meanings are symbolic structures rather than patterns of features in the external world","Matuszek et al [2010], Liang et al [2011] and Chen and Mooney [2011] describe models that learn compositional semantics, but word meanings are symbolic structures rather than patterns of features in the external world","['22', '3', '6', '84', '162']","<S sid =""22"" ssid = ""18"">The logical forms in this framework are trees  which is desirable for two reasons: (i) they parallel syntactic dependency trees  which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""6"" ssid = ""2"">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid =""84"" ssid = ""60"">There are three cases: Extraction (d.ri = E) In the basic version  the denotation of a tree was always the set of consistent values of the root node.</S><S sid =""162"" ssid = ""47"">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S>",['Method_Citation']
7,P11-1060,P13-2009,0,"Liang et al, 2011",0,"It is well-studied in NLP, and a wide variety of methods have been proposed to tackle it ,e.g. rule-based (Popescu et al, 2003), super vised (Zelle, 1995), unsupervised (Goldwasser et al., 2011), and response-based (Liang et al, 2011)","It is well-studied in NLP, and a wide variety of methods have been proposed to tackle it ,e.g. rule-based (Popescu et al, 2003), super vised (Zelle, 1995), unsupervised (Goldwasser et al., 2011), and response-based (Liang et al, 2011)","['13', '134', '29', '77', '172']","<S sid =""13"" ssid = ""9"">We want to induce latent logical forms z (and parameters 0) given only question-answer pairs (x  y)  which is much cheaper to obtain than (x  z) pairs.</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""29"" ssid = ""5"">Let P be a set of predicates (e.g.  state  count ∈ P)  which are just symbols.</S><S sid =""77"" ssid = ""53"">Join The join of two denotations d and d' with respect to components j and j' (∗ means all components) is formed by concatenating all arrays a of d with all compatible arrays a' of d'  where compatibility means a1j = a'1j0.</S><S sid =""172"" ssid = ""57"">Free from the burden It also allows us to easily add new lexical triggers of annotating logical forms  we hope to use our without becoming mired in the semantic formalism. techniques in developing even more accurate and Quantifiers and superlatives significantly compli- broader-coverage language understanding systems. cate scoping in lambda calculus  and often type rais- Acknowledgments We thank Luke Zettlemoyer ing needs to be employed.</S>",['Method_Citation']
8,P11-1060,D12-1069,0,Liangetal2011,0,"One line of work eliminates the need for an annotated logical form, instead using only the correct answer for a database query (Liangetal2011) or even a binary correct/incorrect signal (Clarke et al2010)","One line of work eliminates the need for an annotated logical form, instead using only the correct answer for a database query (Lianget al 2011) or even a binary correct/incorrect signal (Clarke et al2010)","['96', '88', '94', '124', '162']","<S sid =""96"" ssid = ""72"">To California cities)  and it also allows us to underspecify L. In particular  our L will not include verbs or prepositions; rather  we rely on the predicates corresponding to those words to be triggered by traces.</S><S sid =""88"" ssid = ""64"">Generalized Quantification (d.ri = Q) Generalized quantifiers are predicates on two sets  a restrictor A and a nuclear scope B.</S><S sid =""94"" ssid = ""70"">We now turn to the task of mapping natural language For the example in Figure 4(b)  the de- utterances to DCS trees.</S><S sid =""124"" ssid = ""9"">For each data predicate p (e.g.  language)  we add each possible tuple (e.g.  (job37  Java)) to w(p) independently with probability 0.8.</S><S sid =""162"" ssid = ""47"">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S>",['Method_Citation']
9,P11-1060,N12-1049,0,2011,0,"For example, Liang et al (2011) constructs a latent parse similar in structure to a dependency grammar, but representing a logical form","For example, Liang et al (2011) constructs a latent parse similar in structure to a dependency grammar, but representing a logical form","['108', '3', '84', '134', '46']","<S sid =""108"" ssid = ""84"">However  in order to learn  we need to sum over {z ∈ ZL(x) : JzKw = y}  and unfortunately  the additional constraint JzKw = y does not factorize.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""84"" ssid = ""60"">There are three cases: Extraction (d.ri = E) In the basic version  the denotation of a tree was always the set of consistent values of the root node.</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""46"" ssid = ""22"">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees  where each z ∈ Z consists of (i) a predicate for each child i  the ji-th component of v must equal the j'i-th component of some t in the child’s denotation (t ∈ JciKw).</S>",['Method_Citation']
10,P11-1060,P12-1045,0,2011,0,Clarke et al (2010) and Liang et al (2011) trained systems on question and answer pairs by automatically finding semantic interpretations of the questions that would generate the correct answers,Clarke et al (2010) and Liang et al (2011) trained systems on question and answer pairs by automatically finding semantic interpretations of the questions that would generate the correct answers,"['22', '98', '77', '162', '88']","<S sid =""22"" ssid = ""18"">The logical forms in this framework are trees  which is desirable for two reasons: (i) they parallel syntactic dependency trees  which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid =""98"" ssid = ""74"">The filtering function F rules out improperly-typed trees such as hcity; 00:hstateii.</S><S sid =""77"" ssid = ""53"">Join The join of two denotations d and d' with respect to components j and j' (∗ means all components) is formed by concatenating all arrays a of d with all compatible arrays a' of d'  where compatibility means a1j = a'1j0.</S><S sid =""162"" ssid = ""47"">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid =""88"" ssid = ""64"">Generalized Quantification (d.ri = Q) Generalized quantifiers are predicates on two sets  a restrictor A and a nuclear scope B.</S>",['Implication_Citation']
11,P11-1060,P14-1008,0,"Liang et al,2011",0,"Dependency-based Compositional Semantics (DCS) provides an intuitive way to model semantics of questions, by using simple dependency-like trees (Liang et al, 2011)","Dependency-based Compositional Semantics (DCS) provides an intuitive way to model semantics of questions, by using simple dependency-like trees (Liang et al, 2011)","['12', '134', '3', '141', '98']","<S sid =""12"" ssid = ""8"">We represent logical forms z as labeled trees  induced automatically from (x  y) pairs.</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""141"" ssid = ""26"">Rather than using lexical triggers  several of the other systems use IBM word alignment models to produce an initial word-predicate mapping.</S><S sid =""98"" ssid = ""74"">The filtering function F rules out improperly-typed trees such as hcity; 00:hstateii.</S>",['Method_Citation']
12,P11-1060,P14-1008,0,"Liang et al, 2011",0,"DCS trees has been proposed to represent natural language semantics with a structure similar to dependency trees (Liang et al, 2011) (Figure 1)","DCS trees has been proposed to represent natural language semantics with a structure similar to dependency trees (Liang et al, 2011) (Figure 1)","['3', '29', '77', '129', '8']","<S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""29"" ssid = ""5"">Let P be a set of predicates (e.g.  state  count ∈ P)  which are just symbols.</S><S sid =""77"" ssid = ""53"">Join The join of two denotations d and d' with respect to components j and j' (∗ means all components) is formed by concatenating all arrays a of d with all compatible arrays a' of d'  where compatibility means a1j = a'1j0.</S><S sid =""129"" ssid = ""14"">We also define an augmented lexicon L+ which includes a prototype word x for each predicate appearing in (iii) above (e.g.  (large  size))  which cancels the predicates triggered by x’s POS tag.</S><S sid =""8"" ssid = ""4"">On the other hand  existing unsupervised semantic parsers (Poon and Domingos  2009) do not handle deeper linguistic phenomena such as quantification  negation  and superlatives.</S>",['Method_Citation']
13,P11-1060,P14-1008,0,"Liang et al, 2011",0,"are explained in? 2.5. 5http: //nlp.stanford.edu/software/corenlp.shtml 6 In (Liang et al, 2011) DCS trees are learned from QApairs and database entries","In (Liang et al, 2011) DCS trees are learned from QA pairs and database entries","['46', '142', '10', '144', '112']","<S sid =""46"" ssid = ""22"">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees  where each z ∈ Z consists of (i) a predicate for each child i  the ji-th component of v must equal the j'i-th component of some t in the child’s denotation (t ∈ JciKw).</S><S sid =""142"" ssid = ""27"">This option is not available to us since we do not have annotated logical forms  so we must instead rely on lexical triggers to define the search space.</S><S sid =""10"" ssid = ""6"">However  we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid =""144"" ssid = ""29"">Intuitions How is our system learning?</S><S sid =""112"" ssid = ""88"">Our learning algorithm alternates between (i) using the current parameters θ to generate the K-best set ˜ZL θ(x) for each training example x  and (ii) optimizing the parameters to put probability mass on the correct trees in these sets; sets containing no correct answers are skipped.</S>",['Method_Citation']
14,P11-1060,P14-1008,0,"Liang et al, 2011",0,"as in the sentence? Tropi cal storm Debby is blamed for death?, which is a tropical storm, is Debby, etc. Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to a FOL formula, and the abstract denotation of the germ corresponds to the set of consistent values (Liang et al, 2011) of that variable","Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to a FOL formula, and the abstract denotation of the germ corresponds to the set of consistent values (Liang et al, 2011) of that variable","['133', '134', '163', '141', '10']","<S sid =""133"" ssid = ""18"">Table 2 shows that our system using lexical triggers L (henceforth  DCS) outperforms SEMRESP (78.9% over 73.2%).</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""141"" ssid = ""26"">Rather than using lexical triggers  several of the other systems use IBM word alignment models to produce an initial word-predicate mapping.</S><S sid =""10"" ssid = ""6"">However  we still model the logical form (now as a latent variable) to capture the complexities of language.</S>",['Results_Citation']
15,P11-1060,D11-1140,0,2011,0,Clarke et al (2010) and Liang et al (2011) replace semantic annotations in the training set with target answers which are more easily available,Clarke et al (2010) and Liang et al (2011) replace semantic annotations in the training set with target answers which are more easily available,"['86', '162', '77', '3', '113']","<S sid =""86"" ssid = ""62"">Formally  extraction simply moves the i-th column to the front: Xi(d) = d[i  −(i  ø)]{α1 = ø}.</S><S sid =""162"" ssid = ""47"">The lexicon en- tions computed against a world (grounding) is becodes information about how each word can used in coming increasingly popular.</S><S sid =""77"" ssid = ""53"">Join The join of two denotations d and d' with respect to components j and j' (∗ means all components) is formed by concatenating all arrays a of d with all compatible arrays a' of d'  where compatibility means a1j = a'1j0.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""113"" ssid = ""89"">Formally  let ˜O(θ  θ') be the objective function O(θ) with ZL(x) ˜ZL θI(x).</S>",['Implication_Citation']
16,P11-1060,D11-1140,0,"Liang et al, 2011",0,"and Collins, 2005, 2007),? -WASP (Wong and Mooney, 2007), UBL (Kwiatkowski et al, 2010) systems and DCS (Liang et al, 2011)","WASP (Wong and Mooney, 2007), UBL (Kwiatkowski et al, 2010) systems and DCS (Liang et al, 2011)","['10', '134', '3', '55', '80']","<S sid =""10"" ssid = ""6"">However  we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""55"" ssid = ""31"">The tree structure still enables us to compute denotations efficiently based on (1) and (2).</S><S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S>",['Method_Citation']
17,P11-1060,P13-1007,0,2011,0,"In general, every plural NPpotentially introduces an implicit universal, ranging 1For example, Liang et al (2011) in their state-of-the-art statistical semantic parser within the domain of natural language queries to databases, explicitly devise quantifier scoping in the semantic model","For example, Liang et al (2011) in their state-of-the-art statistical semantic parser within the domain of natural language queries to databases, explicitly devise quantifier scoping in the semantic model","['22', '134', '154', '50', '113']","<S sid =""22"" ssid = ""18"">The logical forms in this framework are trees  which is desirable for two reasons: (i) they parallel syntactic dependency trees  which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""154"" ssid = ""39"">The restriction to present (for example  [in  loc] has high weight). trees is similar to economical DRT (Bos  2009).</S><S sid =""50"" ssid = ""26"">For example  consider the phrase number of major cities  and suppose that number corresponds to the count predicate.</S><S sid =""113"" ssid = ""89"">Formally  let ˜O(θ  θ') be the objective function O(θ) with ZL(x) ˜ZL θI(x).</S>",['Results_Citation']
18,P11-1060,D11-1022,0,2011,0,"DD-ADMM may be useful in other frameworks involving logical constraints, such as the models for compositional semantics presented by Liang et al (2011)","DD-ADMM may be useful in other frameworks involving logical constraints, such as the models for compositional semantics presented by Liang et al (2011)","['6', '134', '3', '12', '126']","<S sid =""6"" ssid = ""2"">Answering these types of complex questions compositionally involves first mapping the questions into logical forms (semantic parsing).</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""12"" ssid = ""8"">We represent logical forms z as labeled trees  induced automatically from (x  y) pairs.</S><S sid =""126"" ssid = ""11"">During development  we further held out a random 30% of the training sets for validation.</S>",['Aim_Citation']
19,P11-1060,P12-1051,0,2011,0,"In fact, for any CFG G, it 1See Liang et al (2011) for work in representing lambda calculus expressions with trees","In fact, for any CFG G, it 1See Liang et al (2011) for work in representing lambda calculus expressions with trees","['132', '9', '10', '172', '134']","<S sid =""132"" ssid = ""17"">Results We first compare our system with Clarke et al. (2010) (henceforth  SEMRESP)  which also learns a semantic parser from question-answer pairs.</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""10"" ssid = ""6"">However  we still model the logical form (now as a latent variable) to capture the complexities of language.</S><S sid =""172"" ssid = ""57"">Free from the burden It also allows us to easily add new lexical triggers of annotating logical forms  we hope to use our without becoming mired in the semantic formalism. techniques in developing even more accurate and Quantifiers and superlatives significantly compli- broader-coverage language understanding systems. cate scoping in lambda calculus  and often type rais- Acknowledgments We thank Luke Zettlemoyer ing needs to be employed.</S><S sid =""134"" ssid = ""19"">In fact  although neither DCS nor SEMRESP uses logical forms  DCS uses even less supervision than SEMRESP.</S>",['Method_Citation']
