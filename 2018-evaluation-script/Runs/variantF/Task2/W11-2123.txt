Lossy compressed models RandLM (Talbot and Osborne  2007) and Sheffield (Guthrie and Hepple  2010) offer better memory consumption at the expense of CPU and accuracy.We implement two data structures: PROBING  designed for speed  and TRIE  optimized for memory.Time for Moses itself to load  including loading the language model and phrase table  is included.The code is opensource  has minimal dependencies  and offers both C++ and Java interfaces for integration.This technique was introduced by Clarkson and Rosenfeld (1997) and is also implemented by IRSTLM and BerkeleyLM’s compressed option.The binary language model from Section 5.2 and text phrase table were forced into disk cache before each run.Tokens were converted to vocabulary identifiers in advance and state was carried from each query to the next.This differs from other implementations (Stolcke  2002; Pauls and Klein  2011) that use hash tables as nodes in a trie  as explained in the next section.The first value reports use immediately after loading while the second reports the increase during scoring. dBerkeleyLM is written in Java which requires memory be specified in advance.If they knew that the first four words in a hypergraph node would never extend to the left and form a 5-gram  then three or even fewer words could be kept in the backward state.We run the baseline Moses system for the French-English track of the 2011 Workshop on Machine Translation 9 translating the 3003-sentence test set.For the PROBING implementation  hash table sizes are in the millions  so the most relevant values are on the right size of the graph  where linear probing wins.We incur some additional memory cost due to storing state in each hypothesis  though this is minimal compared with the size of the model itself.In all of our experiments  the binary file (whether mapped or  in the case of most other packages  interpreted) is loaded into the disk cache in advance so that lazy mapping will never fault to disk.As the name implies  space is O(m) and linear in the number of entries.We use two common techniques  hash tables and sorted arrays  describing each before the model that uses the technique.The TRIE model continues to use the least memory of ing (-P) with MAP POPULATE  the default.We present KenLM  a library that implements two data structures for efficient language model queries  reducing both time and costs.Our TRIE implements the popular reverse trie  in which the last word of an n-gram is looked up first  as do SRILM  IRSTLM’s inverted variant  and BerkeleyLM except for the scrolling variant.In line with perplexity results from Table 1  the PROBING model is the fastest followed by TRIE  and subsequently other packages.For the perplexity and translation tasks  we used SRILM to build a 5-gram English language model on 834 million tokens from Europarl v6 (Koehn  2005) and the 2011 Workshop on Machine Translation News Crawl corpus with duplicate lines removed.The PROBING model was designed to improve upon SRILM by using linear probing hash tables (though not arranged in a trie)  allocating memory all at once (eliminating the need for full pointers)  and being easy to compile.The authors provided us with a ratio between TPT and SRI under different conditions. aLossy compression with the same weights. bLossy compression with retuned weights. ditions make the value appropriate for estimating repeated run times  such as in parameter tuning.The trie data structure is commonly used for language modeling.Hash tables are a common sparse mapping technique used by SRILM’s default and BerkeleyLM’s hashed variant.The compressed variant uses block compression and is rather slow as a result.The structure uses linear probing hash tables and is designed for speed.KenLM: Faster and Smaller Language Model QueriesNodes in the trie are based on arrays sorted by vocabulary identifier.Using RandLM and the documented settings (8-bit values and 1 256 false-positive probability)  we built a stupid backoff model on the same data as in Section 5.2.Floating point values may be stored in the trie exactly  using 31 bits for non-positive log probability and 32 bits for backoff5.The set of n-grams appearing in a model is sparse  and we want to efficiently find their associated probabilities and backoff penalties.Moses keeps language models and many other resources in static variables  so these are still resident in memory.To quantize  we use the binning method (Federico and Bertoldi  2006) that sorts values  divides into equally sized bins  and averages within each bin.Our code is thread-safe  and integrated into the Moses  cdec  and Joshua translation systems.These are written to the state s(wn1) and returned so that they can be used for the following query.Our TRIE implementation is designed to improve upon IRSTLM using a reverse trie with improved search  bit level packing  and stateful queries.This is especially bad with PROBING because it is based on hashing and performs random lookups  but it is not intended to be used in low-memory scenarios.Each trie node is individually allocated and full 64-bit pointers are used to find them  wasting memory.The state function is integrated into the query process so that  in lieu of the query p(wnjwn−1 1 )  the application issues query p(wnjs(wn−1 1 )) which also returns s(wn1 ).TPT has theoretically better locality because it stores ngrams near their suffixes  thereby placing reads for a single query in the same or adjacent pages.As noted in Section 1  our code finds the longest matching entry wnf for query p(wn|s(wn−1 f ) The probability p(wn|wn−1 f ) is stored with wnf and the backoffs are immediately accessible in the provided state s(wn−1 When our code walks the data structure to find wnf   it visits wnn  wnn−1  ...   wnf .Along with locking and background kernel operations such as prefaulting  this explains why wall time is not one-eighth that of the single-threaded case. aLossy compression with the same weights. bLossy compression with retuned weights. the non-lossy options.Applications such as machine translation use language model probability as a feature to assist in choosing between hypotheses.IRSTLM (Federico et al.  2008) is an open-source toolkit for building and querying language models.For even larger models  we recommend RandLM; the memory consumption of the cache is not expected to grow with model size  and it has been reported to scale well.Dynamic programming efficiently scores many hypotheses by exploiting the fact that an N-gram language model conditions on at most N − 1 preceding words.Our implementation permits jumping to any n-gram of any length with a single lookup; this appears to be unique among language model implementations.Performance improvements transfer to the Moses (Koehn et al.  2007)  cdec (Dyer et al.  2010)  and Joshua (Li et al.  2009) translation systems where our code has been integrated.For example  syntactic decoders (Koehn et al.  2007; Dyer et al.  2010; Li et al.  2009) perform dynamic programming parametrized by both backward- and forward-looking state.All language model queries issued by machine translation decoders follow a left-to-right pattern  starting with either the begin of sentence token or null context for mid-sentence fragments.We evaluate the time and memory consumption of each data structure by computing perplexity on 4 billion tokens from the English Gigaword corpus (Parker et al.  2009).