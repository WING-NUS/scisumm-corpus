Citance Number,Reference Article,Citing Article,Citation Marker Offset,Citation Marker,Citation Offset,Citation Text,Citation Text Clean,Reference Offset,Reference Text,Discourse Facet
1,P11-1060,D11-1039,0,2011,0,"Clarkeet al (2010) and Liang et al (2011) describe approaches for learning semantic parsers from questions paired with database answers, while Goldwasser et al (2011) presents work on unsupervised learning","Clarke et al (2010) and Liang et al (2011) describe approaches for learning semantic parsers from questions paired with database answers, while Goldwasser et al (2011) presents work on unsupervised learning","['165', '163', '9', '20', '157']","<S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""157"" ssid = ""42"">Eisenciations due to data sparsity  and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large K. uses them as features in another learning problem.</S>",['Method_Citation']
2,P11-1060,P13-1092,0,2011,0,"In particular, Clarke et al (2010) and Liang et al (2011) proposed methods to learn from question answer pairs alone, which represents a significant advance","In particular, Clarke et al (2010) and Liang et al (2011) proposed methods to learn from question answer pairs alone, which represents a significant advance","['132', '165', '20', '9', '160']","<S sid =""132"" ssid = ""17"">Results We first compare our system with Clarke et al. (2010) (henceforth  SEMRESP)  which also learns a semantic parser from question-answer pairs.</S><S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""160"" ssid = ""45"">To contrast  consider et al. (2010)  which we discussed earlier.</S>",['Method_Citation']
3,P11-1060,P13-1092,0,2011,0,"To handle syntax-semantics mismatch, GUSP introduces a novel dependency-based meaning representation 1Clarke et al (2010) and Liang et al (2011) used the annotated logical forms to compute answers for their experiments","To handle syntax-semantics mismatch, GUSP introduces a novel dependency-based meaning representation. Clarke et al (2010) and Liang et al (2011) used the annotated logical forms to compute answers for their experiments","['9', '20', '163', '165', '80']","<S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S>",['Method_Citation']
4,P11-1060,P13-1092,0,2011,0,"More recently, Liang et al (2011 )proposedDCS for dependency-based compositional semantics, which represents a semantic parse as a tree with nodes representing database elements and operations, and edges representing relational joins","More recently, Liang et al (2011) proposed DCS for dependency-based compositional semantics, which represents a semantic parse as a tree with nodes representing database elements and operations, and edges representing relational joins","['171', '36', '173', '163', '21']","<S sid =""171"" ssid = ""56"">This yields a more system is based on a new semantic representation  factorized and flexible representation that is easier DCS  which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S><S sid =""36"" ssid = ""12"">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S><S sid =""173"" ssid = ""58"">In DCS  the mark-execute and Tom Kwiatkowski for providing us with data construct provides a flexible framework for dealing and answering questions.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""21"" ssid = ""17"">The main technical contribution of this work is a new semantic representation  dependency-based compositional semantics (DCS)  which is both simple and expressive (Section 2).</S>",['Implication_Citation']
5,P11-1060,P13-1092,0,"Liang et al, 2011",0,"GUSP represents meaning by a semantic tree, which is similar to DCS (Liang et al, 2011)","GUSP represents meaning by a semantic tree, which is similar to DCS (Liang et al, 2011)","['171', '140', '36', '163', '51']","<S sid =""171"" ssid = ""56"">This yields a more system is based on a new semantic representation  factorized and flexible representation that is easier DCS  which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S><S sid =""140"" ssid = ""25"">Table 3 shows that even DCS  which does not use prototypes  is comparable to the best previous system (Kwiatkowski et al.  2010)  and by adding a few prototypes  DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid =""36"" ssid = ""12"">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""51"" ssid = ""27"">It is impossible to represent the semantics of this phrase with just a CSP  so we introduce a new aggregate relation  notated E. Consider a tree hE:ci  whose root is connected to a child c via E. If the denotation of c is a set of values s  the parentâ€™s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S>",['Method_Citation']
6,P11-1060,W12-2802,0,2011,0,"Matuszek et al [2010], Liang et al [2011] and Chen and Mooney [2011] describe models that learn compositional semantics, but word meanings are symbolic structures rather than patterns of features in the external world","Matuszek et al [2010], Liang et al [2011] and Chen and Mooney [2011] describe models that learn compositional semantics, but word meanings are symbolic structures rather than patterns of features in the external world","['20', '7', '165', '163', '80']","<S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""7"" ssid = ""3"">Supervised semantic parsers (Zelle and Mooney  1996; Tang and Mooney  2001; Ge and Mooney  2005; Zettlemoyer and Collins  2005; Kate and Mooney  2007; Zettlemoyer and Collins  2007; Wong and Mooney  2007; Kwiatkowski et al.  2010) rely on manual annotation of logical forms  which is expensive.</S><S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S>",['Method_Citation']
7,P11-1060,P13-2009,0,"Liang et al, 2011",0,"It is well-studied in NLP, and a wide variety of methods have been proposed to tackle it ,e.g. rule-based (Popescu et al, 2003), super vised (Zelle, 1995), unsupervised (Goldwasser et al., 2011), and response-based (Liang et al, 2011)","It is well-studied in NLP, and a wide variety of methods have been proposed to tackle it ,e.g. rule-based (Popescu et al, 2003), super vised (Zelle, 1995), unsupervised (Goldwasser et al., 2011), and response-based (Liang et al, 2011)","['165', '163', '20', '157', '22']","<S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""157"" ssid = ""42"">Eisenciations due to data sparsity  and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large K. uses them as features in another learning problem.</S><S sid =""22"" ssid = ""18"">The logical forms in this framework are trees  which is desirable for two reasons: (i) they parallel syntactic dependency trees  which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S>",['Method_Citation']
8,P11-1060,D12-1069,0,Liangetal2011,0,"One line of work eliminates the need for an annotated logical form, instead using only the correct answer for a database query (Liangetal2011) or even a binary correct/incorrect signal (Clarke et al2010)","One line of work eliminates the need for an annotated logical form, instead using only the correct answer for a database query (Lianget al 2011) or even a binary correct/incorrect signal (Clarke et al2010)","['146', '89', '9', '80', '51']","<S sid =""146"" ssid = ""31"">We find that only for a small fraction of training examples do the K-best sets contain any trees yielding the correct answer (29% for DCS on GEO).</S><S sid =""89"" ssid = ""65"">For example  In a DCS tree  the quantifier appears as the child of a Q relation  and the restrictor is the parent (see Figure 4(b) for an example).</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S><S sid =""51"" ssid = ""27"">It is impossible to represent the semantics of this phrase with just a CSP  so we introduce a new aggregate relation  notated E. Consider a tree hE:ci  whose root is connected to a child c via E. If the denotation of c is a set of values s  the parentâ€™s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S>",['Method_Citation']
9,P11-1060,N12-1049,0,2011,0,"For example, Liang et al (2011) constructs a latent parse similar in structure to a dependency grammar, but representing a logical form","For example, Liang et al (2011) constructs a latent parse similar in structure to a dependency grammar, but representing a logical form","['35', '3', '171', '118', '41']","<S sid =""35"" ssid = ""11"">Although a DCS tree is a logical form  note that it looks like a syntactic dependency tree with predicates in place of words.</S><S sid =""3"" ssid = ""3"">In tackling this challenging learning problem  we introduce a new semantic representation which highlights a parallel between dependency syntax and efficient evaluation of logical forms.</S><S sid =""171"" ssid = ""56"">This yields a more system is based on a new semantic representation  factorized and flexible representation that is easier DCS  which offers a simple and expressive alterto search through and parametrize using features. native to lambda calculus.</S><S sid =""118"" ssid = ""3"">This evaluation is done with respect to a world w. Recall that a world w maps each predicate p âˆˆ P to a set of tuples w(p).</S><S sid =""41"" ssid = ""17"">We say a value v is consistent for a node x if there exists a solution that assigns v to x.</S>",['Method_Citation']
10,P11-1060,P12-1045,0,2011,0,Clarke et al (2010) and Liang et al (2011) trained systems on question and answer pairs by automatically finding semantic interpretations of the questions that would generate the correct answers,Clarke et al (2010) and Liang et al (2011) trained systems on question and answer pairs by automatically finding semantic interpretations of the questions that would generate the correct answers,"['9', '20', '163', '80', '138']","<S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S><S sid =""138"" ssid = ""23"">Next  we compared our systems (DCS and DCS+) with the state-of-the-art semantic parsers on the full dataset for both GEO and JOBS (see Table 3).</S>",['Implication_Citation']
11,P11-1060,P14-1008,0,"Liang et al,2011",0,"Dependency-based Compositional Semantics (DCS) provides an intuitive way to model semantics of questions, by using simple dependency-like trees (Liang et al, 2011)","Dependency-based Compositional Semantics (DCS) provides an intuitive way to model semantics of questions, by using simple dependency-like trees (Liang et al, 2011)","['36', '25', '59', '9', '60']","<S sid =""36"" ssid = ""12"">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S><S sid =""25"" ssid = ""1"">We first present a basic version (Section 2.1) of dependency-based compositional semantics (DCS)  which captures the core idea of using trees to represent formal semantics.</S><S sid =""59"" ssid = ""35"">The key idea that allows us to give semanticallyscoped denotations to syntactically-scoped trees is as follows: We mark a node low in the tree with a mark relation (one of E  Q  or C).</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""60"" ssid = ""36"">Then higher up in the tree  we invoke it with an execute relation Xi to create the desired semantic scope.2 This mark-execute construct acts non-locally  so to maintain compositionality  we must augment the denotation d = JzKw to include any information about the marked nodes in z that can be accessed by an execute relation later on.</S>",['Method_Citation']
12,P11-1060,P14-1008,0,"Liang et al, 2011",0,"DCS trees has been proposed to represent natural language semantics with a structure similar to dependency trees (Liang et al, 2011) (Figure 1)","DCS trees has been proposed to represent natural language semantics with a structure similar to dependency trees (Liang et al, 2011) (Figure 1)","['154', '35', '59', '36', '94']","<S sid =""154"" ssid = ""39"">The restriction to present (for example  [in  loc] has high weight). trees is similar to economical DRT (Bos  2009).</S><S sid =""35"" ssid = ""11"">Although a DCS tree is a logical form  note that it looks like a syntactic dependency tree with predicates in place of words.</S><S sid =""59"" ssid = ""35"">The key idea that allows us to give semanticallyscoped denotations to syntactically-scoped trees is as follows: We mark a node low in the tree with a mark relation (one of E  Q  or C).</S><S sid =""36"" ssid = ""12"">It is this transparency between syntax and semantics provided by DCS which leads to a simple and streamlined compositional semantics suitable for program induction.</S><S sid =""94"" ssid = ""70"">We now turn to the task of mapping natural language For the example in Figure 4(b)  the de- utterances to DCS trees.</S>",['Implication_Citation']
13,P11-1060,P14-1008,0,"Liang et al, 2011",0,"are explained in? 2.5. 5http: //nlp.stanford.edu/software/corenlp.shtml 6 In (Liang et al, 2011) DCS trees are learned from QApairs and database entries","In (Liang et al, 2011) DCS trees are learned from QA pairs and database entries","['45', '165', '22', '107', '167']","<S sid =""45"" ssid = ""21"">The logical forms in DCS are called DCS trees  where nodes are labeled with predicates  and edges are labeled with relations.</S><S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""22"" ssid = ""18"">The logical forms in this framework are trees  which is desirable for two reasons: (i) they parallel syntactic dependency trees  which facilitates parsing and learning; and (ii) evaluating them to obtain the answer is computationally efficient.</S><S sid =""107"" ssid = ""83"">Our model is arc-factored  so we can sum over all DCS trees in ZL(x) using dynamic programming.</S><S sid =""167"" ssid = ""52"">In DCS  we start with lexical triggers  which are 6 Conclusion more basic than CCG lexical entries.</S>",['Method_Citation']
14,P11-1060,P14-1008,0,"Liang et al, 2011",0,"as in the sentence? Tropi cal storm Debby is blamed for death?, which is a tropical storm, is Debby, etc. Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to a FOL formula, and the abstract denotation of the germ corresponds to the set of consistent values (Liang et al, 2011) of that variable","Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to a FOL formula, and the abstract denotation of the germ corresponds to the set of consistent values (Liang et al, 2011) of that variable","['80', '51', '84', '89', '46']","<S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S><S sid =""51"" ssid = ""27"">It is impossible to represent the semantics of this phrase with just a CSP  so we introduce a new aggregate relation  notated E. Consider a tree hE:ci  whose root is connected to a child c via E. If the denotation of c is a set of values s  the parentâ€™s denotation is then a singleton set containing s. Formally: Figure 3(a) shows the DCS tree for our running example.</S><S sid =""84"" ssid = ""60"">There are three cases: Extraction (d.ri = E) In the basic version  the denotation of a tree was always the set of consistent values of the root node.</S><S sid =""89"" ssid = ""65"">For example  In a DCS tree  the quantifier appears as the child of a Q relation  and the restrictor is the parent (see Figure 4(b) for an example).</S><S sid =""46"" ssid = ""22"">Formally: Definition 1 (DCS trees) Let Z be the set of DCS trees  where each z âˆˆ Z consists of (i) a predicate for each child i  the ji-th component of v must equal the j'i-th component of some t in the childâ€™s denotation (t âˆˆ JciKw).</S>",['Method_Citation']
15,P11-1060,D11-1140,0,2011,0,Clarke et al (2010) and Liang et al (2011) replace semantic annotations in the training set with target answers which are more easily available,Clarke et al (2010) and Liang et al (2011) replace semantic annotations in the training set with target answers which are more easily available,"['163', '20', '165', '9', '132']","<S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""132"" ssid = ""17"">Results We first compare our system with Clarke et al. (2010) (henceforth  SEMRESP)  which also learns a semantic parser from question-answer pairs.</S>",['Implication_Citation']
16,P11-1060,D11-1140,0,"Liang et al, 2011",0,"and Collins, 2005, 2007),? -WASP (Wong and Mooney, 2007), UBL (Kwiatkowski et al, 2010) systems and DCS (Liang et al, 2011)","WASP (Wong and Mooney, 2007), UBL (Kwiatkowski et al, 2010) systems and DCS (Liang et al, 2011)","['165', '7', '140', '157', '163']","<S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""7"" ssid = ""3"">Supervised semantic parsers (Zelle and Mooney  1996; Tang and Mooney  2001; Ge and Mooney  2005; Zettlemoyer and Collins  2005; Kate and Mooney  2007; Zettlemoyer and Collins  2007; Wong and Mooney  2007; Kwiatkowski et al.  2010) rely on manual annotation of logical forms  which is expensive.</S><S sid =""140"" ssid = ""25"">Table 3 shows that even DCS  which does not use prototypes  is comparable to the best previous system (Kwiatkowski et al.  2010)  and by adding a few prototypes  DCS+ offers a decisive edge (91.1% over 88.9% on GEO).</S><S sid =""157"" ssid = ""42"">Eisenciations due to data sparsity  and having an insuffi- stein et al. (2009) induces conjunctive formulae and ciently large K. uses them as features in another learning problem.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S>",['Method_Citation']
17,P11-1060,P13-1007,0,2011,0,"In general, every plural NPpotentially introduces an implicit universal, ranging 1For example, Liang et al (2011) in their state-of-the-art statistical semantic parser within the domain of natural language queries to databases, explicitly devise quantifier scoping in the semantic model","For example, Liang et al (2011) in their state-of-the-art statistical semantic parser within the domain of natural language queries to databases, explicitly devise quantifier scoping in the semantic model","['80', '94', '9', '161', '47']","<S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S><S sid =""94"" ssid = ""70"">We now turn to the task of mapping natural language For the example in Figure 4(b)  the de- utterances to DCS trees.</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""161"" ssid = ""46"">CCG (Steedman  2000)  in which semantic pars- The integration of natural language with denotaing is driven from the lexicon.</S><S sid =""47"" ssid = ""23"">This algorithm is linear in the number of nodes times the size of the denotations.1 Now the dual importance of trees in DCS is clear: We have seen that trees parallel syntactic dependency structure  which will facilitate parsing.</S>",['Aim_Citation']
18,P11-1060,D11-1022,0,2011,0,"DD-ADMM may be useful in other frameworks involving logical constraints, such as the models for compositional semantics presented by Liang et al (2011)","DD-ADMM may be useful in other frameworks involving logical constraints, such as the models for compositional semantics presented by Liang et al (2011)","['80', '9', '163', '20', '138']","<S sid =""80"" ssid = ""56"">The full definition of join is as follows: Aggregate The aggregate operation takes a denotation and forms a set out of the tuples in the first column for each setting of the rest of the columns: Now we turn to the mark (M) and execute (Xi) operations  which handles the divergence between syntactic and semantic scope.</S><S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""163"" ssid = ""48"">Feedback from the context; for example  the lexical entry for borders world has been used to guide both syntactic parsing is S\NP/NP : Ay.Ax.border(x  y)  which means (Schuler  2003) and semantic parsing (Popescu et borders looks right for the first argument and left al.  2003; Clarke et al.  2010).</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S><S sid =""138"" ssid = ""23"">Next  we compared our systems (DCS and DCS+) with the state-of-the-art semantic parsers on the full dataset for both GEO and JOBS (see Table 3).</S>",['Aim_Citation']
19,P11-1060,P12-1051,0,2011,0,"In fact, for any CFG G, it 1See Liang et al (2011) for work in representing lambda calculus expressions with trees","In fact, for any CFG G, it 1See Liang et al (2011) for work in representing lambda calculus expressions with trees","['9', '172', '173', '165', '20']","<S sid =""9"" ssid = ""5"">As in Clarke et al. (2010)  we obviate the need for annotated logical forms by considering the endto-end problem of mapping questions to answers.</S><S sid =""172"" ssid = ""57"">Free from the burden It also allows us to easily add new lexical triggers of annotating logical forms  we hope to use our without becoming mired in the semantic formalism. techniques in developing even more accurate and Quantifiers and superlatives significantly compli- broader-coverage language understanding systems. cate scoping in lambda calculus  and often type rais- Acknowledgments We thank Luke Zettlemoyer ing needs to be employed.</S><S sid =""173"" ssid = ""58"">In DCS  the mark-execute and Tom Kwiatkowski for providing us with data construct provides a flexible framework for dealing and answering questions.</S><S sid =""165"" ssid = ""50"">These rules are often too stringent  cused on aligning text to a world (Liang et al.  2009)  and for complex utterances  especially in free word- using text in reinforcement learning (Branavan et al.  order languages  either disharmonic combinators are 2009; Branavan et al.  2010)  and many others.</S><S sid =""20"" ssid = ""16"">At the same time  representations such as FunQL (Kate et al.  2005)  which was used in Clarke et al. (2010)  are simpler but lack the full expressive power of lambda calculus.</S>","['Implication_Citation', 'Aim_Citation']"
